var JsonRefs =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: clearCache, decodePath, encodePath, findRefs, findRefsAt, getRefDetails, isPtr, isRef, pathFromPtr, pathToPtr, resolveRefs, resolveRefsAt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearCache", function() { return clearCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePath", function() { return decodePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodePath", function() { return encodePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findRefs", function() { return findRefs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findRefsAt", function() { return findRefsAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRefDetails", function() { return getRefDetails; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPtr", function() { return isPtr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isRef", function() { return isRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pathFromPtr", function() { return pathFromPtr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pathToPtr", function() { return pathToPtr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveRefs", function() { return resolveRefs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveRefsAt", function() { return resolveRefsAt; });
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! graphlib */ "./node_modules/graphlib/index.js");
/* harmony import */ var graphlib__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(graphlib__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "./node_modules/path-browserify/index.js");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var path_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path-loader */ "./node_modules/path-loader/index.js");
/* harmony import */ var path_loader__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path_loader__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var slash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! slash */ "./node_modules/slash/index.js");
/* harmony import */ var slash__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(slash__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var uri_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! uri-js */ "./node_modules/uri-js/dist/es5/uri.all.js");
/* harmony import */ var uri_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(uri_js__WEBPACK_IMPORTED_MODULE_6__);
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */







var badPtrTokenRegex = /~(?:[^01]|$)/g;
var remoteCache = {};
var remoteTypes = ['relative', 'remote'];
var remoteUriTypes = ['absolute', 'uri'];
var uriDetailsCache = {};
/* Internal Functions */

function combineQueryParams(qs1, qs2) {
  var combined = {};

  function mergeQueryParams(obj) {
    lodash__WEBPACK_IMPORTED_MODULE_0___default.a.forOwn(obj, function (val, key) {
      combined[key] = val;
    });
  }

  mergeQueryParams(querystring__WEBPACK_IMPORTED_MODULE_4___default.a.parse(qs1 || ''));
  mergeQueryParams(querystring__WEBPACK_IMPORTED_MODULE_4___default.a.parse(qs2 || ''));
  return Object.keys(combined).length === 0 ? undefined : querystring__WEBPACK_IMPORTED_MODULE_4___default.a.stringify(combined);
}

function combineURIs(u1, u2) {
  // Convert Windows paths
  if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(u1)) {
    u1 = slash__WEBPACK_IMPORTED_MODULE_5___default()(u1);
  }

  if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(u2)) {
    u2 = slash__WEBPACK_IMPORTED_MODULE_5___default()(u2);
  }

  var u2Details = parseURI(lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(u2) ? '' : u2);
  var u1Details;
  var combinedDetails;

  if (remoteUriTypes.indexOf(u2Details.reference) > -1) {
    combinedDetails = u2Details;
  } else {
    u1Details = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(u1) ? undefined : parseURI(u1);

    if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(u1Details)) {
      combinedDetails = u1Details; // Join the paths

      combinedDetails.path = slash__WEBPACK_IMPORTED_MODULE_5___default()(path__WEBPACK_IMPORTED_MODULE_2___default.a.join(u1Details.path, u2Details.path)); // Join query parameters

      combinedDetails.query = combineQueryParams(u1Details.query, u2Details.query);
    } else {
      combinedDetails = u2Details;
    }
  } // Remove the fragment


  combinedDetails.fragment = undefined; // For relative URIs, add back the '..' since it was removed above

  return (remoteUriTypes.indexOf(combinedDetails.reference) === -1 && combinedDetails.path.indexOf('../') === 0 ? '../' : '') + uri_js__WEBPACK_IMPORTED_MODULE_6___default.a.serialize(combinedDetails);
}

function findAncestors(obj, path) {
  var ancestors = [];
  var node;

  if (path.length > 0) {
    node = obj;
    path.slice(0, path.length - 1).forEach(function (seg) {
      if (seg in node) {
        node = node[seg];
        ancestors.push(node);
      }
    });
  }

  return ancestors;
}

function isRemote(refDetails) {
  return remoteTypes.indexOf(getRefType(refDetails)) > -1;
}

function isValid(refDetails) {
  return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(refDetails.error) && refDetails.type !== 'invalid';
}

function findValue(obj, path) {
  var value = obj; // Using this manual approach instead of _.get since we have to decodeURI the segments

  path.forEach(function (seg) {
    if (seg in value) {
      value = value[seg];
    } else {
      throw Error('JSON Pointer points to missing location: ' + _pathToPtr(path));
    }
  });
  return value;
}

function getExtraRefKeys(ref) {
  return Object.keys(ref).filter(function (key) {
    return key !== '$ref';
  });
}

function getRefType(refDetails) {
  var type; // Convert the URI reference to one of our types

  switch (refDetails.uriDetails.reference) {
    case 'absolute':
    case 'uri':
      type = 'remote';
      break;

    case 'same-document':
      type = 'local';
      break;

    default:
      type = refDetails.uriDetails.reference;
  }

  return type;
}

function getRemoteDocument(url, options) {
  var cacheEntry = remoteCache[url];
  var allTasks = Promise.resolve();

  var loaderOptions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.cloneDeep(options.loaderOptions || {});

  if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(cacheEntry)) {
    // If there is no content processor, default to processing the raw response as JSON
    if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(loaderOptions.processContent)) {
      loaderOptions.processContent = function (res, callback) {
        callback(undefined, JSON.parse(res.text));
      };
    } // Attempt to load the resource using path-loader


    allTasks = path_loader__WEBPACK_IMPORTED_MODULE_3___default.a.load(decodeURI(url), loaderOptions); // Update the cache

    allTasks = allTasks.then(function (res) {
      remoteCache[url] = {
        value: res
      };
      return res;
    }).catch(function (err) {
      remoteCache[url] = {
        error: err
      };
      throw err;
    });
  } else {
    // Return the cached version
    allTasks = allTasks.then(function () {
      if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isError(cacheEntry.error)) {
        throw cacheEntry.error;
      } else {
        return cacheEntry.value;
      }
    });
  } // Return a cloned version to avoid updating the cache


  allTasks = allTasks.then(function (res) {
    return lodash__WEBPACK_IMPORTED_MODULE_0___default.a.cloneDeep(res);
  });
  return allTasks;
}

function isRefLike(obj, throwWithDetails) {
  var refLike = true;

  try {
    if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isPlainObject(obj)) {
      throw new Error('obj is not an Object');
    } else if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(obj.$ref)) {
      throw new Error('obj.$ref is not a String');
    }
  } catch (err) {
    if (throwWithDetails) {
      throw err;
    }

    refLike = false;
  }

  return refLike;
}

function makeAbsolute(location) {
  if (location.indexOf('://') === -1 && !path__WEBPACK_IMPORTED_MODULE_2___default.a.isAbsolute(location)) {
    return path__WEBPACK_IMPORTED_MODULE_2___default.a.resolve(process.cwd(), location);
  } else {
    return location;
  }
}

function makeRefFilter(options) {
  var refFilter;
  var validTypes;

  if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isArray(options.filter) || lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(options.filter)) {
    validTypes = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(options.filter) ? [options.filter] : options.filter;

    refFilter = function refFilter(refDetails) {
      // Check the exact type or for invalid URIs, check its original type
      return validTypes.indexOf(refDetails.type) > -1 || validTypes.indexOf(getRefType(refDetails)) > -1;
    };
  } else if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isFunction(options.filter)) {
    refFilter = options.filter;
  } else if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.filter)) {
    refFilter = function refFilter() {
      return true;
    };
  }

  return function (refDetails, path) {
    return (refDetails.type !== 'invalid' || options.includeInvalid === true) && refFilter(refDetails, path);
  };
}

function makeSubDocPath(options) {
  var subDocPath;

  if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isArray(options.subDocPath)) {
    subDocPath = options.subDocPath;
  } else if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(options.subDocPath)) {
    subDocPath = _pathFromPtr(options.subDocPath);
  } else if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.subDocPath)) {
    subDocPath = [];
  }

  return subDocPath;
}

function markMissing(refDetails, err) {
  refDetails.error = err.message;
  refDetails.missing = true;
}

function parseURI(uri) {
  // We decode first to avoid doubly encoding
  return uri_js__WEBPACK_IMPORTED_MODULE_6___default.a.parse(uri);
}

function buildRefModel(document, options, metadata) {
  var allTasks = Promise.resolve();

  var subDocPtr = _pathToPtr(options.subDocPath);

  var absLocation = makeAbsolute(options.location);
  var relativeBase = path__WEBPACK_IMPORTED_MODULE_2___default.a.dirname(options.location);
  var docDepKey = absLocation + subDocPtr;
  var refs;
  var rOptions; // Store the document in the metadata if necessary

  if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(metadata.docs[absLocation])) {
    metadata.docs[absLocation] = document;
  } // If there are no dependencies stored for the location+subDocPath, we've never seen it before and will process it


  if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(metadata.deps[docDepKey])) {
    metadata.deps[docDepKey] = {}; // Find the references based on the options

    refs = _findRefs(document, options); // Iterate over the references and process

    lodash__WEBPACK_IMPORTED_MODULE_0___default.a.forOwn(refs, function (refDetails, refPtr) {
      var refKey = makeAbsolute(options.location) + refPtr;
      var refdKey = refDetails.refdId = decodeURI(makeAbsolute(isRemote(refDetails) ? combineURIs(relativeBase, refDetails.uri) : options.location) + '#' + (refDetails.uri.indexOf('#') > -1 ? refDetails.uri.split('#')[1] : '')); // Record reference metadata

      metadata.refs[refKey] = refDetails; // Do not process invalid references

      if (!isValid(refDetails)) {
        return;
      } // Record the fully-qualified URI


      refDetails.fqURI = refdKey; // Record dependency (relative to the document's sub-document path)

      metadata.deps[docDepKey][refPtr === subDocPtr ? '#' : refPtr.replace(subDocPtr + '/', '#/')] = refdKey; // Do not process directly-circular references (to an ancestor or self)

      if (refKey.indexOf(refdKey + '/') === 0) {
        refDetails.circular = true;
        return;
      } // Prepare the options for subsequent processDocument calls


      rOptions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.cloneDeep(options);
      rOptions.subDocPath = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(refDetails.uriDetails.fragment) ? [] : _pathFromPtr(decodeURI(refDetails.uriDetails.fragment)); // Resolve the reference

      if (isRemote(refDetails)) {
        // Delete filter.options because all remote references should be fully resolved
        delete rOptions.filter; // The new location being referenced

        rOptions.location = refdKey.split('#')[0];
        allTasks = allTasks.then(function (nMetadata, nOptions) {
          return function () {
            var rAbsLocation = makeAbsolute(nOptions.location);
            var rDoc = nMetadata.docs[rAbsLocation];

            if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(rDoc)) {
              // We have no cache so we must retrieve the document
              return getRemoteDocument(rAbsLocation, nOptions).catch(function (err) {
                // Store the response in the document cache
                nMetadata.docs[rAbsLocation] = err; // Return the error to allow the subsequent `then` to handle both errors and successes

                return err;
              });
            } else {
              // We have already retrieved (or attempted to) the document and should use the cached version in the
              // metadata since it could already be processed some.
              return Promise.resolve().then(function () {
                return rDoc;
              });
            }
          };
        }(metadata, rOptions));
      } else {
        allTasks = allTasks.then(function () {
          return document;
        });
      } // Process the remote document or the referenced portion of the local document


      allTasks = allTasks.then(function (nMetadata, nOptions, nRefDetails) {
        return function (doc) {
          if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isError(doc)) {
            markMissing(nRefDetails, doc);
          } else {
            // Wrapped in a try/catch since findRefs throws
            try {
              return buildRefModel(doc, nOptions, nMetadata).catch(function (err) {
                markMissing(nRefDetails, err);
              });
            } catch (err) {
              markMissing(nRefDetails, err);
            }
          }
        };
      }(metadata, rOptions, refDetails));
    });
  }

  return allTasks;
}

function setValue(obj, refPath, value) {
  findValue(obj, refPath.slice(0, refPath.length - 1))[refPath[refPath.length - 1]] = value;
}

function walk(ancestors, node, path, fn) {
  var processChildren = true;

  function walkItem(item, segment) {
    path.push(segment);
    walk(ancestors, item, path, fn);
    path.pop();
  } // Call the iteratee


  if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isFunction(fn)) {
    processChildren = fn(ancestors, node, path);
  } // We do not process circular objects again


  if (ancestors.indexOf(node) === -1) {
    ancestors.push(node);

    if (processChildren !== false) {
      if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isArray(node)) {
        node.forEach(function (member, index) {
          walkItem(member, index.toString());
        });
      } else if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isObject(node)) {
        lodash__WEBPACK_IMPORTED_MODULE_0___default.a.forOwn(node, function (cNode, key) {
          walkItem(cNode, key);
        });
      }
    }

    ancestors.pop();
  }
}

function validateOptions(options, obj) {
  var locationParts;
  var shouldDecode;

  if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options)) {
    // Default to an empty options object
    options = {};
  } else {
    // Clone the options so we do not alter the ones passed in
    options = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.cloneDeep(options);
  }

  if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isObject(options)) {
    throw new TypeError('options must be an Object');
  } else if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.resolveCirculars) && !lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isBoolean(options.resolveCirculars)) {
    throw new TypeError('options.resolveCirculars must be a Boolean');
  } else if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.filter) && !lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isArray(options.filter) && !lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isFunction(options.filter) && !lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(options.filter)) {
    throw new TypeError('options.filter must be an Array, a Function of a String');
  } else if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.includeInvalid) && !lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isBoolean(options.includeInvalid)) {
    throw new TypeError('options.includeInvalid must be a Boolean');
  } else if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.location) && !lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(options.location)) {
    throw new TypeError('options.location must be a String');
  } else if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.refPreProcessor) && !lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isFunction(options.refPreProcessor)) {
    throw new TypeError('options.refPreProcessor must be a Function');
  } else if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.refPostProcessor) && !lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isFunction(options.refPostProcessor)) {
    throw new TypeError('options.refPostProcessor must be a Function');
  } else if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.subDocPath) && !lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isArray(options.subDocPath) && !_isPtr(options.subDocPath)) {
    // If a pointer is provided, throw an error if it's not the proper type
    throw new TypeError('options.subDocPath must be an Array of path segments or a valid JSON Pointer');
  } // Default to false for allowing circulars


  if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.resolveCirculars)) {
    options.resolveCirculars = false;
  }

  options.filter = makeRefFilter(options); // options.location is not officially supported yet but will be when Issue 88 is complete

  if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.location)) {
    options.location = makeAbsolute('./root.json');
  }

  locationParts = options.location.split('#'); // If options.location contains a fragment, turn it into an options.subDocPath

  if (locationParts.length > 1) {
    options.subDocPath = '#' + locationParts[1];
  }

  shouldDecode = decodeURI(options.location) === options.location; // Just to be safe, remove any accidental fragment as it would break things

  options.location = combineURIs(options.location, undefined); // If the location was not encoded, meke sure it's not when we get it back (Issue #138)

  if (shouldDecode) {
    options.location = decodeURI(options.location);
  } // Set the subDocPath to avoid everyone else having to compute it


  options.subDocPath = makeSubDocPath(options);

  if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(obj)) {
    try {
      findValue(obj, options.subDocPath);
    } catch (err) {
      err.message = err.message.replace('JSON Pointer', 'options.subDocPath');
      throw err;
    }
  }

  return options;
}

function _decodePath(path) {
  if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isArray(path)) {
    throw new TypeError('path must be an array');
  }

  return path.map(function (seg) {
    if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(seg)) {
      seg = JSON.stringify(seg);
    }

    return seg.replace(/~1/g, '/').replace(/~0/g, '~');
  });
}

function _encodePath(path) {
  if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isArray(path)) {
    throw new TypeError('path must be an array');
  }

  return path.map(function (seg) {
    if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(seg)) {
      seg = JSON.stringify(seg);
    }

    return seg.replace(/~/g, '~0').replace(/\//g, '~1');
  });
}

function _findRefs(obj, options) {
  var refs = {}; // Validate the provided document

  if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isArray(obj) && !lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isObject(obj)) {
    throw new TypeError('obj must be an Array or an Object');
  } // Validate options


  options = validateOptions(options, obj); // Walk the document (or sub document) and find all JSON References

  walk(findAncestors(obj, options.subDocPath), findValue(obj, options.subDocPath), lodash__WEBPACK_IMPORTED_MODULE_0___default.a.cloneDeep(options.subDocPath), function (ancestors, node, path) {
    var processChildren = true;
    var refDetails;
    var refPtr;

    if (isRefLike(node)) {
      // Pre-process the node when necessary
      if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.refPreProcessor)) {
        node = options.refPreProcessor(lodash__WEBPACK_IMPORTED_MODULE_0___default.a.cloneDeep(node), path);
      }

      refDetails = _getRefDetails(node); // Post-process the reference details

      if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.refPostProcessor)) {
        refDetails = options.refPostProcessor(refDetails, path);
      }

      if (options.filter(refDetails, path)) {
        refPtr = _pathToPtr(path);
        refs[refPtr] = refDetails;
      } // Whenever a JSON Reference has extra children, its children should not be processed.
      //   See: http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3


      if (getExtraRefKeys(node).length > 0) {
        processChildren = false;
      }
    }

    return processChildren;
  });
  return refs;
}

function _findRefsAt(location, options) {
  var allTasks = Promise.resolve();
  allTasks = allTasks.then(function () {
    // Validate the provided location
    if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(location)) {
      throw new TypeError('location must be a string');
    }

    if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options)) {
      options = {};
    }

    if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isObject(options)) {
      // Add the location to the options for processing/validation
      options.location = location;
    } // Validate options


    options = validateOptions(options);
    return getRemoteDocument(options.location, options);
  }).then(function (res) {
    var cacheEntry = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.cloneDeep(remoteCache[options.location]);

    var cOptions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.cloneDeep(options);

    var uriDetails = parseURI(options.location);

    if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(cacheEntry.refs)) {
      // Do not filter any references so the cache is complete
      delete cOptions.filter;
      delete cOptions.subDocPath;
      cOptions.includeInvalid = true;
      remoteCache[options.location].refs = _findRefs(res, cOptions);
    } // Add the filter options back


    if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options.filter)) {
      cOptions.filter = options.filter;
    }

    if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(uriDetails.fragment)) {
      cOptions.subDocPath = _pathFromPtr(decodeURI(uriDetails.fragment));
    } else if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(uriDetails.subDocPath)) {
      cOptions.subDocPath = options.subDocPath;
    } // This will use the cache so don't worry about calling it twice


    return {
      refs: _findRefs(res, cOptions),
      value: res
    };
  });
  return allTasks;
}

function _getRefDetails(obj) {
  var details = {
    def: obj
  };
  var cacheKey;
  var extraKeys;
  var uriDetails;

  try {
    if (isRefLike(obj, true)) {
      cacheKey = obj.$ref;
      uriDetails = uriDetailsCache[cacheKey];

      if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(uriDetails)) {
        uriDetails = uriDetailsCache[cacheKey] = parseURI(cacheKey);
      }

      details.uri = cacheKey;
      details.uriDetails = uriDetails;

      if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(uriDetails.error)) {
        details.type = getRefType(details); // Validate the JSON Pointer

        try {
          if (['#', '/'].indexOf(cacheKey[0]) > -1) {
            _isPtr(cacheKey, true);
          } else if (cacheKey.indexOf('#') > -1) {
            _isPtr(uriDetails.fragment, true);
          }
        } catch (err) {
          details.error = err.message;
          details.type = 'invalid';
        }
      } else {
        details.error = details.uriDetails.error;
        details.type = 'invalid';
      } // Identify warning


      extraKeys = getExtraRefKeys(obj);

      if (extraKeys.length > 0) {
        details.warning = 'Extra JSON Reference properties will be ignored: ' + extraKeys.join(', ');
      }
    } else {
      details.type = 'invalid';
    }
  } catch (err) {
    details.error = err.message;
    details.type = 'invalid';
  }

  return details;
}

function _isPtr(ptr, throwWithDetails) {
  var valid = true;
  var firstChar;

  try {
    if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(ptr)) {
      if (ptr !== '') {
        firstChar = ptr.charAt(0);

        if (['#', '/'].indexOf(firstChar) === -1) {
          throw new Error('ptr must start with a / or #/');
        } else if (firstChar === '#' && ptr !== '#' && ptr.charAt(1) !== '/') {
          throw new Error('ptr must start with a / or #/');
        } else if (ptr.match(badPtrTokenRegex)) {
          throw new Error('ptr has invalid token(s)');
        }
      }
    } else {
      throw new Error('ptr is not a String');
    }
  } catch (err) {
    if (throwWithDetails === true) {
      throw err;
    }

    valid = false;
  }

  return valid;
}

function _isRef(obj, throwWithDetails) {
  return isRefLike(obj, throwWithDetails) && _getRefDetails(obj, throwWithDetails).type !== 'invalid';
}

function _pathFromPtr(ptr) {
  try {
    _isPtr(ptr, true);
  } catch (err) {
    throw new Error('ptr must be a JSON Pointer: ' + err.message);
  }

  var segments = ptr.split('/'); // Remove the first segment

  segments.shift();
  return _decodePath(segments);
}

function _pathToPtr(path, hashPrefix) {
  if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isArray(path)) {
    throw new Error('path must be an Array');
  } // Encode each segment and return


  return (hashPrefix !== false ? '#' : '') + (path.length > 0 ? '/' : '') + _encodePath(path).join('/');
}

function _resolveRefs(obj, options) {
  var allTasks = Promise.resolve();
  allTasks = allTasks.then(function () {
    // Validate the provided document
    if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isArray(obj) && !lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isObject(obj)) {
      throw new TypeError('obj must be an Array or an Object');
    } // Validate options


    options = validateOptions(options, obj); // Clone the input so we do not alter it

    obj = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.cloneDeep(obj);
  }).then(function () {
    var metadata = {
      deps: {},
      // To avoid processing the same refernece twice, and for circular reference identification
      docs: {},
      // Cache to avoid processing the same document more than once
      refs: {} // Reference locations and their metadata

    };
    return buildRefModel(obj, options, metadata).then(function () {
      return metadata;
    });
  }).then(function (results) {
    var allRefs = {};
    var circularPaths = [];
    var circulars = [];
    var depGraph = new graphlib__WEBPACK_IMPORTED_MODULE_1___default.a.Graph();
    var fullLocation = makeAbsolute(options.location);

    var refsRoot = fullLocation + _pathToPtr(options.subDocPath);

    var relativeBase = path__WEBPACK_IMPORTED_MODULE_2___default.a.dirname(fullLocation); // Identify circulars
    // Add nodes first

    Object.keys(results.deps).forEach(function (node) {
      depGraph.setNode(node);
    }); // Add edges

    lodash__WEBPACK_IMPORTED_MODULE_0___default.a.forOwn(results.deps, function (props, node) {
      lodash__WEBPACK_IMPORTED_MODULE_0___default.a.forOwn(props, function (dep) {
        depGraph.setEdge(node, dep);
      });
    });

    circularPaths = graphlib__WEBPACK_IMPORTED_MODULE_1___default.a.alg.findCycles(depGraph); // Create a unique list of circulars

    circularPaths.forEach(function (path) {
      path.forEach(function (seg) {
        if (circulars.indexOf(seg) === -1) {
          circulars.push(seg);
        }
      });
    }); // Identify circulars

    lodash__WEBPACK_IMPORTED_MODULE_0___default.a.forOwn(results.deps, function (props, node) {
      lodash__WEBPACK_IMPORTED_MODULE_0___default.a.forOwn(props, function (dep, prop) {
        var isCircular = false;
        var refPtr = node + prop.slice(1);
        var refDetails = results.refs[node + prop.slice(1)];
        var remote = isRemote(refDetails);
        var pathIndex;

        if (circulars.indexOf(dep) > -1) {
          // Figure out if the circular is part of a circular chain or just a reference to a circular
          circularPaths.forEach(function (path) {
            // Short circuit
            if (isCircular) {
              return;
            }

            pathIndex = path.indexOf(dep);

            if (pathIndex > -1) {
              // Check each path segment to see if the reference location is beneath one of its segments
              path.forEach(function (seg) {
                // Short circuit
                if (isCircular) {
                  return;
                }

                if (refPtr.indexOf(seg + '/') === 0) {
                  // If the reference is local, mark it as circular but if it's a remote reference, only mark it
                  // circular if the matching path is the last path segment or its match is not to a document root
                  if (!remote || pathIndex === path.length - 1 || dep[dep.length - 1] !== '#') {
                    isCircular = true;
                  }
                }
              });
            }
          });
        }

        if (isCircular) {
          // Update all references and reference details
          refDetails.circular = true;
        }
      });
    }); // Resolve the references in reverse order since the current order is top-down


    lodash__WEBPACK_IMPORTED_MODULE_0___default.a.forOwn(Object.keys(results.deps).reverse(), function (parentPtr) {
      var deps = results.deps[parentPtr];
      var pPtrParts = parentPtr.split('#');
      var pDocument = results.docs[pPtrParts[0]];

      var pPtrPath = _pathFromPtr(pPtrParts[1]);

      lodash__WEBPACK_IMPORTED_MODULE_0___default.a.forOwn(deps, function (dep, prop) {
        var depParts = dep.split('#');
        var dDocument = results.docs[depParts[0]];
        var dPtrPath = pPtrPath.concat(_pathFromPtr(prop));

        var refDetails = results.refs[pPtrParts[0] + _pathToPtr(dPtrPath)]; // Resolve reference if valid


        if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(refDetails.error) && lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(refDetails.missing)) {
          if (!options.resolveCirculars && refDetails.circular) {
            refDetails.value = refDetails.def;
          } else {
            try {
              refDetails.value = findValue(dDocument, _pathFromPtr(depParts[1]));
            } catch (err) {
              markMissing(refDetails, err);
              return;
            } // If the reference is at the root of the document, replace the document in the cache.  Otherwise, replace
            // the value in the appropriate location in the document cache.


            if (pPtrParts[1] === '' && prop === '#') {
              results.docs[pPtrParts[0]] = refDetails.value;
            } else {
              setValue(pDocument, dPtrPath, refDetails.value);
            }
          }
        }
      });
    });

    function walkRefs(root, refPtr, refPath) {
      var refPtrParts = refPtr.split('#');
      var refDetails = results.refs[refPtr];
      var refDeps; // Record the reference (relative to the root document unless the reference is in the root document)

      allRefs[refPtrParts[0] === options.location ? '#' + refPtrParts[1] : _pathToPtr(options.subDocPath.concat(refPath))] = refDetails; // Do not walk invalid references

      if (refDetails.circular || !isValid(refDetails)) {
        // Sanitize errors
        if (!refDetails.circular && refDetails.error) {
          // The way we use findRefs now results in an error that doesn't match the expectation
          refDetails.error = refDetails.error.replace('options.subDocPath', 'JSON Pointer'); // Update the error to use the appropriate JSON Pointer

          if (refDetails.error.indexOf('#') > -1) {
            refDetails.error = refDetails.error.replace(refDetails.uri.substr(refDetails.uri.indexOf('#')), refDetails.uri);
          } // Report errors opening files as JSON Pointer errors


          if (refDetails.error.indexOf('ENOENT:') === 0 || refDetails.error.indexOf('Not Found') === 0) {
            refDetails.error = 'JSON Pointer points to missing location: ' + refDetails.uri;
          }
        }

        return;
      }

      refDeps = results.deps[refDetails.refdId];

      if (refDetails.refdId.indexOf(root) !== 0) {
        Object.keys(refDeps).forEach(function (prop) {
          walkRefs(refDetails.refdId, refDetails.refdId + prop.substr(1), refPath.concat(_pathFromPtr(prop)));
        });
      }
    } // For performance reasons, we only process a document (or sub document) and each reference once ever.  This means
    // that if we want to provide the full picture as to what paths in the resolved document were created as a result
    // of a reference, we have to take our fully-qualified reference locations and expand them to be all local based
    // on the original document.


    Object.keys(results.refs).forEach(function (refPtr) {
      var refDetails = results.refs[refPtr];
      var fqURISegments;
      var uriSegments; // Make all fully-qualified reference URIs relative to the document root (if necessary).  This step is done here
      // for performance reasons instead of below when the official sanitization process runs.

      if (refDetails.type !== 'invalid') {
        // Remove the trailing hash from document root references if they weren't in the original URI
        if (refDetails.fqURI[refDetails.fqURI.length - 1] === '#' && refDetails.uri[refDetails.uri.length - 1] !== '#') {
          refDetails.fqURI = refDetails.fqURI.substr(0, refDetails.fqURI.length - 1);
        }

        fqURISegments = refDetails.fqURI.split('/');
        uriSegments = refDetails.uri.split('/'); // The fully-qualified URI is unencoded so to keep the original formatting of the URI (encoded vs. unencoded),
        // we need to replace each URI segment in reverse order.

        lodash__WEBPACK_IMPORTED_MODULE_0___default.a.times(uriSegments.length - 1, function (time) {
          var nSeg = uriSegments[uriSegments.length - time - 1];
          var fqSegIndex = fqURISegments.length - time - 1;
          var fqSeg = fqURISegments[fqSegIndex];

          if (nSeg === '.' || nSeg === '..') {
            nSeg = fqSeg;
          }

          fqURISegments[fqSegIndex] = nSeg;
        });

        refDetails.fqURI = fqURISegments.join('/'); // Make the fully-qualified URIs relative to the document root

        if (refDetails.fqURI.indexOf(fullLocation) === 0) {
          refDetails.fqURI = refDetails.fqURI.replace(fullLocation, '');
        } else if (refDetails.fqURI.indexOf(relativeBase) === 0) {
          refDetails.fqURI = refDetails.fqURI.replace(relativeBase, '');
        }

        if (refDetails.fqURI[0] === '/') {
          refDetails.fqURI = '.' + refDetails.fqURI;
        }
      } // We only want to process references found at or beneath the provided document and sub-document path


      if (refPtr.indexOf(refsRoot) !== 0) {
        return;
      }

      walkRefs(refsRoot, refPtr, _pathFromPtr(refPtr.substr(refsRoot.length)));
    }); // Sanitize the reference details

    lodash__WEBPACK_IMPORTED_MODULE_0___default.a.forOwn(results.refs, function (refDetails) {
      // Delete the reference id used for dependency tracking and circular identification
      delete refDetails.refdId; // To avoid the error message being URI encoded/decoded by mistake, replace the current JSON Pointer with the
      // value in the JSON Reference definition.

      if (refDetails.missing) {
        refDetails.error = refDetails.error.split(': ')[0] + ': ' + refDetails.def.$ref;
      }
    });

    return {
      refs: allRefs,
      resolved: results.docs[fullLocation]
    };
  });
  return allTasks;
}

function _resolveRefsAt(location, options) {
  var allTasks = Promise.resolve();
  allTasks = allTasks.then(function () {
    // Validate the provided location
    if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isString(location)) {
      throw new TypeError('location must be a string');
    }

    if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(options)) {
      options = {};
    }

    if (lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isObject(options)) {
      // Add the location to the options for processing/validation
      options.location = location;
    } // Validate options


    options = validateOptions(options);
    return getRemoteDocument(options.location, options);
  }).then(function (res) {
    var cOptions = lodash__WEBPACK_IMPORTED_MODULE_0___default.a.cloneDeep(options);

    var uriDetails = parseURI(options.location); // Set the sub document path if necessary

    if (!lodash__WEBPACK_IMPORTED_MODULE_0___default.a.isUndefined(uriDetails.fragment)) {
      cOptions.subDocPath = _pathFromPtr(decodeURI(uriDetails.fragment));
    }

    return _resolveRefs(res, cOptions).then(function (res2) {
      return {
        refs: res2.refs,
        resolved: res2.resolved,
        value: res
      };
    });
  });
  return allTasks;
}
/**
 * Various utilities for JSON References *(http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03)* and
 * JSON Pointers *(https://tools.ietf.org/html/rfc6901)*.
 *
 * @module json-refs
 */

/**
 * A number of functions exported below are used within the exported functions.  Typically, I would use a function
 * declaration _(with documenation)_ above and then just export a reference to the function but due to a bug in JSDoc
 * (https://github.com/jsdoc3/jsdoc/issues/679), this breaks the generated API documentation and TypeScript
 * declarations.  So that's why each `module.exports` below basically just wraps a call to the function declaration.
 */

/**
* Clears the internal cache of remote documents, reference details, etc.
*/


function clearCache() {
  remoteCache = {};
}
/**
 * Takes an array of path segments and decodes the JSON Pointer tokens in them.
 *
 * @param {string[]} path - The array of path segments
 *
 * @returns {string} the array of path segments with their JSON Pointer tokens decoded
 *
 * @throws {Error} if the path is not an `Array`
 *
 * @see {@link https://tools.ietf.org/html/rfc6901#section-3}
 */

function decodePath(path) {
  return _decodePath(path);
}
/**
 * Takes an array of path segments and encodes the special JSON Pointer characters in them.
 *
 * @param {string[]} path - The array of path segments
 *
 * @returns {string} the array of path segments with their JSON Pointer tokens encoded
 *
 * @throws {Error} if the path is not an `Array`
 *
 * @see {@link https://tools.ietf.org/html/rfc6901#section-3}
 */

function encodePath(path) {
  return _encodePath(path);
}
/**
 * Finds JSON References defined within the provided array/object.
 *
 * @param {array|object} obj - The structure to find JSON References within
 * @param {module:json-refs~JsonRefsOptions} [options] - The JsonRefs options
 *
 * @returns {object} an object whose keys are JSON Pointers *(fragment version)* to where the JSON Reference is defined
 * and whose values are {@link UnresolvedRefDetails}.
 *
 * @throws {Error} when the input arguments fail validation or if `options.subDocPath` points to an invalid location
 *
 * @example
 * // Finding all valid references
 * var allRefs = JsonRefs.findRefs(obj);
 * // Finding all remote references
 * var remoteRefs = JsonRefs.findRefs(obj, {filter: ['relative', 'remote']});
 * // Finding all invalid references
 * var invalidRefs = JsonRefs.findRefs(obj, {filter: 'invalid', includeInvalid: true});
 */

function findRefs(obj, options) {
  return _findRefs(obj, options);
}
/**
 * Finds JSON References defined within the document at the provided location.
 *
 * This API is identical to {@link findRefs} except this API will retrieve a remote document and then
 * return the result of {@link findRefs} on the retrieved document.
 *
 * @param {string} location - The location to retrieve *(Can be relative or absolute, just make sure you look at the
 * {@link module:json-refs~JsonRefsOptions|options documentation} to see how relative references are handled.)*
 * @param {module:json-refs~JsonRefsOptions} [options] - The JsonRefs options
 *
 * @returns {Promise<module:json-refs~RetrievedRefsResults>} a promise that resolves a
 * {@link module:json-refs~RetrievedRefsResults} and rejects with an `Error` when the input arguments fail validation,
 * when `options.subDocPath` points to an invalid location or when the location argument points to an unloadable
 * resource
 *
 * @example
 * // Example that only resolves references within a sub document
 * JsonRefs.findRefsAt('http://petstore.swagger.io/v2/swagger.json', {
 *     subDocPath: '#/definitions'
 *   })
 *   .then(function (res) {
 *      // Do something with the response
 *      //
 *      // res.refs: JSON Reference locations and details
 *      // res.value: The retrieved document
 *   }, function (err) {
 *     console.log(err.stack);
 *   });
 */

function findRefsAt(location, options) {
  return _findRefsAt(location, options);
}
/**
 * Returns detailed information about the JSON Reference.
 *
 * @param {object} obj - The JSON Reference definition
 *
 * @returns {module:json-refs~UnresolvedRefDetails} the detailed information
 */

function getRefDetails(obj) {
  return _getRefDetails(obj);
}
/**
 * Returns whether the argument represents a JSON Pointer.
 *
 * A string is a JSON Pointer if the following are all true:
 *
 *   * The string is of type `String`
 *   * The string must be empty, `#` or start with a `/` or `#/`
 *
 * @param {string} ptr - The string to check
 * @param {boolean} [throwWithDetails=false] - Whether or not to throw an `Error` with the details as to why the value
 * provided is invalid
 *
 * @returns {boolean} the result of the check
 *
 * @throws {error} when the provided value is invalid and the `throwWithDetails` argument is `true`
 *
 * @see {@link https://tools.ietf.org/html/rfc6901#section-3}
 *
 * @example
 * // Separating the different ways to invoke isPtr for demonstration purposes
 * if (isPtr(str)) {
 *   // Handle a valid JSON Pointer
 * } else {
 *   // Get the reason as to why the value is not a JSON Pointer so you can fix/report it
 *   try {
 *     isPtr(str, true);
 *   } catch (err) {
 *     // The error message contains the details as to why the provided value is not a JSON Pointer
 *   }
 * }
 */

function isPtr(ptr, throwWithDetails) {
  return _isPtr(ptr, throwWithDetails);
}
/**
 * Returns whether the argument represents a JSON Reference.
 *
 * An object is a JSON Reference only if the following are all true:
 *
 *   * The object is of type `Object`
 *   * The object has a `$ref` property
 *   * The `$ref` property is a valid URI *(We do not require 100% strict URIs and will handle unescaped special
 *     characters.)*
 *
 * @param {object} obj - The object to check
 * @param {boolean} [throwWithDetails=false] - Whether or not to throw an `Error` with the details as to why the value
 * provided is invalid
 *
 * @returns {boolean} the result of the check
 *
 * @throws {error} when the provided value is invalid and the `throwWithDetails` argument is `true`
 *
 * @see {@link http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3}
 *
 * @example
 * // Separating the different ways to invoke isRef for demonstration purposes
 * if (isRef(obj)) {
 *   // Handle a valid JSON Reference
 * } else {
 *   // Get the reason as to why the value is not a JSON Reference so you can fix/report it
 *   try {
 *     isRef(str, true);
 *   } catch (err) {
 *     // The error message contains the details as to why the provided value is not a JSON Reference
 *   }
 * }
 */

function isRef(obj, throwWithDetails) {
  return _isRef(obj, throwWithDetails);
}
/**
 * Returns an array of path segments for the provided JSON Pointer.
 *
 * @param {string} ptr - The JSON Pointer
 *
 * @returns {string[]} the path segments
 *
 * @throws {Error} if the provided `ptr` argument is not a JSON Pointer
 */

function pathFromPtr(ptr) {
  return _pathFromPtr(ptr);
}
/**
 * Returns a JSON Pointer for the provided array of path segments.
 *
 * **Note:** If a path segment in `path` is not a `String`, it will be converted to one using `JSON.stringify`.
 *
 * @param {string[]} path - The array of path segments
 * @param {boolean} [hashPrefix=true] - Whether or not create a hash-prefixed JSON Pointer
 *
 * @returns {string} the corresponding JSON Pointer
 *
 * @throws {Error} if the `path` argument is not an array
 */

function pathToPtr(path, hashPrefix) {
  return _pathToPtr(path, hashPrefix);
}
/**
 * Finds JSON References defined within the provided array/object and resolves them.
 *
 * @param {array|object} obj - The structure to find JSON References within
 * @param {module:json-refs~JsonRefsOptions} [options] - The JsonRefs options
 *
 * @returns {Promise<module:json-refs~ResolvedRefsResults>} a promise that resolves a
 * {@link module:json-refs~ResolvedRefsResults} and rejects with an `Error` when the input arguments fail validation,
 * when `options.subDocPath` points to an invalid location or when the location argument points to an unloadable
 * resource
 *
 * @example
 * // Example that only resolves relative and remote references
 * JsonRefs.resolveRefs(swaggerObj, {
 *     filter: ['relative', 'remote']
 *   })
 *   .then(function (res) {
 *      // Do something with the response
 *      //
 *      // res.refs: JSON Reference locations and details
 *      // res.resolved: The document with the appropriate JSON References resolved
 *   }, function (err) {
 *     console.log(err.stack);
 *   });
 */

function resolveRefs(obj, options) {
  return _resolveRefs(obj, options);
}
/**
 * Resolves JSON References defined within the document at the provided location.
 *
 * This API is identical to {@link module:json-refs.resolveRefs} except this API will retrieve a remote document and
 * then return the result of {@link module:json-refs.resolveRefs} on the retrieved document.
 *
 * @param {string} location - The location to retrieve *(Can be relative or absolute, just make sure you look at the
 * {@link module:json-refs~JsonRefsOptions|options documentation} to see how relative references are handled.)*
 * @param {module:json-refs~JsonRefsOptions} [options] - The JsonRefs options
 *
 * @returns {Promise<module:json-refs~RetrievedResolvedRefsResults>} a promise that resolves a
 * {@link module:json-refs~RetrievedResolvedRefsResults} and rejects with an `Error` when the input arguments fail
 * validation, when `options.subDocPath` points to an invalid location or when the location argument points to an
 * unloadable resource
 *
 * @example
 * // Example that loads a JSON document (No options.loaderOptions.processContent required) and resolves all references
 * JsonRefs.resolveRefsAt('./swagger.json')
 *   .then(function (res) {
 *      // Do something with the response
 *      //
 *      // res.refs: JSON Reference locations and details
 *      // res.resolved: The document with the appropriate JSON References resolved
 *      // res.value: The retrieved document
 *   }, function (err) {
 *     console.log(err.stack);
 *   });
 */

function resolveRefsAt(location, options) {
  return _resolveRefsAt(location, options);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Expose `Emitter`.
 */
if (true) {
  module.exports = Emitter;
}
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */


function Emitter(obj) {
  if (obj) return mixin(obj);
}

;
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }

  return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {}; // all

  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  } // specific event


  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this; // remove all handlers

  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  } // remove specific handler


  var cb;

  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];

    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */


Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1),
      callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);

    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */


Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */


Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

/***/ }),

/***/ "./node_modules/graphlib/index.js":
/*!****************************************!*\
  !*** ./node_modules/graphlib/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var lib = __webpack_require__(/*! ./lib */ "./node_modules/graphlib/lib/index.js");

module.exports = {
  Graph: lib.Graph,
  json: __webpack_require__(/*! ./lib/json */ "./node_modules/graphlib/lib/json.js"),
  alg: __webpack_require__(/*! ./lib/alg */ "./node_modules/graphlib/lib/alg/index.js"),
  version: lib.version
};

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/components.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/components.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = components;

function components(g) {
  var visited = {},
      cmpts = [],
      cmpt;

  function dfs(v) {
    if (_.has(visited, v)) return;
    visited[v] = true;
    cmpt.push(v);

    _.each(g.successors(v), dfs);

    _.each(g.predecessors(v), dfs);
  }

  _.each(g.nodes(), function (v) {
    cmpt = [];
    dfs(v);

    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });

  return cmpts;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dfs.js":
/*!**********************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dfs.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = dfs;
/*
 * A helper that preforms a pre- or post-order traversal on the input graph
 * and returns the nodes in the order they were visited. If the graph is
 * undirected then this algorithm will navigate using neighbors. If the graph
 * is directed then this algorithm will navigate using successors.
 *
 * Order must be one of "pre" or "post".
 */

function dfs(g, vs, order) {
  if (!_.isArray(vs)) {
    vs = [vs];
  }

  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);
  var acc = [],
      visited = {};

  _.each(vs, function (v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }

    doDfs(g, v, order === "post", visited, navigation, acc);
  });

  return acc;
}

function doDfs(g, v, postorder, visited, navigation, acc) {
  if (!_.has(visited, v)) {
    visited[v] = true;

    if (!postorder) {
      acc.push(v);
    }

    _.each(navigation(v), function (w) {
      doDfs(g, w, postorder, visited, navigation, acc);
    });

    if (postorder) {
      acc.push(v);
    }
  }
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dijkstra-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dijkstra-all.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dijkstra = __webpack_require__(/*! ./dijkstra */ "./node_modules/graphlib/lib/alg/dijkstra.js"),
    _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = dijkstraAll;

function dijkstraAll(g, weightFunc, edgeFunc) {
  return _.transform(g.nodes(), function (acc, v) {
    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
  }, {});
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dijkstra.js":
/*!***************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dijkstra.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js"),
    PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/graphlib/lib/data/priority-queue.js");

module.exports = dijkstra;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function dijkstra(g, source, weightFn, edgeFn) {
  return runDijkstra(g, String(source), weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function (v) {
    return g.outEdges(v);
  });
}

function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {},
      pq = new PriorityQueue(),
      v,
      vEntry;

  var updateNeighbors = function updateNeighbors(edge) {
    var w = edge.v !== v ? edge.v : edge.w,
        wEntry = results[w],
        weight = weightFn(edge),
        distance = vEntry.distance + weight;

    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. " + "Bad edge: " + edge + " Weight: " + weight);
    }

    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v;
      pq.decrease(w, distance);
    }
  };

  g.nodes().forEach(function (v) {
    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
    results[v] = {
      distance: distance
    };
    pq.add(v, distance);
  });

  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];

    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }

    edgeFn(v).forEach(updateNeighbors);
  }

  return results;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/find-cycles.js":
/*!******************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/find-cycles.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js"),
    tarjan = __webpack_require__(/*! ./tarjan */ "./node_modules/graphlib/lib/alg/tarjan.js");

module.exports = findCycles;

function findCycles(g) {
  return _.filter(tarjan(g), function (cmpt) {
    return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
  });
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/floyd-warshall.js":
/*!*********************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/floyd-warshall.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = floydWarshall;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(g, weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function (v) {
    return g.outEdges(v);
  });
}

function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {},
      nodes = g.nodes();
  nodes.forEach(function (v) {
    results[v] = {};
    results[v][v] = {
      distance: 0
    };
    nodes.forEach(function (w) {
      if (v !== w) {
        results[v][w] = {
          distance: Number.POSITIVE_INFINITY
        };
      }
    });
    edgeFn(v).forEach(function (edge) {
      var w = edge.v === v ? edge.w : edge.v,
          d = weightFn(edge);
      results[v][w] = {
        distance: d,
        predecessor: v
      };
    });
  });
  nodes.forEach(function (k) {
    var rowK = results[k];
    nodes.forEach(function (i) {
      var rowI = results[i];
      nodes.forEach(function (j) {
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;

        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });
  return results;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/index.js":
/*!************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  components: __webpack_require__(/*! ./components */ "./node_modules/graphlib/lib/alg/components.js"),
  dijkstra: __webpack_require__(/*! ./dijkstra */ "./node_modules/graphlib/lib/alg/dijkstra.js"),
  dijkstraAll: __webpack_require__(/*! ./dijkstra-all */ "./node_modules/graphlib/lib/alg/dijkstra-all.js"),
  findCycles: __webpack_require__(/*! ./find-cycles */ "./node_modules/graphlib/lib/alg/find-cycles.js"),
  floydWarshall: __webpack_require__(/*! ./floyd-warshall */ "./node_modules/graphlib/lib/alg/floyd-warshall.js"),
  isAcyclic: __webpack_require__(/*! ./is-acyclic */ "./node_modules/graphlib/lib/alg/is-acyclic.js"),
  postorder: __webpack_require__(/*! ./postorder */ "./node_modules/graphlib/lib/alg/postorder.js"),
  preorder: __webpack_require__(/*! ./preorder */ "./node_modules/graphlib/lib/alg/preorder.js"),
  prim: __webpack_require__(/*! ./prim */ "./node_modules/graphlib/lib/alg/prim.js"),
  tarjan: __webpack_require__(/*! ./tarjan */ "./node_modules/graphlib/lib/alg/tarjan.js"),
  topsort: __webpack_require__(/*! ./topsort */ "./node_modules/graphlib/lib/alg/topsort.js")
};

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/is-acyclic.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/is-acyclic.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var topsort = __webpack_require__(/*! ./topsort */ "./node_modules/graphlib/lib/alg/topsort.js");

module.exports = isAcyclic;

function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e) {
    if (e instanceof topsort.CycleException) {
      return false;
    }

    throw e;
  }

  return true;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/postorder.js":
/*!****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/postorder.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/graphlib/lib/alg/dfs.js");

module.exports = postorder;

function postorder(g, vs) {
  return dfs(g, vs, "post");
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/preorder.js":
/*!***************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/preorder.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/graphlib/lib/alg/dfs.js");

module.exports = preorder;

function preorder(g, vs) {
  return dfs(g, vs, "pre");
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/prim.js":
/*!***********************************************!*\
  !*** ./node_modules/graphlib/lib/alg/prim.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js"),
    Graph = __webpack_require__(/*! ../graph */ "./node_modules/graphlib/lib/graph.js"),
    PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/graphlib/lib/data/priority-queue.js");

module.exports = prim;

function prim(g, weightFunc) {
  var result = new Graph(),
      parents = {},
      pq = new PriorityQueue(),
      v;

  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v,
        pri = pq.priority(w);

    if (pri !== undefined) {
      var edgeWeight = weightFunc(edge);

      if (edgeWeight < pri) {
        parents[w] = v;
        pq.decrease(w, edgeWeight);
      }
    }
  }

  if (g.nodeCount() === 0) {
    return result;
  }

  _.each(g.nodes(), function (v) {
    pq.add(v, Number.POSITIVE_INFINITY);
    result.setNode(v);
  }); // Start from an arbitrary node


  pq.decrease(g.nodes()[0], 0);
  var init = false;

  while (pq.size() > 0) {
    v = pq.removeMin();

    if (_.has(parents, v)) {
      result.setEdge(v, parents[v]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }

    g.nodeEdges(v).forEach(updateNeighbors);
  }

  return result;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/tarjan.js":
/*!*************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/tarjan.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = tarjan;

function tarjan(g) {
  var index = 0,
      stack = [],
      visited = {},
      // node id -> { onStack, lowlink, index }
  results = [];

  function dfs(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index,
      index: index++
    };
    stack.push(v);
    g.successors(v).forEach(function (w) {
      if (!_.has(visited, w)) {
        dfs(w);
        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
      } else if (visited[w].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
      }
    });

    if (entry.lowlink === entry.index) {
      var cmpt = [],
          w;

      do {
        w = stack.pop();
        visited[w].onStack = false;
        cmpt.push(w);
      } while (v !== w);

      results.push(cmpt);
    }
  }

  g.nodes().forEach(function (v) {
    if (!_.has(visited, v)) {
      dfs(v);
    }
  });
  return results;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/alg/topsort.js":
/*!**************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/topsort.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = topsort;
topsort.CycleException = CycleException;

function topsort(g) {
  var visited = {},
      stack = {},
      results = [];

  function visit(node) {
    if (_.has(stack, node)) {
      throw new CycleException();
    }

    if (!_.has(visited, node)) {
      stack[node] = true;
      visited[node] = true;

      _.each(g.predecessors(node), visit);

      delete stack[node];
      results.push(node);
    }
  }

  _.each(g.sinks(), visit);

  if (_.size(visited) !== g.nodeCount()) {
    throw new CycleException();
  }

  return results;
}

function CycleException() {}

CycleException.prototype = new Error(); // must be an instance of Error to pass testing

/***/ }),

/***/ "./node_modules/graphlib/lib/data/priority-queue.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphlib/lib/data/priority-queue.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = PriorityQueue;
/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */

function PriorityQueue() {
  this._arr = [];
  this._keyIndices = {};
}
/**
 * Returns the number of elements in the queue. Takes `O(1)` time.
 */


PriorityQueue.prototype.size = function () {
  return this._arr.length;
};
/**
 * Returns the keys that are in the queue. Takes `O(n)` time.
 */


PriorityQueue.prototype.keys = function () {
  return this._arr.map(function (x) {
    return x.key;
  });
};
/**
 * Returns `true` if **key** is in the queue and `false` if not.
 */


PriorityQueue.prototype.has = function (key) {
  return _.has(this._keyIndices, key);
};
/**
 * Returns the priority for **key**. If **key** is not present in the queue
 * then this function returns `undefined`. Takes `O(1)` time.
 *
 * @param {Object} key
 */


PriorityQueue.prototype.priority = function (key) {
  var index = this._keyIndices[key];

  if (index !== undefined) {
    return this._arr[index].priority;
  }
};
/**
 * Returns the key for the minimum element in this queue. If the queue is
 * empty this function throws an Error. Takes `O(1)` time.
 */


PriorityQueue.prototype.min = function () {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }

  return this._arr[0].key;
};
/**
 * Inserts a new key into the priority queue. If the key already exists in
 * the queue this function returns `false`; otherwise it will return `true`.
 * Takes `O(n)` time.
 *
 * @param {Object} key the key to add
 * @param {Number} priority the initial priority for the key
 */


PriorityQueue.prototype.add = function (key, priority) {
  var keyIndices = this._keyIndices;
  key = String(key);

  if (!_.has(keyIndices, key)) {
    var arr = this._arr;
    var index = arr.length;
    keyIndices[key] = index;
    arr.push({
      key: key,
      priority: priority
    });

    this._decrease(index);

    return true;
  }

  return false;
};
/**
 * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
 */


PriorityQueue.prototype.removeMin = function () {
  this._swap(0, this._arr.length - 1);

  var min = this._arr.pop();

  delete this._keyIndices[min.key];

  this._heapify(0);

  return min.key;
};
/**
 * Decreases the priority for **key** to **priority**. If the new priority is
 * greater than the previous priority, this function will throw an Error.
 *
 * @param {Object} key the key for which to raise priority
 * @param {Number} priority the new priority for the key
 */


PriorityQueue.prototype.decrease = function (key, priority) {
  var index = this._keyIndices[key];

  if (priority > this._arr[index].priority) {
    throw new Error("New priority is greater than current priority. " + "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
  }

  this._arr[index].priority = priority;

  this._decrease(index);
};

PriorityQueue.prototype._heapify = function (i) {
  var arr = this._arr;
  var l = 2 * i,
      r = l + 1,
      largest = i;

  if (l < arr.length) {
    largest = arr[l].priority < arr[largest].priority ? l : largest;

    if (r < arr.length) {
      largest = arr[r].priority < arr[largest].priority ? r : largest;
    }

    if (largest !== i) {
      this._swap(i, largest);

      this._heapify(largest);
    }
  }
};

PriorityQueue.prototype._decrease = function (index) {
  var arr = this._arr;
  var priority = arr[index].priority;
  var parent;

  while (index !== 0) {
    parent = index >> 1;

    if (arr[parent].priority < priority) {
      break;
    }

    this._swap(index, parent);

    index = parent;
  }
};

PriorityQueue.prototype._swap = function (i, j) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i];
  var origArrJ = arr[j];
  arr[i] = origArrJ;
  arr[j] = origArrI;
  keyIndices[origArrJ.key] = i;
  keyIndices[origArrI.key] = j;
};

/***/ }),

/***/ "./node_modules/graphlib/lib/graph.js":
/*!********************************************!*\
  !*** ./node_modules/graphlib/lib/graph.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = Graph;
var DEFAULT_EDGE_NAME = "\x00",
    GRAPH_NODE = "\x00",
    EDGE_KEY_DELIM = "\x01"; // Implementation notes:
//
//  * Node id query functions should return string ids for the nodes
//  * Edge id query functions should return an "edgeObj", edge object, that is
//    composed of enough information to uniquely identify an edge: {v, w, name}.
//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
//    reference edges. This is because we need a performant way to look these
//    edges up and, object properties, which have string keys, are the closest
//    we're going to get to a performant hashtable in JavaScript.

function Graph(opts) {
  this._isDirected = _.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = _.has(opts, "compound") ? opts.compound : false; // Label for the graph itself

  this._label = undefined; // Defaults to be set when creating a new node

  this._defaultNodeLabelFn = _.constant(undefined); // Defaults to be set when creating a new edge

  this._defaultEdgeLabelFn = _.constant(undefined); // v -> label

  this._nodes = {};

  if (this._isCompound) {
    // v -> parent
    this._parent = {}; // v -> children

    this._children = {};
    this._children[GRAPH_NODE] = {};
  } // v -> edgeObj


  this._in = {}; // u -> v -> Number

  this._preds = {}; // v -> edgeObj

  this._out = {}; // v -> w -> Number

  this._sucs = {}; // e -> edgeObj

  this._edgeObjs = {}; // e -> label

  this._edgeLabels = {};
}
/* Number of nodes in the graph. Should only be changed by the implementation. */


Graph.prototype._nodeCount = 0;
/* Number of edges in the graph. Should only be changed by the implementation. */

Graph.prototype._edgeCount = 0;
/* === Graph functions ========= */

Graph.prototype.isDirected = function () {
  return this._isDirected;
};

Graph.prototype.isMultigraph = function () {
  return this._isMultigraph;
};

Graph.prototype.isCompound = function () {
  return this._isCompound;
};

Graph.prototype.setGraph = function (label) {
  this._label = label;
  return this;
};

Graph.prototype.graph = function () {
  return this._label;
};
/* === Node functions ========== */


Graph.prototype.setDefaultNodeLabel = function (newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }

  this._defaultNodeLabelFn = newDefault;
  return this;
};

Graph.prototype.nodeCount = function () {
  return this._nodeCount;
};

Graph.prototype.nodes = function () {
  return _.keys(this._nodes);
};

Graph.prototype.sources = function () {
  var self = this;
  return _.filter(this.nodes(), function (v) {
    return _.isEmpty(self._in[v]);
  });
};

Graph.prototype.sinks = function () {
  var self = this;
  return _.filter(this.nodes(), function (v) {
    return _.isEmpty(self._out[v]);
  });
};

Graph.prototype.setNodes = function (vs, value) {
  var args = arguments;
  var self = this;

  _.each(vs, function (v) {
    if (args.length > 1) {
      self.setNode(v, value);
    } else {
      self.setNode(v);
    }
  });

  return this;
};

Graph.prototype.setNode = function (v, value) {
  if (_.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }

    return this;
  }

  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);

  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE;
    this._children[v] = {};
    this._children[GRAPH_NODE][v] = true;
  }

  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};

Graph.prototype.node = function (v) {
  return this._nodes[v];
};

Graph.prototype.hasNode = function (v) {
  return _.has(this._nodes, v);
};

Graph.prototype.removeNode = function (v) {
  var self = this;

  if (_.has(this._nodes, v)) {
    var removeEdge = function removeEdge(e) {
      self.removeEdge(self._edgeObjs[e]);
    };

    delete this._nodes[v];

    if (this._isCompound) {
      this._removeFromParentsChildList(v);

      delete this._parent[v];

      _.each(this.children(v), function (child) {
        self.setParent(child);
      });

      delete this._children[v];
    }

    _.each(_.keys(this._in[v]), removeEdge);

    delete this._in[v];
    delete this._preds[v];

    _.each(_.keys(this._out[v]), removeEdge);

    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }

  return this;
};

Graph.prototype.setParent = function (v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }

  if (_.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    // Coerce parent to string
    parent += "";

    for (var ancestor = parent; !_.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
      }
    }

    this.setNode(parent);
  }

  this.setNode(v);

  this._removeFromParentsChildList(v);

  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};

Graph.prototype._removeFromParentsChildList = function (v) {
  delete this._children[this._parent[v]][v];
};

Graph.prototype.parent = function (v) {
  if (this._isCompound) {
    var parent = this._parent[v];

    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};

Graph.prototype.children = function (v) {
  if (_.isUndefined(v)) {
    v = GRAPH_NODE;
  }

  if (this._isCompound) {
    var children = this._children[v];

    if (children) {
      return _.keys(children);
    }
  } else if (v === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};

Graph.prototype.predecessors = function (v) {
  var predsV = this._preds[v];

  if (predsV) {
    return _.keys(predsV);
  }
};

Graph.prototype.successors = function (v) {
  var sucsV = this._sucs[v];

  if (sucsV) {
    return _.keys(sucsV);
  }
};

Graph.prototype.neighbors = function (v) {
  var preds = this.predecessors(v);

  if (preds) {
    return _.union(preds, this.successors(v));
  }
};

Graph.prototype.isLeaf = function (v) {
  var neighbors;

  if (this.isDirected()) {
    neighbors = this.successors(v);
  } else {
    neighbors = this.neighbors(v);
  }

  return neighbors.length === 0;
};

Graph.prototype.filterNodes = function (filter) {
  var copy = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });
  copy.setGraph(this.graph());
  var self = this;

  _.each(this._nodes, function (value, v) {
    if (filter(v)) {
      copy.setNode(v, value);
    }
  });

  _.each(this._edgeObjs, function (e) {
    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
      copy.setEdge(e, self.edge(e));
    }
  });

  var parents = {};

  function findParent(v) {
    var parent = self.parent(v);

    if (parent === undefined || copy.hasNode(parent)) {
      parents[v] = parent;
      return parent;
    } else if (parent in parents) {
      return parents[parent];
    } else {
      return findParent(parent);
    }
  }

  if (this._isCompound) {
    _.each(copy.nodes(), function (v) {
      copy.setParent(v, findParent(v));
    });
  }

  return copy;
};
/* === Edge functions ========== */


Graph.prototype.setDefaultEdgeLabel = function (newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }

  this._defaultEdgeLabelFn = newDefault;
  return this;
};

Graph.prototype.edgeCount = function () {
  return this._edgeCount;
};

Graph.prototype.edges = function () {
  return _.values(this._edgeObjs);
};

Graph.prototype.setPath = function (vs, value) {
  var self = this,
      args = arguments;

  _.reduce(vs, function (v, w) {
    if (args.length > 1) {
      self.setEdge(v, w, value);
    } else {
      self.setEdge(v, w);
    }

    return w;
  });

  return this;
};
/*
 * setEdge(v, w, [value, [name]])
 * setEdge({ v, w, [name] }, [value])
 */


Graph.prototype.setEdge = function () {
  var v,
      w,
      name,
      value,
      valueSpecified = false,
      arg0 = arguments[0];

  if (_typeof(arg0) === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w = arg0.w;
    name = arg0.name;

    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w = arguments[1];
    name = arguments[3];

    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }

  v = "" + v;
  w = "" + w;

  if (!_.isUndefined(name)) {
    name = "" + name;
  }

  var e = edgeArgsToId(this._isDirected, v, w, name);

  if (_.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }

    return this;
  }

  if (!_.isUndefined(name) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  } // It didn't exist, so we need to create it.
  // First ensure the nodes exist.


  this.setNode(v);
  this.setNode(w);
  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);
  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name); // Ensure we add undirected edges in a consistent way.

  v = edgeObj.v;
  w = edgeObj.w;
  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry(this._preds[w], v);
  incrementOrInitEntry(this._sucs[v], w);
  this._in[w][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};

Graph.prototype.edge = function (v, w, name) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
  return this._edgeLabels[e];
};

Graph.prototype.hasEdge = function (v, w, name) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name);
  return _.has(this._edgeLabels, e);
};

Graph.prototype.removeEdge = function (v, w, name) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w, name),
      edge = this._edgeObjs[e];

  if (edge) {
    v = edge.v;
    w = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry(this._preds[w], v);
    decrementOrRemoveEntry(this._sucs[v], w);
    delete this._in[w][e];
    delete this._out[v][e];
    this._edgeCount--;
  }

  return this;
};

Graph.prototype.inEdges = function (v, u) {
  var inV = this._in[v];

  if (inV) {
    var edges = _.values(inV);

    if (!u) {
      return edges;
    }

    return _.filter(edges, function (edge) {
      return edge.v === u;
    });
  }
};

Graph.prototype.outEdges = function (v, w) {
  var outV = this._out[v];

  if (outV) {
    var edges = _.values(outV);

    if (!w) {
      return edges;
    }

    return _.filter(edges, function (edge) {
      return edge.w === w;
    });
  }
};

Graph.prototype.nodeEdges = function (v, w) {
  var inEdges = this.inEdges(v, w);

  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w));
  }
};

function incrementOrInitEntry(map, k) {
  if (map[k]) {
    map[k]++;
  } else {
    map[k] = 1;
  }
}

function decrementOrRemoveEntry(map, k) {
  if (! --map[k]) {
    delete map[k];
  }
}

function edgeArgsToId(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;

  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }

  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM + (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
}

function edgeArgsToObj(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;

  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }

  var edgeObj = {
    v: v,
    w: w
  };

  if (name) {
    edgeObj.name = name;
  }

  return edgeObj;
}

function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}

/***/ }),

/***/ "./node_modules/graphlib/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/graphlib/lib/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Includes only the "core" of graphlib
module.exports = {
  Graph: __webpack_require__(/*! ./graph */ "./node_modules/graphlib/lib/graph.js"),
  version: __webpack_require__(/*! ./version */ "./node_modules/graphlib/lib/version.js")
};

/***/ }),

/***/ "./node_modules/graphlib/lib/json.js":
/*!*******************************************!*\
  !*** ./node_modules/graphlib/lib/json.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/graphlib/lib/lodash.js"),
    Graph = __webpack_require__(/*! ./graph */ "./node_modules/graphlib/lib/graph.js");

module.exports = {
  write: write,
  read: read
};

function write(g) {
  var json = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };

  if (!_.isUndefined(g.graph())) {
    json.value = _.clone(g.graph());
  }

  return json;
}

function writeNodes(g) {
  return _.map(g.nodes(), function (v) {
    var nodeValue = g.node(v),
        parent = g.parent(v),
        node = {
      v: v
    };

    if (!_.isUndefined(nodeValue)) {
      node.value = nodeValue;
    }

    if (!_.isUndefined(parent)) {
      node.parent = parent;
    }

    return node;
  });
}

function writeEdges(g) {
  return _.map(g.edges(), function (e) {
    var edgeValue = g.edge(e),
        edge = {
      v: e.v,
      w: e.w
    };

    if (!_.isUndefined(e.name)) {
      edge.name = e.name;
    }

    if (!_.isUndefined(edgeValue)) {
      edge.value = edgeValue;
    }

    return edge;
  });
}

function read(json) {
  var g = new Graph(json.options).setGraph(json.value);

  _.each(json.nodes, function (entry) {
    g.setNode(entry.v, entry.value);

    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });

  _.each(json.edges, function (entry) {
    g.setEdge({
      v: entry.v,
      w: entry.w,
      name: entry.name
    }, entry.value);
  });

  return g;
}

/***/ }),

/***/ "./node_modules/graphlib/lib/lodash.js":
/*!*********************************************!*\
  !*** ./node_modules/graphlib/lib/lodash.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* global window */
var lodash;

if (true) {
  try {
    lodash = {
      clone: __webpack_require__(/*! lodash/clone */ "./node_modules/lodash/clone.js"),
      constant: __webpack_require__(/*! lodash/constant */ "./node_modules/lodash/constant.js"),
      each: __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js"),
      filter: __webpack_require__(/*! lodash/filter */ "./node_modules/lodash/filter.js"),
      has: __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js"),
      isArray: __webpack_require__(/*! lodash/isArray */ "./node_modules/lodash/isArray.js"),
      isEmpty: __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js"),
      isFunction: __webpack_require__(/*! lodash/isFunction */ "./node_modules/lodash/isFunction.js"),
      isUndefined: __webpack_require__(/*! lodash/isUndefined */ "./node_modules/lodash/isUndefined.js"),
      keys: __webpack_require__(/*! lodash/keys */ "./node_modules/lodash/keys.js"),
      map: __webpack_require__(/*! lodash/map */ "./node_modules/lodash/map.js"),
      reduce: __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js"),
      size: __webpack_require__(/*! lodash/size */ "./node_modules/lodash/size.js"),
      transform: __webpack_require__(/*! lodash/transform */ "./node_modules/lodash/transform.js"),
      union: __webpack_require__(/*! lodash/union */ "./node_modules/lodash/union.js"),
      values: __webpack_require__(/*! lodash/values */ "./node_modules/lodash/values.js")
    };
  } catch (e) {}
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;

/***/ }),

/***/ "./node_modules/graphlib/lib/version.js":
/*!**********************************************!*\
  !*** ./node_modules/graphlib/lib/version.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = '2.1.7';

/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var DataView = getNative(root, 'DataView');
module.exports = DataView;

/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `Hash`.


Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
module.exports = Hash;

/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `ListCache`.


ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
module.exports = ListCache;

/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Map = getNative(root, 'Map');
module.exports = Map;

/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;
  this.clear();

  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
} // Add methods to `MapCache`.


MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
module.exports = MapCache;

/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Promise = getNative(root, 'Promise');
module.exports = Promise;

/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var Set = getNative(root, 'Set');
module.exports = Set;

/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */


function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();

  while (++index < length) {
    this.add(values[index]);
  }
} // Add methods to `SetCache`.


SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
module.exports = SetCache;

/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */


function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
} // Add methods to `Stack`.


Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
module.exports = Stack;

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Built-in value references. */


var _Symbol = root.Symbol;
module.exports = _Symbol;

/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Built-in value references. */


var Uint8Array = root.Uint8Array;
module.exports = Uint8Array;

/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/* Built-in method references that are verified to be native. */


var WeakMap = getNative(root, 'WeakMap');
module.exports = WeakMap;

/***/ }),

/***/ "./node_modules/lodash/_apply.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);

    case 1:
      return func.call(thisArg, args[0]);

    case 2:
      return func.call(thisArg, args[0], args[1]);

    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }

  return func.apply(thisArg, args);
}

module.exports = apply;

/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }

  return array;
}

module.exports = arrayEach;

/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];

    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }

  return result;
}

module.exports = arrayFilter;

/***/ }),

/***/ "./node_modules/lodash/_arrayIncludes.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayIncludes.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js");
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */


function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

/***/ }),

/***/ "./node_modules/lodash/_arrayIncludesWith.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash/_arrayIncludesWith.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }

  return false;
}

module.exports = arrayIncludesWith;

/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */

function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
    key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
    isIndex(key, length)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = arrayLikeKeys;

/***/ }),

/***/ "./node_modules/lodash/_arrayMap.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }

  return result;
}

module.exports = arrayMap;

/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }

  return array;
}

module.exports = arrayPush;

/***/ }),

/***/ "./node_modules/lodash/_arrayReduce.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayReduce.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }

  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }

  return accumulator;
}

module.exports = arrayReduce;

/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }

  return false;
}

module.exports = arraySome;

/***/ }),

/***/ "./node_modules/lodash/_asciiSize.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_asciiSize.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js");
/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */


var asciiSize = baseProperty('length');
module.exports = asciiSize;

/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */

function assignValue(object, key, value) {
  var objValue = object[key];

  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function assocIndexOf(array, key) {
  var length = array.length;

  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }

  return -1;
}

module.exports = assocIndexOf;

/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");
/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */


function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");
/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */


function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "./node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "./node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/** Used to compose bitmasks for cloning. */


var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values supported by `_.clone`. */

var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */

function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }

  if (result !== undefined) {
    return result;
  }

  if (!isObject(value)) {
    return value;
  }

  var isArr = isArray(value);

  if (isArr) {
    result = initCloneArray(value);

    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }

    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);

      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }

      result = initCloneByTag(value, tag, isDeep);
    }
  } // Check for circular references and return its corresponding clone.


  stack || (stack = new Stack());
  var stacked = stack.get(value);

  if (stacked) {
    return stacked;
  }

  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function (subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
    return result;
  }

  if (isMap(value)) {
    value.forEach(function (subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function (subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    } // Recursively populate clone (susceptible to call stack limits).


    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/** Built-in value references. */


var objectCreate = Object.create;
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */

var baseCreate = function () {
  function object() {}

  return function (proto) {
    if (!isObject(proto)) {
      return {};
    }

    if (objectCreate) {
      return objectCreate(proto);
    }

    object.prototype = proto;
    var result = new object();
    object.prototype = undefined;
    return result;
  };
}();

module.exports = baseCreate;

/***/ }),

/***/ "./node_modules/lodash/_baseEach.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseEach.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    createBaseEach = __webpack_require__(/*! ./_createBaseEach */ "./node_modules/lodash/_createBaseEach.js");
/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */


var baseEach = createBaseEach(baseForOwn);
module.exports = baseEach;

/***/ }),

/***/ "./node_modules/lodash/_baseFilter.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseFilter.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js");
/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */


function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function (value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;

/***/ }),

/***/ "./node_modules/lodash/_baseFindIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseFindIndex.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }

  return -1;
}

module.exports = baseFindIndex;

/***/ }),

/***/ "./node_modules/lodash/_baseFlatten.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseFlatten.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isFlattenable = __webpack_require__(/*! ./_isFlattenable */ "./node_modules/lodash/_isFlattenable.js");
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */


function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];

    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }

  return result;
}

module.exports = baseFlatten;

/***/ }),

/***/ "./node_modules/lodash/_baseFor.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseFor.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var createBaseFor = __webpack_require__(/*! ./_createBaseFor */ "./node_modules/lodash/_createBaseFor.js");
/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */


var baseFor = createBaseFor();
module.exports = baseFor;

/***/ }),

/***/ "./node_modules/lodash/_baseForOwn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseForOwn.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */


function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

/***/ }),

/***/ "./node_modules/lodash/_baseGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */


function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }

  return index && index == length ? object : undefined;
}

module.exports = baseGet;

/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */


function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),

/***/ "./node_modules/lodash/_baseHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseHas.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */

function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;

/***/ }),

/***/ "./node_modules/lodash/_baseHasIn.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseHasIn.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

/***/ }),

/***/ "./node_modules/lodash/_baseIndexOf.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIndexOf.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ "./node_modules/lodash/_baseIsNaN.js"),
    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ "./node_modules/lodash/_strictIndexOf.js");
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */


function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]';
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */

function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */


function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }

  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** `Object#toString` result references. */

var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }

    objIsArr = true;
    objIsObj = false;
  }

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }

  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }

  if (!isSameTag) {
    return false;
  }

  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]';
/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */

function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;

/***/ }),

/***/ "./node_modules/lodash/_baseIsMatch.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsMatch.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */

function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }

  object = Object(object);

  while (index--) {
    var data = matchData[index];

    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }

  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();

      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }

      if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
        return false;
      }
    }
  }

  return true;
}

module.exports = baseIsMatch;

/***/ }),

/***/ "./node_modules/lodash/_baseIsNaN.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsNaN.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */


var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */

var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used for built-in method references. */

var funcProto = Function.prototype,
    objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect if a method is native. */

var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */

function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }

  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var setTag = '[object Set]';
/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */

function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;

/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/** Used to identify `toStringTag` values of typed arrays. */

var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */

function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var baseMatches = __webpack_require__(/*! ./_baseMatches */ "./node_modules/lodash/_baseMatches.js"),
    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ "./node_modules/lodash/_baseMatchesProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    property = __webpack_require__(/*! ./property */ "./node_modules/lodash/property.js");
/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */


function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }

  if (value == null) {
    return identity;
  }

  if (_typeof(value) == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }

  return property(value);
}

module.exports = baseIteratee;

/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }

  var result = [];

  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeys;

/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */

function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }

  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }

  return result;
}

module.exports = baseKeysIn;

/***/ }),

/***/ "./node_modules/lodash/_baseMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseMap.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */


function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

/***/ }),

/***/ "./node_modules/lodash/_baseMatches.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseMatches.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ "./node_modules/lodash/_baseIsMatch.js"),
    getMatchData = __webpack_require__(/*! ./_getMatchData */ "./node_modules/lodash/_getMatchData.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js");
/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */


function baseMatches(source) {
  var matchData = getMatchData(source);

  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }

  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

/***/ }),

/***/ "./node_modules/lodash/_baseMatchesProperty.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash/_baseMatchesProperty.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"),
    get = __webpack_require__(/*! ./get */ "./node_modules/lodash/get.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */

function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }

  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

/***/ }),

/***/ "./node_modules/lodash/_baseProperty.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseProperty.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

/***/ }),

/***/ "./node_modules/lodash/_basePropertyDeep.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_basePropertyDeep.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");
/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */


function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

/***/ }),

/***/ "./node_modules/lodash/_baseReduce.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseReduce.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function (value, index, collection) {
    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;

/***/ }),

/***/ "./node_modules/lodash/_baseRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseRest.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */


function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

/***/ }),

/***/ "./node_modules/lodash/_baseSetToString.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseSetToString.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var constant = __webpack_require__(/*! ./constant */ "./node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");
/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var baseSetToString = !defineProperty ? identity : function (func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};
module.exports = baseSetToString;

/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }

  return result;
}

module.exports = baseTimes;

/***/ }),

/***/ "./node_modules/lodash/_baseToString.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseToString.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */

function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }

  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }

  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = baseToString;

/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

module.exports = baseUnary;

/***/ }),

/***/ "./node_modules/lodash/_baseUniq.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseUniq.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ "./node_modules/lodash/_arrayIncludes.js"),
    arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ "./node_modules/lodash/_arrayIncludesWith.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js"),
    createSet = __webpack_require__(/*! ./_createSet */ "./node_modules/lodash/_createSet.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */

function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);

    if (set) {
      return setToArray(set);
    }

    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }

  outer: while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;
    value = comparator || value !== 0 ? value : 0;

    if (isCommon && computed === computed) {
      var seenIndex = seen.length;

      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }

      if (iteratee) {
        seen.push(computed);
      }

      result.push(value);
    } else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }

      result.push(value);
    }
  }

  return result;
}

module.exports = baseUniq;

/***/ }),

/***/ "./node_modules/lodash/_baseValues.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseValues.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js");
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */


function baseValues(object, props) {
  return arrayMap(props, function (key) {
    return object[key];
  });
}

module.exports = baseValues;

/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

/***/ }),

/***/ "./node_modules/lodash/_castFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_castFunction.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");
/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */


function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

/***/ }),

/***/ "./node_modules/lodash/_castPath.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_castPath.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    stringToPath = __webpack_require__(/*! ./_stringToPath */ "./node_modules/lodash/_stringToPath.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */


function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }

  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js");
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */


function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Detect free variable `exports`. */


var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */

function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }

  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */


function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */

function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");
/** Used to convert symbols to primitives and strings. */


var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */

function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */


function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;
  array || (array = Array(length));

  while (++index < length) {
    array[index] = source[index];
  }

  return array;
}

module.exports = copyArray;

/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */


function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }

    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }

  return object;
}

module.exports = copyObject;

/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js");
/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js");
/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */


function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Used to detect overreaching core-js shims. */


var coreJsData = root['__core-js_shared__'];
module.exports = coreJsData;

/***/ }),

/***/ "./node_modules/lodash/_createBaseEach.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createBaseEach.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */


function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }

    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }

    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }

    return collection;
  };
}

module.exports = createBaseEach;

/***/ }),

/***/ "./node_modules/lodash/_createBaseFor.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_createBaseFor.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];

      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }

    return object;
  };
}

module.exports = createBaseFor;

/***/ }),

/***/ "./node_modules/lodash/_createSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_createSet.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    noop = __webpack_require__(/*! ./noop */ "./node_modules/lodash/noop.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */

var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
  return new Set(values);
};
module.exports = createSet;

/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = function () {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}();

module.exports = defineProperty;

/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */

function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  } // Assume cyclic values are equal.


  var stacked = stack.get(array);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
  stack.set(array, other);
  stack.set(other, array); // Ignore non-index properties.

  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }

    if (compared !== undefined) {
      if (compared) {
        continue;
      }

      result = false;
      break;
    } // Recursively compare arrays (susceptible to call stack limits).


    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }

  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;
/** `Object#toString` result references. */

var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';
/** Used to convert symbols to primitives and strings. */

var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }

      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }

      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked) {
        return stacked == other;
      }

      bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }

  }

  return false;
}

module.exports = equalByTag;

/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");
/** Used to compose bitmasks for value comparisons. */


var COMPARE_PARTIAL_FLAG = 1;
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */

function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }

  var index = objLength;

  while (index--) {
    var key = objProps[index];

    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  } // Assume cyclic values are equal.


  var stacked = stack.get(object);

  if (stacked && stack.get(other)) {
    return stacked == other;
  }

  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;

  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    } // Recursively compare objects (susceptible to call stack limits).


    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }

    skipCtor || (skipCtor = key == 'constructor');
  }

  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }

  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
module.exports = freeGlobal;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */


function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */


function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

module.exports = getMapData;

/***/ }),

/***/ "./node_modules/lodash/_getMatchData.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getMatchData.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */


function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }

  return result;
}

module.exports = getMatchData;

/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */


function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");
/** Built-in value references. */


var getPrototype = overArg(Object.getPrototypeOf, Object);
module.exports = getPrototype;

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
  if (object == null) {
    return [];
  }

  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function (symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
module.exports = getSymbols;

/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeGetSymbols = Object.getOwnPropertySymbols;
/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */

var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
  var result = [];

  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }

  return result;
};
module.exports = getSymbolsIn;

/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
var dataViewTag = '[object DataView]';
/** Used to detect maps, sets, and weakmaps. */

var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function getTag(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;

        case mapCtorString:
          return mapTag;

        case promiseCtorString:
          return promiseTag;

        case setCtorString:
          return setTag;

        case weakMapCtorString:
          return weakMapTag;
      }
    }

    return result;
  };
}

module.exports = getTag;

/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

/***/ }),

/***/ "./node_modules/lodash/_hasPath.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hasPath.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */


function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);

    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }

    object = object[key];
  }

  if (result || ++index != length) {
    return result;
  }

  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

module.exports = hasPath;

/***/ }),

/***/ "./node_modules/lodash/_hasUnicode.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hasUnicode.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = "\\ufe0e\\ufe0f";
/** Used to compose unicode capture groups. */

var rsZWJ = "\\u200d";
/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */

function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;

/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */


function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */

function hashGet(key) {
  var data = this.__data__;

  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }

  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */

function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");
/** Used to stand-in for `undefined` hash values. */


var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */

function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */

function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }

  return result;
}

module.exports = initCloneArray;

/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js");
/** `Object#toString` result references. */


var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';
var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */

function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;

  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag:
    case float64Tag:
    case int8Tag:
    case int16Tag:
    case int32Tag:
    case uint8Tag:
    case uint8ClampedTag:
    case uint16Tag:
    case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor();

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor();

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js");
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */


function initCloneObject(object) {
  return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}

module.exports = initCloneObject;

/***/ }),

/***/ "./node_modules/lodash/_isFlattenable.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_isFlattenable.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/** Built-in value references. */


var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */

function isFlattenable(value) {
  return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/** Used to detect unsigned integer values. */

var reIsUint = /^(?:0|[1-9]\d*)$/;
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */

function isIndex(value, length) {
  var type = _typeof(value);

  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

/***/ }),

/***/ "./node_modules/lodash/_isKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_isKey.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used to match property names within property paths. */


var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */

function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }

  var type = _typeof(value);

  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }

  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

module.exports = isKey;

/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = _typeof(value);

  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

module.exports = isKeyable;

/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");
/** Used to detect methods masquerading as native. */


var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */


function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

module.exports = isMasked;

/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */

function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
  return value === proto;
}

module.exports = isPrototype;

/***/ }),

/***/ "./node_modules/lodash/_isStrictComparable.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash/_isStrictComparable.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */


function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/** Used for built-in method references. */


var arrayProto = Array.prototype;
/** Built-in value references. */

var splice = arrayProto.splice;
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }

  var lastIndex = data.length - 1;

  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }

  --this.size;
  return true;
}

module.exports = listCacheDelete;

/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);
  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */


function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }

  return this;
}

module.exports = listCacheSet;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */


function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

module.exports = mapCacheClear;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */


function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */


function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */


function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */


function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);
  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

/***/ }),

/***/ "./node_modules/lodash/_matchesStrictComparable.js":
/*!*********************************************************!*\
  !*** ./node_modules/lodash/_matchesStrictComparable.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }

    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

module.exports = matchesStrictComparable;

/***/ }),

/***/ "./node_modules/lodash/_memoizeCapped.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_memoizeCapped.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var memoize = __webpack_require__(/*! ./memoize */ "./node_modules/lodash/memoize.js");
/** Used as the maximum memoize cache size. */


var MAX_MEMOIZE_SIZE = 500;
/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */

function memoizeCapped(func) {
  var result = memoize(func, function (key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }

    return key;
  });
  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");
/* Built-in method references that are verified to be native. */


var nativeCreate = getNative(Object, 'create');
module.exports = nativeCreate;

/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeKeys = overArg(Object.keys, Object);
module.exports = nativeKeys;

/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];

  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }

  return result;
}

module.exports = nativeKeysIn;

/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `exports`. */


var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */

var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */

var nodeUtil = function () {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    } // Legacy `process.binding('util')` for Node.js < 10.


    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}();

module.exports = nodeUtil;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

/***/ }),

/***/ "./node_modules/lodash/_overRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js");
/* Built-in method references for those with the same name as other `lodash` methods. */


var nativeMax = Math.max;
/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */

function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? func.length - 1 : start, 0);
  return function () {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }

    index = -1;
    var otherArgs = Array(start + 1);

    while (++index < start) {
      otherArgs[index] = args[index];
    }

    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `self`. */


var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */

function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);

  return this;
}

module.exports = setCacheAdd;

/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);
  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

/***/ }),

/***/ "./node_modules/lodash/_setToString.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ "./node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__(/*! ./_shortOut */ "./node_modules/lodash/_shortOut.js");
/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */


var setToString = shortOut(baseSetToString);
module.exports = setToString;

/***/ }),

/***/ "./node_modules/lodash/_shortOut.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_shortOut.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeNow = Date.now;
/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */

function shortOut(func) {
  var count = 0,
      lastCalled = 0;
  return function () {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;

    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }

    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */


function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}

module.exports = stackClear;

/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);
  this.size = data.size;
  return result;
}

module.exports = stackDelete;

/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");
/** Used as the size to enable large array optimizations. */


var LARGE_ARRAY_SIZE = 200;
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */

function stackSet(key, value) {
  var data = this.__data__;

  if (data instanceof ListCache) {
    var pairs = data.__data__;

    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }

    data = this.__data__ = new MapCache(pairs);
  }

  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

/***/ }),

/***/ "./node_modules/lodash/_strictIndexOf.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_strictIndexOf.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }

  return -1;
}

module.exports = strictIndexOf;

/***/ }),

/***/ "./node_modules/lodash/_stringSize.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stringSize.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var asciiSize = __webpack_require__(/*! ./_asciiSize */ "./node_modules/lodash/_asciiSize.js"),
    hasUnicode = __webpack_require__(/*! ./_hasUnicode */ "./node_modules/lodash/_hasUnicode.js"),
    unicodeSize = __webpack_require__(/*! ./_unicodeSize */ "./node_modules/lodash/_unicodeSize.js");
/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */


function stringSize(string) {
  return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
}

module.exports = stringSize;

/***/ }),

/***/ "./node_modules/lodash/_stringToPath.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_stringToPath.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ "./node_modules/lodash/_memoizeCapped.js");
/** Used to match property names within property paths. */


var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/** Used to match backslashes in property paths. */

var reEscapeChar = /\\(\\)?/g;
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */

var stringToPath = memoizeCapped(function (string) {
  var result = [];

  if (string.charCodeAt(0) === 46
  /* . */
  ) {
      result.push('');
    }

  string.replace(rePropName, function (match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});
module.exports = stringToPath;

/***/ }),

/***/ "./node_modules/lodash/_toKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_toKey.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used as references for various `Number` constants. */


var INFINITY = 1 / 0;
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */

function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }

  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

module.exports = toKey;

/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used for built-in method references. */
var funcProto = Function.prototype;
/** Used to resolve the decompiled source of functions. */

var funcToString = funcProto.toString;
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */

function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}

    try {
      return func + '';
    } catch (e) {}
  }

  return '';
}

module.exports = toSource;

/***/ }),

/***/ "./node_modules/lodash/_unicodeSize.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_unicodeSize.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used to compose unicode character classes. */
var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = "\\ufe0e\\ufe0f";
/** Used to compose unicode capture groups. */

var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = "\\ud83c[\\udffb-\\udfff]",
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    rsZWJ = "\\u200d";
/** Used to compose unicode regexes. */

var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */

function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;

  while (reUnicode.test(string)) {
    ++result;
  }

  return result;
}

module.exports = unicodeSize;

/***/ }),

/***/ "./node_modules/lodash/clone.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/clone.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");
/** Used to compose bitmasks for cloning. */


var CLONE_SYMBOLS_FLAG = 4;
/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */

function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;

/***/ }),

/***/ "./node_modules/lodash/constant.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/constant.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function () {
    return value;
  };
}

module.exports = constant;

/***/ }),

/***/ "./node_modules/lodash/each.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/each.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./forEach */ "./node_modules/lodash/forEach.js");

/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

module.exports = eq;

/***/ }),

/***/ "./node_modules/lodash/filter.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/filter.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    baseFilter = __webpack_require__(/*! ./_baseFilter */ "./node_modules/lodash/_baseFilter.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 */


function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;

/***/ }),

/***/ "./node_modules/lodash/forEach.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/forEach.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */


function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

/***/ }),

/***/ "./node_modules/lodash/get.js":
/*!************************************!*\
  !*** ./node_modules/lodash/get.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");
/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */


function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

/***/ }),

/***/ "./node_modules/lodash/has.js":
/*!************************************!*\
  !*** ./node_modules/lodash/has.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseHas = __webpack_require__(/*! ./_baseHas */ "./node_modules/lodash/_baseHas.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");
/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */


function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;

/***/ }),

/***/ "./node_modules/lodash/hasIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/hasIn.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseHasIn = __webpack_require__(/*! ./_baseHasIn */ "./node_modules/lodash/_baseHasIn.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");
/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */


function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/** Built-in value references. */

var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */

var isArguments = baseIsArguments(function () {
  return arguments;
}()) ? baseIsArguments : function (value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
module.exports = isArguments;

/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;
module.exports = isArray;

/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */


function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

/***/ }),

/***/ "./node_modules/lodash/isArrayLikeObject.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/isArrayLikeObject.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */


function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");
/** Detect free variable `exports`. */


var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */

var freeModule = freeExports && ( false ? undefined : _typeof(module)) == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */

var moduleExports = freeModule && freeModule.exports === freeExports;
/** Built-in value references. */

var Buffer = moduleExports ? root.Buffer : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */

var isBuffer = nativeIsBuffer || stubFalse;
module.exports = isBuffer;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/isEmpty.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEmpty.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    setTag = '[object Set]';
/** Used for built-in method references. */

var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */

function isEmpty(value) {
  if (value == null) {
    return true;
  }

  if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }

  var tag = getTag(value);

  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }

  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }

  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }

  return true;
}

module.exports = isEmpty;

/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");
/** `Object#toString` result references. */


var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */

function isFunction(value) {
  if (!isObject(value)) {
    return false;
  } // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.


  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */

function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsMap = nodeUtil && nodeUtil.isMap;
/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */

var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
module.exports = isMap;

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && _typeof(value) == 'object';
}

module.exports = isObjectLike;

/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsSet = nodeUtil && nodeUtil.isSet;
/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */

var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
module.exports = isSet;

/***/ }),

/***/ "./node_modules/lodash/isString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isString.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var stringTag = '[object String]';
/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */

function isString(value) {
  return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
}

module.exports = isString;

/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");
/* Node.js helper references. */


var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */

var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
module.exports = isTypedArray;

/***/ }),

/***/ "./node_modules/lodash/isUndefined.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isUndefined.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;

/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */


function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */


function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj){if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */;(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined;/** Used as the semantic version number. */var VERSION='4.17.11';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange="\\ud800-\\udfff",rsComboMarksRange="\\u0300-\\u036f",reComboHalfMarksRange="\\ufe20-\\ufe2f",rsComboSymbolsRange="\\u20d0-\\u20ff",rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange="\\u2700-\\u27bf",rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange="\\u2000-\\u206f",rsSpaceRange=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange="\\ufe0e\\ufe0f",rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz="\\ud83c[\\udffb-\\udfff]",rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional="(?:\\ud83c[\\udde6-\\uddff]){2}",rsSurrPair="[\\ud800-\\udbff][\\udc00-\\udfff]",rsUpper='['+rsUpperRange+']',rsZWJ="\\u200d";/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
"\u0100":'A',"\u0102":'A',"\u0104":'A',"\u0101":'a',"\u0103":'a',"\u0105":'a',"\u0106":'C',"\u0108":'C',"\u010A":'C',"\u010C":'C',"\u0107":'c',"\u0109":'c',"\u010B":'c',"\u010D":'c',"\u010E":'D',"\u0110":'D',"\u010F":'d',"\u0111":'d',"\u0112":'E',"\u0114":'E',"\u0116":'E',"\u0118":'E',"\u011A":'E',"\u0113":'e',"\u0115":'e',"\u0117":'e',"\u0119":'e',"\u011B":'e',"\u011C":'G',"\u011E":'G',"\u0120":'G',"\u0122":'G',"\u011D":'g',"\u011F":'g',"\u0121":'g',"\u0123":'g',"\u0124":'H',"\u0126":'H',"\u0125":'h',"\u0127":'h',"\u0128":'I',"\u012A":'I',"\u012C":'I',"\u012E":'I',"\u0130":'I',"\u0129":'i',"\u012B":'i',"\u012D":'i',"\u012F":'i',"\u0131":'i',"\u0134":'J',"\u0135":'j',"\u0136":'K',"\u0137":'k',"\u0138":'k',"\u0139":'L',"\u013B":'L',"\u013D":'L',"\u013F":'L',"\u0141":'L',"\u013A":'l',"\u013C":'l',"\u013E":'l',"\u0140":'l',"\u0142":'l',"\u0143":'N',"\u0145":'N',"\u0147":'N',"\u014A":'N',"\u0144":'n',"\u0146":'n',"\u0148":'n',"\u014B":'n',"\u014C":'O',"\u014E":'O',"\u0150":'O',"\u014D":'o',"\u014F":'o',"\u0151":'o',"\u0154":'R',"\u0156":'R',"\u0158":'R',"\u0155":'r',"\u0157":'r',"\u0159":'r',"\u015A":'S',"\u015C":'S',"\u015E":'S',"\u0160":'S',"\u015B":'s',"\u015D":'s',"\u015F":'s',"\u0161":'s',"\u0162":'T',"\u0164":'T',"\u0166":'T',"\u0163":'t',"\u0165":'t',"\u0167":'t',"\u0168":'U',"\u016A":'U',"\u016C":'U',"\u016E":'U',"\u0170":'U',"\u0172":'U',"\u0169":'u',"\u016B":'u',"\u016D":'u',"\u016F":'u',"\u0171":'u',"\u0173":'u',"\u0174":'W',"\u0175":'w',"\u0176":'Y',"\u0177":'y',"\u0178":'Y',"\u0179":'Z',"\u017B":'Z',"\u017D":'Z',"\u017A":'z',"\u017C":'z',"\u017E":'z',"\u0132":'IJ',"\u0133":'ij',"\u0152":'Oe',"\u0153":'oe',"\u0149":"'n","\u017F":'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r',"\u2028":'u2028',"\u2029":'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=(typeof global==="undefined"?"undefined":_typeof(global))=='object'&&global&&global.Object===Object&&global;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=( false?undefined:_typeof(exports))=='object'&&exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&( false?undefined:_typeof(module))=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return!!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return-1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return-1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined){result=result===undefined?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return[key,object[key]];});}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return'\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return-1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined,_Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=_Symbol?_Symbol.isConcatSpreadable:undefined,symIterator=_Symbol?_Symbol.iterator:undefined,symToStringTag=_Symbol?_Symbol.toStringTag:undefined;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined,symbolValueOf=symbolProto?symbolProto.valueOf:undefined,symbolToString=symbolProto?symbolProto.toString:undefined;/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return{};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){}// No operation performed.
/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else{result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else{break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined:result;}return hasOwnProperty.call(data,key)?data[key]:undefined;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else{splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else{data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined&&!eq(object[key],value)||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return-1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else{object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined){number=number<=upper?number:upper;}if(lower!==undefined){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else{var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else{if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});return result;}if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return!length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else{arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return!length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined&&!(key in object)){return false;}}else{var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(_typeof(value)=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){if(isObject(srcValue)){stack||(stack=new Stack());baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else{var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined;if(newValue===undefined){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined;var isCommon=newValue===undefined;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else{newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else{isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){var index=-1;iteratees=arrayMap(iteratees.length?iteratees:[identity],baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return{'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else{baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined;if(newValue===undefined){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return!result;});return!!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else{high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){value=iteratee(value);var low=0,high=array==null?0:array.length,valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else{setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else{high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return+value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else{seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined?length:end;return!start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return-1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined;if(newValue===undefined){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else{assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined,guard=length>2?sources[2]:undefined;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined,args,holders,undefined,undefined,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function predicate(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else{wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined&&other===undefined){return defaultValue;}if(value!==undefined){result=value;}if(other!==undefined){if(result===undefined){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else{value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}step=step===undefined?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined,newHoldersRight=isCurry?undefined:holders,newPartials=isCurry?partials:undefined,newPartialsRight=isCurry?undefined:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return+(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined;}ary=ary===undefined?ary:nativeMax(toInteger(ary),0);arity=arity===undefined?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined;}var data=isBindKey?undefined:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else{result=createHybrid.apply(undefined,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Assume cyclic values are equal.
var stacked=stack.get(array);if(stacked&&stack.get(other)){return stacked==other;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked&&stack.get(other)){return stacked==other;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else{delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return[];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return{'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return!!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=_typeof(value);length=length==null?MAX_SAFE_INTEGER:length;return!!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=_typeof(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=_typeof(value);if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=_typeof(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return!!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return!!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else{count=0;}return func.apply(undefined,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return'';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined){size=1;}else{size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return[];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return[];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return[];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length-1;if(fromIndex!==undefined){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return[];}depth=depth===undefined?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined;}else{mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return-1;}var index=length;if(fromIndex!==undefined){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return[];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else{start=start==null?0:toInteger(start);end=end===undefined?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return-1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return[];}n=guard||n===undefined?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return[];}n=guard||n===undefined?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined;return array&&array.length?baseUniq(array,undefined,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return[];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return[];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function interceptor(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined:this.__values__[this.__index__++];return{'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined;if(result){previous.__wrapped__=clone;}else{result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else{baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else{baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return[];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return[[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined){n=1;}else{n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return[];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined,undefined,undefined,undefined,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined,undefined,undefined,undefined,undefined,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined;return result;}function cancel(){if(timerId!==undefined){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined;}function flush(){return timerId===undefined?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return!predicate.call(this);case 1:return!predicate.call(this,args[0]);case 2:return!predicate.call(this,args[0],args[1]);case 3:return!predicate.call(this,args[0],args[1],args[2]);}return!predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined,undefined,undefined,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return[];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return!value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return!value.size;}if(isPrototype(value)){return!baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined;var result=customizer?customizer(value,other):undefined;return result===undefined?baseIsEqual(value,other,undefined,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=_typeof(value);return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&_typeof(value)=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return _typeof(value)=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return[];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined,customDefaultsMerge);return apply(mergeWith,undefined,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined:baseGet(object,path);return result===undefined?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else{result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return{};}var props=arrayMap(getAllKeysIn(object),function(prop){return[prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined;}while(++index<length){var value=object==null?undefined:object[toKey(path[index])];if(value===undefined){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else{accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined){upper=lower;lower=undefined;}if(upper!==undefined){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined){end=start;start=0;}else{end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined;}if(floating===undefined){if(typeof upper=='boolean'){floating=upper;upper=undefined;}else if(typeof lower=='boolean'){floating=lower;lower=undefined;}}if(lower===undefined&&upper===undefined){lower=0;upper=1;}else{lower=toFinite(lower);if(upper===undefined){upper=lower;lower=0;}else{upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined){n=1;}else{n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined;}limit=limit===undefined?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return[];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
var sourceURL='//# sourceURL='+('sourceURL'in options?options.sourceURL:'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined:pattern;if(pattern===undefined){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return[toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){}// No operation performed.
/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return[];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return{};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return'';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return[];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else{result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function interceptor(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'',names=realNames[key]||(realNames[key]=[]);names.push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if( true&&_typeof(__webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"))=='object'&&__webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")){// Expose Lodash on the global object to prevent errors when Lodash is
// loaded by a script tag in the presence of an AMD loader.
// See http://requirejs.org/docs/errors.html#mismatch for more details.
// Use `_.noConflict` to remove Lodash from the global object.
root._=_;// Define as an anonymous module so, through path mapping, it can be
// referenced as the "underscore" module.
!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return _;}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}// Check for `exports` after `define` in case a build optimizer adds it.
else if(freeModule){// Export for Node.js.
(freeModule.exports=_)._=_;// Export for CommonJS support.
freeExports._=_;}else{// Export to the global object.
root._=_;}}).call(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/lodash/map.js":
/*!************************************!*\
  !*** ./node_modules/lodash/map.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseMap = __webpack_require__(/*! ./_baseMap */ "./node_modules/lodash/_baseMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */


function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;

/***/ }),

/***/ "./node_modules/lodash/memoize.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/memoize.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */

function memoize(func, resolver) {
  if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }

    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };

  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
} // Expose `MapCache`.


memoize.Cache = MapCache;
module.exports = memoize;

/***/ }),

/***/ "./node_modules/lodash/noop.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/noop.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {// No operation performed.
}

module.exports = noop;

/***/ }),

/***/ "./node_modules/lodash/property.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/property.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js"),
    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ "./node_modules/lodash/_basePropertyDeep.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");
/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */


function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

/***/ }),

/***/ "./node_modules/lodash/reduce.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/reduce.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayReduce = __webpack_require__(/*! ./_arrayReduce */ "./node_modules/lodash/_arrayReduce.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseReduce = __webpack_require__(/*! ./_baseReduce */ "./node_modules/lodash/_baseReduce.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");
/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */


function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;
  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;

/***/ }),

/***/ "./node_modules/lodash/size.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/size.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isString = __webpack_require__(/*! ./isString */ "./node_modules/lodash/isString.js"),
    stringSize = __webpack_require__(/*! ./_stringSize */ "./node_modules/lodash/_stringSize.js");
/** `Object#toString` result references. */


var mapTag = '[object Map]',
    setTag = '[object Set]';
/**
 * Gets the size of `collection` by returning its length for array-like
 * values or the number of own enumerable string keyed properties for objects.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @returns {number} Returns the collection size.
 * @example
 *
 * _.size([1, 2, 3]);
 * // => 3
 *
 * _.size({ 'a': 1, 'b': 2 });
 * // => 2
 *
 * _.size('pebbles');
 * // => 7
 */

function size(collection) {
  if (collection == null) {
    return 0;
  }

  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length;
  }

  var tag = getTag(collection);

  if (tag == mapTag || tag == setTag) {
    return collection.size;
  }

  return baseKeys(collection).length;
}

module.exports = size;

/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

/***/ }),

/***/ "./node_modules/lodash/toString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js");
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */


function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

/***/ }),

/***/ "./node_modules/lodash/transform.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/transform.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");
/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */


function transform(object, iteratee, accumulator) {
  var isArr = isArray(object),
      isArrLike = isArr || isBuffer(object) || isTypedArray(object);
  iteratee = baseIteratee(iteratee, 4);

  if (accumulator == null) {
    var Ctor = object && object.constructor;

    if (isArrLike) {
      accumulator = isArr ? new Ctor() : [];
    } else if (isObject(object)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
    } else {
      accumulator = {};
    }
  }

  (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

module.exports = transform;

/***/ }),

/***/ "./node_modules/lodash/union.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/union.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    baseUniq = __webpack_require__(/*! ./_baseUniq */ "./node_modules/lodash/_baseUniq.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js");
/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */


var union = baseRest(function (arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});
module.exports = union;

/***/ }),

/***/ "./node_modules/lodash/values.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/values.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var baseValues = __webpack_require__(/*! ./_baseValues */ "./node_modules/lodash/_baseValues.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");
/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */


function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;

/***/ }),

/***/ "./node_modules/native-promise-only/lib/npo.src.js":
/*!*********************************************************!*\
  !*** ./node_modules/native-promise-only/lib/npo.src.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, setImmediate) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! Native Promise Only
    v0.8.1 (c) Kyle Simpson
    MIT License: http://getify.mit-license.org
*/
(function UMD(name, context, definition) {
  // special form of UMD for polyfilling across evironments
  context[name] = context[name] || definition();

  if ( true && module.exports) {
    module.exports = context[name];
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function $AMD$() {
      return context[name];
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
})("Promise", typeof global != "undefined" ? global : this, function DEF() {
  /*jshint validthis:true */
  "use strict";

  var builtInProp,
      cycle,
      scheduling_queue,
      ToString = Object.prototype.toString,
      timer = typeof setImmediate != "undefined" ? function timer(fn) {
    return setImmediate(fn);
  } : setTimeout; // dammit, IE8.

  try {
    Object.defineProperty({}, "x", {});

    builtInProp = function builtInProp(obj, name, val, config) {
      return Object.defineProperty(obj, name, {
        value: val,
        writable: true,
        configurable: config !== false
      });
    };
  } catch (err) {
    builtInProp = function builtInProp(obj, name, val) {
      obj[name] = val;
      return obj;
    };
  } // Note: using a queue instead of array for efficiency


  scheduling_queue = function Queue() {
    var first, last, item;

    function Item(fn, self) {
      this.fn = fn;
      this.self = self;
      this.next = void 0;
    }

    return {
      add: function add(fn, self) {
        item = new Item(fn, self);

        if (last) {
          last.next = item;
        } else {
          first = item;
        }

        last = item;
        item = void 0;
      },
      drain: function drain() {
        var f = first;
        first = last = cycle = void 0;

        while (f) {
          f.fn.call(f.self);
          f = f.next;
        }
      }
    };
  }();

  function schedule(fn, self) {
    scheduling_queue.add(fn, self);

    if (!cycle) {
      cycle = timer(scheduling_queue.drain);
    }
  } // promise duck typing


  function isThenable(o) {
    var _then,
        o_type = _typeof(o);

    if (o != null && (o_type == "object" || o_type == "function")) {
      _then = o.then;
    }

    return typeof _then == "function" ? _then : false;
  }

  function notify() {
    for (var i = 0; i < this.chain.length; i++) {
      notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);
    }

    this.chain.length = 0;
  } // NOTE: This is a separate function to isolate
  // the `try..catch` so that other code can be
  // optimized better


  function notifyIsolated(self, cb, chain) {
    var ret, _then;

    try {
      if (cb === false) {
        chain.reject(self.msg);
      } else {
        if (cb === true) {
          ret = self.msg;
        } else {
          ret = cb.call(void 0, self.msg);
        }

        if (ret === chain.promise) {
          chain.reject(TypeError("Promise-chain cycle"));
        } else if (_then = isThenable(ret)) {
          _then.call(ret, chain.resolve, chain.reject);
        } else {
          chain.resolve(ret);
        }
      }
    } catch (err) {
      chain.reject(err);
    }
  }

  function resolve(msg) {
    var _then,
        self = this; // already triggered?


    if (self.triggered) {
      return;
    }

    self.triggered = true; // unwrap

    if (self.def) {
      self = self.def;
    }

    try {
      if (_then = isThenable(msg)) {
        schedule(function () {
          var def_wrapper = new MakeDefWrapper(self);

          try {
            _then.call(msg, function $resolve$() {
              resolve.apply(def_wrapper, arguments);
            }, function $reject$() {
              reject.apply(def_wrapper, arguments);
            });
          } catch (err) {
            reject.call(def_wrapper, err);
          }
        });
      } else {
        self.msg = msg;
        self.state = 1;

        if (self.chain.length > 0) {
          schedule(notify, self);
        }
      }
    } catch (err) {
      reject.call(new MakeDefWrapper(self), err);
    }
  }

  function reject(msg) {
    var self = this; // already triggered?

    if (self.triggered) {
      return;
    }

    self.triggered = true; // unwrap

    if (self.def) {
      self = self.def;
    }

    self.msg = msg;
    self.state = 2;

    if (self.chain.length > 0) {
      schedule(notify, self);
    }
  }

  function iteratePromises(Constructor, arr, resolver, rejecter) {
    for (var idx = 0; idx < arr.length; idx++) {
      (function IIFE(idx) {
        Constructor.resolve(arr[idx]).then(function $resolver$(msg) {
          resolver(idx, msg);
        }, rejecter);
      })(idx);
    }
  }

  function MakeDefWrapper(self) {
    this.def = self;
    this.triggered = false;
  }

  function MakeDef(self) {
    this.promise = self;
    this.state = 0;
    this.triggered = false;
    this.chain = [];
    this.msg = void 0;
  }

  function Promise(executor) {
    if (typeof executor != "function") {
      throw TypeError("Not a function");
    }

    if (this.__NPO__ !== 0) {
      throw TypeError("Not a promise");
    } // instance shadowing the inherited "brand"
    // to signal an already "initialized" promise


    this.__NPO__ = 1;
    var def = new MakeDef(this);

    this["then"] = function then(success, failure) {
      var o = {
        success: typeof success == "function" ? success : true,
        failure: typeof failure == "function" ? failure : false
      }; // Note: `then(..)` itself can be borrowed to be used against
      // a different promise constructor for making the chained promise,
      // by substituting a different `this` binding.

      o.promise = new this.constructor(function extractChain(resolve, reject) {
        if (typeof resolve != "function" || typeof reject != "function") {
          throw TypeError("Not a function");
        }

        o.resolve = resolve;
        o.reject = reject;
      });
      def.chain.push(o);

      if (def.state !== 0) {
        schedule(notify, def);
      }

      return o.promise;
    };

    this["catch"] = function $catch$(failure) {
      return this.then(void 0, failure);
    };

    try {
      executor.call(void 0, function publicResolve(msg) {
        resolve.call(def, msg);
      }, function publicReject(msg) {
        reject.call(def, msg);
      });
    } catch (err) {
      reject.call(def, err);
    }
  }

  var PromisePrototype = builtInProp({}, "constructor", Promise,
  /*configurable=*/
  false); // Note: Android 4 cannot use `Object.defineProperty(..)` here

  Promise.prototype = PromisePrototype; // built-in "brand" to signal an "uninitialized" promise

  builtInProp(PromisePrototype, "__NPO__", 0,
  /*configurable=*/
  false);
  builtInProp(Promise, "resolve", function Promise$resolve(msg) {
    var Constructor = this; // spec mandated checks
    // note: best "isPromise" check that's practical for now

    if (msg && _typeof(msg) == "object" && msg.__NPO__ === 1) {
      return msg;
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      resolve(msg);
    });
  });
  builtInProp(Promise, "reject", function Promise$reject(msg) {
    return new this(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      reject(msg);
    });
  });
  builtInProp(Promise, "all", function Promise$all(arr) {
    var Constructor = this; // spec mandated checks

    if (ToString.call(arr) != "[object Array]") {
      return Constructor.reject(TypeError("Not an array"));
    }

    if (arr.length === 0) {
      return Constructor.resolve([]);
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      var len = arr.length,
          msgs = Array(len),
          count = 0;
      iteratePromises(Constructor, arr, function resolver(idx, msg) {
        msgs[idx] = msg;

        if (++count === len) {
          resolve(msgs);
        }
      }, reject);
    });
  });
  builtInProp(Promise, "race", function Promise$race(arr) {
    var Constructor = this; // spec mandated checks

    if (ToString.call(arr) != "[object Array]") {
      return Constructor.reject(TypeError("Not an array"));
    }

    return new Constructor(function executor(resolve, reject) {
      if (typeof resolve != "function" || typeof reject != "function") {
        throw TypeError("Not a function");
      }

      iteratePromises(Constructor, arr, function resolver(idx, msg) {
        resolve(msg);
      }, reject);
    });
  });
  return Promise;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/path-browserify/index.js":
/*!***********************************************!*\
  !*** ./node_modules/path-browserify/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;

  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];

    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
} // Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.


var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;

var splitPath = function splitPath(filename) {
  return splitPathRe.exec(filename).slice(1);
}; // path.resolve([from ...], to)
// posix version


exports.resolve = function () {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries

    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  } // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path


  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
    return !!p;
  }), !resolvedAbsolute).join('/');
  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
}; // path.normalize(path)
// posix version


exports.normalize = function (path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/'; // Normalize the path

  path = normalizeArray(filter(path.split('/'), function (p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }

  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
}; // posix version


exports.isAbsolute = function (path) {
  return path.charAt(0) === '/';
}; // posix version


exports.join = function () {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function (p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }

    return p;
  }).join('/'));
}; // path.relative(from, to)
// posix version


exports.relative = function (from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;

    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;

    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;

  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];

  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};

exports.basename = function (path, ext) {
  var f = splitPath(path)[2]; // TODO: make this comparison case-insensitive on windows?

  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }

  return f;
};

exports.extname = function (path) {
  return splitPath(path)[3];
};

function filter(xs, f) {
  if (xs.filter) return xs.filter(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    if (f(xs[i], i, xs)) res.push(xs[i]);
  }

  return res;
} // String.prototype.substr - negative index don't work in IE8


var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
  return str.substr(start, len);
} : function (str, start, len) {
  if (start < 0) start = str.length + start;
  return str.substr(start, len);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/path-loader/index.js":
/*!*******************************************!*\
  !*** ./node_modules/path-loader/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var supportedLoaders = {
  file: __webpack_require__(/*! ./lib/loaders/file */ "./node_modules/path-loader/lib/loaders/file-browser.js"),
  http: __webpack_require__(/*! ./lib/loaders/http */ "./node_modules/path-loader/lib/loaders/http.js"),
  https: __webpack_require__(/*! ./lib/loaders/http */ "./node_modules/path-loader/lib/loaders/http.js")
};
var defaultLoader = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' || typeof importScripts === 'function' ? supportedLoaders.http : supportedLoaders.file; // Load promises polyfill if necessary

/* istanbul ignore if */

if (typeof Promise === 'undefined') {
  __webpack_require__(/*! native-promise-only */ "./node_modules/native-promise-only/lib/npo.src.js");
}

function getScheme(location) {
  if (typeof location !== 'undefined') {
    location = location.indexOf('://') === -1 ? '' : location.split('://')[0];
  }

  return location;
}
/**
 * Utility that provides a single API for loading the content of a path/URL.
 *
 * @module path-loader
 */


function getLoader(location) {
  var scheme = getScheme(location);
  var loader = supportedLoaders[scheme];

  if (typeof loader === 'undefined') {
    if (scheme === '') {
      loader = defaultLoader;
    } else {
      throw new Error('Unsupported scheme: ' + scheme);
    }
  }

  return loader;
}
/**
 * Loads a document at the provided location and returns a JavaScript object representation.
 *
 * @param {string} location - The location to the document
 * @param {module:path-loader~LoadOptions} [options] - The loader options
 *
 * @returns {Promise<*>} Always returns a promise even if there is a callback provided
 *
 * @example
 * // Example using Promises
 *
 * PathLoader
 *   .load('./package.json')
 *   .then(JSON.parse)
 *   .then(function (document) {
 *     console.log(document.name + ' (' + document.version + '): ' + document.description);
 *   }, function (err) {
 *     console.error(err.stack);
 *   });
 *
 * @example
 * // Example using options.prepareRequest to provide authentication details for a remotely secure URL
 *
 * PathLoader
 *   .load('https://api.github.com/repos/whitlockjc/path-loader', {
 *     prepareRequest: function (req, callback) {
 *       req.auth('my-username', 'my-password');
 *       callback(undefined, req);
 *     }
 *   })
 *   .then(JSON.parse)
 *   .then(function (document) {
 *     console.log(document.full_name + ': ' + document.description);
 *   }, function (err) {
 *     console.error(err.stack);
 *   });
 *
 * @example
 * // Example loading a YAML file
 *
 * PathLoader
 *   .load('/Users/not-you/projects/path-loader/.travis.yml')
 *   .then(YAML.safeLoad)
 *   .then(function (document) {
 *     console.log('path-loader uses the', document.language, 'language.');
 *   }, function (err) {
 *     console.error(err.stack);
 *   });
 *
 * @example
 * // Example loading a YAML file with options.processContent (Useful if you need information in the raw response)
 *
 * PathLoader
 *   .load('/Users/not-you/projects/path-loader/.travis.yml', {
 *     processContent: function (res, callback) {
 *       callback(YAML.safeLoad(res.text));
 *     }
 *   })
 *   .then(function (document) {
 *     console.log('path-loader uses the', document.language, 'language.');
 *   }, function (err) {
 *     console.error(err.stack);
 *   });
 */


module.exports.load = function (location, options) {
  var allTasks = Promise.resolve(); // Default options to empty object

  if (typeof options === 'undefined') {
    options = {};
  } // Validate arguments


  allTasks = allTasks.then(function () {
    if (typeof location === 'undefined') {
      throw new TypeError('location is required');
    } else if (typeof location !== 'string') {
      throw new TypeError('location must be a string');
    }

    if (typeof options !== 'undefined') {
      if (_typeof(options) !== 'object') {
        throw new TypeError('options must be an object');
      } else if (typeof options.processContent !== 'undefined' && typeof options.processContent !== 'function') {
        throw new TypeError('options.processContent must be a function');
      }
    }
  }); // Load the document from the provided location and process it

  allTasks = allTasks.then(function () {
    return new Promise(function (resolve, reject) {
      var loader = getLoader(location);
      loader.load(location, options || {}, function (err, document) {
        if (err) {
          reject(err);
        } else {
          resolve(document);
        }
      });
    });
  }).then(function (res) {
    if (options.processContent) {
      return new Promise(function (resolve, reject) {
        // For consistency between file and http, always send an object with a 'text' property containing the raw
        // string value being processed.
        options.processContent(_typeof(res) === 'object' ? res : {
          text: res
        }, function (err, processed) {
          if (err) {
            reject(err);
          } else {
            resolve(processed);
          }
        });
      });
    } else {
      // If there was no content processor, we will assume that for all objects that it is a Superagent response
      // and will return its `text` property value.  Otherwise, we will return the raw response.
      return _typeof(res) === 'object' ? res.text : res;
    }
  });
  return allTasks;
};

/***/ }),

/***/ "./node_modules/path-loader/lib/loaders/file-browser.js":
/*!**************************************************************!*\
  !*** ./node_modules/path-loader/lib/loaders/file-browser.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


var unsupportedError = new TypeError('The \'file\' scheme is not supported in the browser');
/**
 * The file loader is not supported in the browser.
 *
 * @throws {error} the file loader is not supported in the browser
 */

module.exports.getBase = function () {
  throw unsupportedError;
};
/**
 * The file loader is not supported in the browser.
 */


module.exports.load = function () {
  var fn = arguments[arguments.length - 1];

  if (typeof fn === 'function') {
    fn(unsupportedError);
  } else {
    throw unsupportedError;
  }
};

/***/ }),

/***/ "./node_modules/path-loader/lib/loaders/http.js":
/*!******************************************************!*\
  !*** ./node_modules/path-loader/lib/loaders/http.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env node, browser */

/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Jeremy Whitlock
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


var request = __webpack_require__(/*! superagent */ "./node_modules/superagent/lib/client.js");

var supportedHttpMethods = ['delete', 'get', 'head', 'patch', 'post', 'put'];
/**
 * Loads a file from an http or https URL.
 *
 * @param {string} location - The document URL (If relative, location is relative to window.location.origin).
 * @param {object} options - The loader options
 * @param {string} [options.method=get] - The HTTP method to use for the request
 * @param {module:PathLoader~PrepareRequestCallback} [options.prepareRequest] - The callback used to prepare a request
 * @param {module:PathLoader~ProcessResponseCallback} [options.processContent] - The callback used to process the
 * response
 * @param {function} callback - The error-first callback
 */

module.exports.load = function (location, options, callback) {
  var realMethod = options.method ? options.method.toLowerCase() : 'get';
  var err;
  var realRequest;

  function makeRequest(err, req) {
    if (err) {
      callback(err);
    } else {
      // buffer() is only available in Node.js
      if (Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]' && typeof req.buffer === 'function') {
        req.buffer(true);
      }

      req.end(function (err2, res) {
        if (err2) {
          callback(err2);
        } else {
          callback(undefined, res);
        }
      });
    }
  }

  if (typeof options.method !== 'undefined') {
    if (typeof options.method !== 'string') {
      err = new TypeError('options.method must be a string');
    } else if (supportedHttpMethods.indexOf(options.method) === -1) {
      err = new TypeError('options.method must be one of the following: ' + supportedHttpMethods.slice(0, supportedHttpMethods.length - 1).join(', ') + ' or ' + supportedHttpMethods[supportedHttpMethods.length - 1]);
    }
  } else if (typeof options.prepareRequest !== 'undefined' && typeof options.prepareRequest !== 'function') {
    err = new TypeError('options.prepareRequest must be a function');
  }

  if (!err) {
    realRequest = request[realMethod === 'delete' ? 'del' : realMethod](location);

    if (options.prepareRequest) {
      try {
        options.prepareRequest(realRequest, makeRequest);
      } catch (err2) {
        callback(err2);
      }
    } else {
      makeRequest(undefined, realRequest);
    }
  } else {
    callback(err);
  }
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (_typeof(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (_typeof(obj) === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }

  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }

  return res;
};

/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 6–8
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/slash/index.js":
/*!*************************************!*\
  !*** ./node_modules/slash/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (input) {
  var isExtendedLengthPath = /^\\\\\?\\/.test(input);
  var hasNonAscii = /[^\u0000-\u0080]+/.test(input); // eslint-disable-line no-control-regex

  if (isExtendedLengthPath || hasNonAscii) {
    return input;
  }

  return input.replace(/\\/g, '/');
};

/***/ }),

/***/ "./node_modules/superagent/lib/agent-base.js":
/*!***************************************************!*\
  !*** ./node_modules/superagent/lib/agent-base.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function (fn) {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function ()
  /*varargs*/
  {
    this._defaults.push({
      fn: fn,
      arguments: arguments
    });

    return this;
  };
});

Agent.prototype._setDefaults = function (req) {
  this._defaults.forEach(function (def) {
    req[def.fn].apply(req, def.arguments);
  });
};

module.exports = Agent;

/***/ }),

/***/ "./node_modules/superagent/lib/client.js":
/*!***********************************************!*\
  !*** ./node_modules/superagent/lib/client.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Root reference for iframes.
 */
var root;

if (typeof window !== 'undefined') {
  // Browser window
  root = window;
} else if (typeof self !== 'undefined') {
  // Web Worker
  root = self;
} else {
  // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

var RequestBase = __webpack_require__(/*! ./request-base */ "./node_modules/superagent/lib/request-base.js");

var isObject = __webpack_require__(/*! ./is-object */ "./node_modules/superagent/lib/is-object.js");

var ResponseBase = __webpack_require__(/*! ./response-base */ "./node_modules/superagent/lib/response-base.js");

var Agent = __webpack_require__(/*! ./agent-base */ "./node_modules/superagent/lib/agent-base.js");
/**
 * Noop.
 */


function noop() {}

;
/**
 * Expose `request`.
 */

var request = exports = module.exports = function (method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  } // url first


  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
};

exports.Request = Request;
/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest && (!root.location || 'file:' != root.location.protocol || !root.ActiveXObject)) {
    return new XMLHttpRequest();
  } else {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch (e) {}

    try {
      return new ActiveXObject('Msxml2.XMLHTTP.6.0');
    } catch (e) {}

    try {
      return new ActiveXObject('Msxml2.XMLHTTP.3.0');
    } catch (e) {}

    try {
      return new ActiveXObject('Msxml2.XMLHTTP');
    } catch (e) {}
  }

  throw Error("Browser-only version of superagent could not find XHR");
};
/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */


var trim = ''.trim ? function (s) {
  return s.trim();
} : function (s) {
  return s.replace(/(^\s*|\s*$)/g, '');
};
/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];

  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }

  return pairs.join('&');
}
/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */


function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function (v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for (var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}
/**
 * Expose serialization method.
 */


request.serializeObject = serialize;
/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');

    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] = decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}
/**
 * Expose parser.
 */


request.parseString = parseString;
/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};
/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};
/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};
/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');

    if (index === -1) {
      // could be empty line, just skip it
      continue;
    }

    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}
/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */


function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}
/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */


function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr; // responseText is accessible only if responseType is '' or 'text' and on older browsers

  this.text = this.req.method != 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text') || typeof this.xhr.responseType === 'undefined' ? this.xhr.responseText : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status; // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request

  if (status === 1223) {
    status = 204;
  }

  this._setStatusProperties(status);

  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders()); // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.

  this.header['content-type'] = this.xhr.getResponseHeader('content-type');

  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD' ? this._parseBody(this.text ? this.text : this.xhr.response) : null;
  }
}

ResponseBase(Response.prototype);
/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function (str) {
  var parse = request.parse[this.type];

  if (this.req._parser) {
    return this.req._parser(this, str);
  }

  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }

  return parse && str && (str.length || str instanceof Object) ? parse(str) : null;
};
/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */


Response.prototype.toError = function () {
  var req = this.req;
  var method = req.method;
  var url = req.url;
  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;
  return err;
};
/**
 * Expose `Response`.
 */


request.Response = Response;
/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case

  this._header = {}; // coerces header names to lowercase

  this.on('end', function () {
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch (e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e; // issue #675: return the raw response if the response parsing fails

      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response; // issue #876: return the http status code if the response parsing fails

        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);
    var new_err;

    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch (custom_err) {
      new_err = custom_err; // ok() callback can throw
    } // #1000 don't catch errors from the callback to avoid double calling it


    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}
/**
 * Mixin `Emitter` and `RequestBase`.
 */


Emitter(Request.prototype);
RequestBase(Request.prototype);
/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function (type) {
  this.set('Content-Type', request.types[type] || type);
  return this;
};
/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.accept = function (type) {
  this.set('Accept', request.types[type] || type);
  return this;
};
/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.auth = function (user, pass, options) {
  if (1 === arguments.length) pass = '';

  if (_typeof(pass) === 'object' && pass !== null) {
    // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }

  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto'
    };
  }

  var encoder = function encoder(string) {
    if ('function' === typeof btoa) {
      return btoa(string);
    }

    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};
/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.query = function (val) {
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};
/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.attach = function (field, file, options) {
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }

  return this;
};

Request.prototype._getFormData = function () {
  if (!this._formData) {
    this._formData = new root.FormData();
  }

  return this._formData;
};
/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */


Request.prototype.callback = function (err, res) {
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};
/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */


Request.prototype.crossDomainError = function () {
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;
  err.status = this.status;
  err.method = this.method;
  err.url = this.url;
  this.callback(err);
}; // This only warns, because the request is still likely to work


Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function () {
  console.warn("This is not supported in browser version of superagent");
  return this;
}; // This throws, because it can't send/receive data as expected


Request.prototype.pipe = Request.prototype.write = function () {
  throw Error("Streaming is not supported in browser version of superagent");
};
/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */


Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === _typeof(obj) && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
};
/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */


Request.prototype.end = function (fn) {
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }

  this._endCalled = true; // store callback

  this._callback = fn || noop; // querystring

  this._finalizeQueryString();

  return this._end();
};

Request.prototype._end = function () {
  var self = this;
  var xhr = this.xhr = request.getXHR();
  var data = this._formData || this._data;

  this._setTimeouts(); // state change


  xhr.onreadystatechange = function () {
    var readyState = xhr.readyState;

    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }

    if (4 != readyState) {
      return;
    } // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"


    var status;

    try {
      status = xhr.status;
    } catch (e) {
      status = 0;
    }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }

    self.emit('end');
  }; // progress


  var handleProgress = function handleProgress(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }

    e.direction = direction;
    self.emit('progress', e);
  };

  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');

      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch (e) {// Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  } // initiate request


  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  } // CORS


  if (this._withCredentials) xhr.withCredentials = true; // body

  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];

    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }

    if (serialize) data = serialize(data);
  } // set header fields


  for (var field in this.header) {
    if (null == this.header[field]) continue;
    if (this.header.hasOwnProperty(field)) xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  } // send stuff


  this.emit('request', this); // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined

  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

request.agent = function () {
  return new Agent();
};

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function (method) {
  Agent.prototype[method.toLowerCase()] = function (url, fn) {
    var req = new request.Request(method, url);

    this._setDefaults(req);

    if (fn) {
      req.end(fn);
    }

    return req;
  };
});
Agent.prototype.del = Agent.prototype['delete'];
/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function (url, data, fn) {
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.head = function (url, data, fn) {
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.options = function (url, data, fn) {
  var req = request('OPTIONS', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


function del(url, data, fn) {
  var req = request('DELETE', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;
/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function (url, data, fn) {
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.post = function (url, data, fn) {
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};
/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */


request.put = function (url, data, fn) {
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/***/ }),

/***/ "./node_modules/superagent/lib/is-object.js":
/*!**************************************************!*\
  !*** ./node_modules/superagent/lib/is-object.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isObject(obj) {
  return null !== obj && 'object' === _typeof(obj);
}

module.exports = isObject;

/***/ }),

/***/ "./node_modules/superagent/lib/request-base.js":
/*!*****************************************************!*\
  !*** ./node_modules/superagent/lib/request-base.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Module of mixed-in functions shared between node and client code
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var isObject = __webpack_require__(/*! ./is-object */ "./node_modules/superagent/lib/is-object.js");
/**
 * Expose `RequestBase`.
 */


module.exports = RequestBase;
/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }

  return obj;
}
/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.clearTimeout = function _clearTimeout() {
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};
/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.parse = function parse(fn) {
  this._parser = fn;
  return this;
};
/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.responseType = function (val) {
  this._responseType = val;
  return this;
};
/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */


RequestBase.prototype.serialize = function serialize(fn) {
  this._serializer = fn;
  return this;
};
/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.timeout = function timeout(options) {
  if (!options || 'object' !== _typeof(options)) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for (var option in options) {
    switch (option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;

      case 'response':
        this._responseTimeout = options.response;
        break;

      default:
        console.warn("Unknown timeout option", option);
    }
  }

  return this;
};
/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.retry = function retry(count, fn) {
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = ['ECONNRESET', 'ETIMEDOUT', 'EADDRINFO', 'ESOCKETTIMEDOUT'];
/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */

RequestBase.prototype._shouldRetry = function (err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }

  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);

      if (override === true) return true;
      if (override === false) return false; // undefined falls back to defaults
    } catch (e) {
      console.error(e);
    }
  }

  if (res && res.status && res.status >= 500 && res.status != 501) return true;

  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true; // Superagent timeout

    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }

  return false;
};
/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */


RequestBase.prototype._retry = function () {
  this.clearTimeout(); // node

  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;
  return this._end();
};
/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */


RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;

    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }

    this._fullfilledPromise = new Promise(function (innerResolve, innerReject) {
      self.end(function (err, res) {
        if (err) innerReject(err);else innerResolve(res);
      });
    });
  }

  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function (cb) {
  return this.then(undefined, cb);
};
/**
 * Allow for extension
 */


RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function (cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function (res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};
/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


RequestBase.prototype.get = function (field) {
  return this._header[field.toLowerCase()];
};
/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */


RequestBase.prototype.getHeader = RequestBase.prototype.get;
/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function (field, val) {
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }

    return this;
  }

  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};
/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */


RequestBase.prototype.unset = function (field) {
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};
/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.field = function (name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }

    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }

    return this;
  } // val should be defined now


  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }

  if ('boolean' === typeof val) {
    val = '' + val;
  }

  this._getFormData().append(name, val);

  return this;
};
/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */


RequestBase.prototype.abort = function () {
  if (this._aborted) {
    return this;
  }

  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser

  this.req && this.req.abort(); // node

  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function (user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer':
      // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
      break;
  }

  return this;
};
/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */


RequestBase.prototype.withCredentials = function (on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};
/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.redirects = function (n) {
  this._maxRedirects = n;
  return this;
};
/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */


RequestBase.prototype.maxResponseSize = function (n) {
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }

  this._maxResponseSize = n;
  return this;
};
/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */


RequestBase.prototype.toJSON = function () {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};
/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.send = function (data) {
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  } // merge


  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];

    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data ? this._data + '&' + data : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  } // default to json


  if (!type) this.type('json');
  return this;
};
/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */


RequestBase.prototype.sortQuery = function (sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};
/**
 * Compose querystring to append to req.url
 *
 * @api private
 */


RequestBase.prototype._finalizeQueryString = function () {
  var query = this._query.join('&');

  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }

  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');

    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');

      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }

      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
}; // For backwards compat only


RequestBase.prototype._appendQueryString = function () {
  console.trace("Unsupported");
};
/**
 * Invoke callback with timeout error.
 *
 * @api private
 */


RequestBase.prototype._timeoutError = function (reason, timeout, errno) {
  if (this._aborted) {
    return;
  }

  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function () {
  var self = this; // deadline

  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function () {
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  } // response timeout


  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function () {
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};

/***/ }),

/***/ "./node_modules/superagent/lib/response-base.js":
/*!******************************************************!*\
  !*** ./node_modules/superagent/lib/response-base.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Module dependencies.
 */

var utils = __webpack_require__(/*! ./utils */ "./node_modules/superagent/lib/utils.js");
/**
 * Expose `ResponseBase`.
 */


module.exports = ResponseBase;
/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}
/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */


function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }

  return obj;
}
/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */


ResponseBase.prototype.get = function (field) {
  return this.header[field.toLowerCase()];
};
/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */


ResponseBase.prototype._setHeaderProperties = function (header) {
  // TODO: moar!
  // TODO: make this a util
  // content-type
  var ct = header['content-type'] || '';
  this.type = utils.type(ct); // params

  var params = utils.params(ct);

  for (var key in params) {
    this[key] = params[key];
  }

  this.links = {}; // links

  try {
    if (header.link) {
      this.links = utils.parseLinks(header.link);
    }
  } catch (err) {// ignore
  }
};
/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */


ResponseBase.prototype._setStatusProperties = function (status) {
  var type = status / 100 | 0; // status / class

  this.status = this.statusCode = status;
  this.statusType = type; // basics

  this.info = 1 == type;
  this.ok = 2 == type;
  this.redirect = 3 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = 4 == type || 5 == type ? this.toError() : false; // sugar

  this.created = 201 == status;
  this.accepted = 202 == status;
  this.noContent = 204 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.forbidden = 403 == status;
  this.notFound = 404 == status;
  this.unprocessableEntity = 422 == status;
};

/***/ }),

/***/ "./node_modules/superagent/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/superagent/lib/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function (str) {
  return str.split(/ *; */).shift();
};
/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.params = function (str) {
  return str.split(/ *; */).reduce(function (obj, str) {
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();
    if (key && val) obj[key] = val;
    return obj;
  }, {});
};
/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */


exports.parseLinks = function (str) {
  return str.split(/ *, */).reduce(function (obj, str) {
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};
/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */


exports.cleanHeader = function (header, changesOrigin) {
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host']; // secuirty

  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }

  return header;
};

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js"); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/uri-js/dist/es5/uri.all.js":
/*!*************************************************!*\
  !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
(function (global, factory) {
  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(this, function (exports) {
  'use strict';

  function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
      sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
      sets[0] = sets[0].slice(0, -1);
      var xl = sets.length - 1;

      for (var x = 1; x < xl; ++x) {
        sets[x] = sets[x].slice(1, -1);
      }

      sets[xl] = sets[xl].slice(1);
      return sets.join('');
    } else {
      return sets[0];
    }
  }

  function subexp(str) {
    return "(?:" + str + ")";
  }

  function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
  }

  function toUpperCase(str) {
    return str.toUpperCase();
  }

  function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
  }

  function assign(target, source) {
    var obj = target;

    if (source) {
      for (var key in source) {
        obj[key] = source[key];
      }
    }

    return obj;
  }

  function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        CR$ = "[\\x0D]",
        DIGIT$$ = "[0-9]",
        DQUOTE$$ = "[\\x22]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        //case-insensitive
    LF$$ = "[\\x0A]",
        SP$$ = "[\\x20]",
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$),
        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"),
        USERINFO$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*"),
        DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$),
        DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+"),
        //RFC 6874
    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$),
        //RFC 6874
    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + ZONEID$),
        //RFC 6874, with relaxed parsing rules
    IPVFUTURE$ = subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+"),
        IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"),
        //RFC 6874
    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*"),
        HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")" + "|" + REG_NAME$),
        PORT$ = subexp(DIGIT$$ + "*"),
        AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"),
        PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]")),
        SEGMENT$ = subexp(PCHAR$ + "*"),
        SEGMENT_NZ$ = subexp(PCHAR$ + "+"),
        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+"),
        PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"),
        PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"),
        //simplified
    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),
        //simplified
    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),
        //simplified
    PATH_EMPTY$ = "(?!" + PCHAR$ + ")",
        PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"),
        FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"),
        HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$),
        URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$),
        RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"),
        URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$),
        ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"),
        GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$",
        SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$",
        AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
    return {
      NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
      NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
      NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
      ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
      UNRESERVED: new RegExp(UNRESERVED$$, "g"),
      OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
      PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
      IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
      IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules

    };
  }

  var URI_PROTOCOL = buildExps(false);
  var IRI_PROTOCOL = buildExps(true);

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var toConsumableArray = function toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    } else {
      return Array.from(arr);
    }
  };
  /** Highest positive signed 32-bit float value */


  var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */

  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128; // 0x80

  var delimiter = '-'; // '\x2D'

  /** Regular expressions */

  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars

  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

  /** Error messages */

  var errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  };
  /** Convenience shortcuts */

  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error$1(type) {
    throw new RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var result = [];
    var length = array.length;

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [];
    var counter = 0;
    var length = string.length;

    while (counter < length) {
      var value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // It's a high surrogate, and there is a next character.
        var extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // Low surrogate.
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // It's an unmatched surrogate; only append this code unit, in case the
          // next code unit is the high surrogate of a surrogate pair.
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  var ucs2encode = function ucs2encode(array) {
    return String.fromCodePoint.apply(String, toConsumableArray(array));
  };
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  var basicToDigit = function basicToDigit(codePoint) {
    if (codePoint - 0x30 < 0x0A) {
      return codePoint - 0x16;
    }

    if (codePoint - 0x41 < 0x1A) {
      return codePoint - 0x41;
    }

    if (codePoint - 0x61 < 0x1A) {
      return codePoint - 0x61;
    }

    return base;
  };
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  var digitToBasic = function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  var adapt = function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (;
    /* no initialization */
    delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  var decode = function decode(input) {
    // Don't use UCS-2.
    var output = [];
    var inputLength = input.length;
    var i = 0;
    var n = initialN;
    var bias = initialBias; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    var basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (var j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error$1('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;)
    /* no final expression */
    {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      var oldi = i;

      for (var w = 1, k = base;;
      /* no condition */
      k += base) {
        if (index >= inputLength) {
          error$1('invalid-input');
        }

        var digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error$1('overflow');
        }

        i += digit * w;
        var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        var baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error$1('overflow');
        }

        w *= baseMinusT;
      }

      var out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error$1('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output.

      output.splice(i++, 0, n);
    }

    return String.fromCodePoint.apply(String, output);
  };
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  var encode = function encode(input) {
    var output = []; // Convert the input in UCS-2 to an array of Unicode code points.

    input = ucs2decode(input); // Cache the length.

    var inputLength = input.length; // Initialize the state.

    var n = initialN;
    var delta = 0;
    var bias = initialBias; // Handle the basic code points.

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _currentValue2 = _step.value;

        if (_currentValue2 < 0x80) {
          output.push(stringFromCharCode(_currentValue2));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var basicLength = output.length;
    var handledCPCount = basicLength; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string with a delimiter unless it's empty.

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      var m = maxInt;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var currentValue = _step2.value;

          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        // but guard against overflow.

      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error$1('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var _currentValue = _step3.value;

          if (_currentValue < n && ++delta > maxInt) {
            error$1('overflow');
          }

          if (_currentValue == n) {
            // Represent delta as a generalized variable-length integer.
            var q = delta;

            for (var k = base;;
            /* no condition */
            k += base) {
              var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

              if (q < t) {
                break;
              }

              var qMinusT = q - t;
              var baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }

            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  };
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  var toUnicode = function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  };
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  var toASCII = function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  };
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  var punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '2.1.0',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /**
   * URI.js
   *
   * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/uri-js
   */

  /**
   * Copyright 2011 Gary Court. All rights reserved.
   *
   * Redistribution and use in source and binary forms, with or without modification, are
   * permitted provided that the following conditions are met:
   *
   *    1. Redistributions of source code must retain the above copyright notice, this list of
   *       conditions and the following disclaimer.
   *
   *    2. Redistributions in binary form must reproduce the above copyright notice, this list
   *       of conditions and the following disclaimer in the documentation and/or other materials
   *       provided with the distribution.
   *
   * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
   * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
   * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
   * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
   * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *
   * The views and conclusions contained in the software and documentation are those of the
   * authors and should not be interpreted as representing official policies, either expressed
   * or implied, of Gary Court.
   */

  var SCHEMES = {};

  function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
  }

  function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;

    while (i < il) {
      var c = parseInt(str.substr(i + 1, 2), 16);

      if (c < 128) {
        newStr += String.fromCharCode(c);
        i += 3;
      } else if (c >= 194 && c < 224) {
        if (il - i >= 6) {
          var c2 = parseInt(str.substr(i + 4, 2), 16);
          newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
        } else {
          newStr += str.substr(i, 6);
        }

        i += 6;
      } else if (c >= 224) {
        if (il - i >= 9) {
          var _c = parseInt(str.substr(i + 4, 2), 16);

          var c3 = parseInt(str.substr(i + 7, 2), 16);
          newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
        } else {
          newStr += str.substr(i, 9);
        }

        i += 9;
      } else {
        newStr += str.substr(i, 3);
        i += 3;
      }
    }

    return newStr;
  }

  function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }

    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
  }

  function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
  }

  function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
      return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
      return host;
    }
  }

  function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
      var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
          _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
          last = _address$toLowerCase$2[0],
          first = _address$toLowerCase$2[1];

      var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
      var lastFields = last.split(":").map(_stripLeadingZeros);
      var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
      var fieldCount = isLastFieldIPv4Address ? 7 : 8;
      var lastFieldsStart = lastFields.length - fieldCount;
      var fields = Array(fieldCount);

      for (var x = 0; x < fieldCount; ++x) {
        fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
      }

      if (isLastFieldIPv4Address) {
        fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
      }

      var allZeroFields = fields.reduce(function (acc, field, index) {
        if (!field || field === "0") {
          var lastLongest = acc[acc.length - 1];

          if (lastLongest && lastLongest.index + lastLongest.length === index) {
            lastLongest.length++;
          } else {
            acc.push({
              index: index,
              length: 1
            });
          }
        }

        return acc;
      }, []);
      var longestZeroFields = allZeroFields.sort(function (a, b) {
        return b.length - a.length;
      })[0];
      var newHost = void 0;

      if (longestZeroFields && longestZeroFields.length > 1) {
        var newFirst = fields.slice(0, longestZeroFields.index);
        var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
        newHost = newFirst.join(":") + "::" + newLast.join(":");
      } else {
        newHost = fields.join(":");
      }

      if (zone) {
        newHost += "%" + zone;
      }

      return newHost;
    } else {
      return host;
    }
  }

  var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
  var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;

  function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);

    if (matches) {
      if (NO_MATCH_IS_UNDEFINED) {
        //store each component
        components.scheme = matches[1];
        components.userinfo = matches[3];
        components.host = matches[4];
        components.port = parseInt(matches[5], 10);
        components.path = matches[6] || "";
        components.query = matches[7];
        components.fragment = matches[8]; //fix port number

        if (isNaN(components.port)) {
          components.port = matches[5];
        }
      } else {
        //IE FIX for improper RegExp matching
        //store each component
        components.scheme = matches[1] || undefined;
        components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
        components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
        components.port = parseInt(matches[5], 10);
        components.path = matches[6] || "";
        components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
        components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined; //fix port number

        if (isNaN(components.port)) {
          components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
        }
      }

      if (components.host) {
        //normalize IP hosts
        components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
      } //determine reference type


      if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
        components.reference = "same-document";
      } else if (components.scheme === undefined) {
        components.reference = "relative";
      } else if (components.fragment === undefined) {
        components.reference = "absolute";
      } else {
        components.reference = "uri";
      } //check for reference errors


      if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
        components.error = components.error || "URI is not a " + options.reference + " reference.";
      } //find scheme handler


      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()]; //check if scheme can't handle IRIs

      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        //if host component is a domain name
        if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
          //convert Unicode IDN -> ASCII IDN
          try {
            components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
          }
        } //convert IRI -> URI


        _normalizeComponentEncoding(components, URI_PROTOCOL);
      } else {
        //normalize encodings
        _normalizeComponentEncoding(components, protocol);
      } //perform scheme specific parsing


      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(components, options);
      }
    } else {
      components.error = components.error || "URI can not be parsed.";
    }

    return components;
  }

  function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];

    if (components.userinfo !== undefined) {
      uriTokens.push(components.userinfo);
      uriTokens.push("@");
    }

    if (components.host !== undefined) {
      //normalize IP hosts, add brackets and escape zone separator for IPv6
      uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
        return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
      }));
    }

    if (typeof components.port === "number") {
      uriTokens.push(":");
      uriTokens.push(components.port.toString(10));
    }

    return uriTokens.length ? uriTokens.join("") : undefined;
  }

  var RDS1 = /^\.\.?\//;
  var RDS2 = /^\/\.(\/|$)/;
  var RDS3 = /^\/\.\.(\/|$)/;
  var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;

  function removeDotSegments(input) {
    var output = [];

    while (input.length) {
      if (input.match(RDS1)) {
        input = input.replace(RDS1, "");
      } else if (input.match(RDS2)) {
        input = input.replace(RDS2, "/");
      } else if (input.match(RDS3)) {
        input = input.replace(RDS3, "/");
        output.pop();
      } else if (input === "." || input === "..") {
        input = "";
      } else {
        var im = input.match(RDS5);

        if (im) {
          var s = im[0];
          input = input.slice(s.length);
          output.push(s);
        } else {
          throw new Error("Unexpected dot segment condition");
        }
      }
    }

    return output.join("");
  }

  function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = []; //find scheme handler

    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()]; //perform scheme specific serialization

    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);

    if (components.host) {
      //if host component is an IPv6 address
      if (protocol.IPV6ADDRESS.test(components.host)) {} //TODO: normalize IPv6 address as per RFC 5952
      //if host component is a domain name
      else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          //convert IDN via punycode
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
    } //normalize encoding


    _normalizeComponentEncoding(components, protocol);

    if (options.reference !== "suffix" && components.scheme) {
      uriTokens.push(components.scheme);
      uriTokens.push(":");
    }

    var authority = _recomposeAuthority(components, options);

    if (authority !== undefined) {
      if (options.reference !== "suffix") {
        uriTokens.push("//");
      }

      uriTokens.push(authority);

      if (components.path && components.path.charAt(0) !== "/") {
        uriTokens.push("/");
      }
    }

    if (components.path !== undefined) {
      var s = components.path;

      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s = removeDotSegments(s);
      }

      if (authority === undefined) {
        s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
      }

      uriTokens.push(s);
    }

    if (components.query !== undefined) {
      uriTokens.push("?");
      uriTokens.push(components.query);
    }

    if (components.fragment !== undefined) {
      uriTokens.push("#");
      uriTokens.push(components.fragment);
    }

    return uriTokens.join(""); //merge tokens into a string
  }

  function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];
    var target = {};

    if (!skipNormalization) {
      base = parse(serialize(base, options), options); //normalize base components

      relative = parse(serialize(relative, options), options); //normalize relative components
    }

    options = options || {};

    if (!options.tolerant && relative.scheme) {
      target.scheme = relative.scheme; //target.authority = relative.authority;

      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (!relative.path) {
          target.path = base.path;

          if (relative.query !== undefined) {
            target.query = relative.query;
          } else {
            target.query = base.query;
          }
        } else {
          if (relative.path.charAt(0) === "/") {
            target.path = removeDotSegments(relative.path);
          } else {
            if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
              target.path = "/" + relative.path;
            } else if (!base.path) {
              target.path = relative.path;
            } else {
              target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
            }

            target.path = removeDotSegments(target.path);
          }

          target.query = relative.query;
        } //target.authority = base.authority;


        target.userinfo = base.userinfo;
        target.host = base.host;
        target.port = base.port;
      }

      target.scheme = base.scheme;
    }

    target.fragment = relative.fragment;
    return target;
  }

  function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({
      scheme: 'null'
    }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
  }

  function normalize(uri, options) {
    if (typeof uri === "string") {
      uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
      uri = parse(serialize(uri, options), options);
    }

    return uri;
  }

  function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
      uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
      uriA = serialize(uriA, options);
    }

    if (typeof uriB === "string") {
      uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
      uriB = serialize(uriB, options);
    }

    return uriA === uriB;
  }

  function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
  }

  function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
  }

  var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
      //report missing host
      if (!components.host) {
        components.error = components.error || "HTTP URIs must have a host.";
      }

      return components;
    },
    serialize: function serialize(components, options) {
      //normalize the default port
      if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
        components.port = undefined;
      } //normalize the empty path


      if (!components.path) {
        components.path = "/";
      } //NOTE: We do not parse query strings for HTTP URIs
      //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
      //and not the HTTP spec.


      return components;
    }
  };
  var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
  };
  var O = {};
  var isIRI = true; //RFC 3986

  var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
  var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive

  var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
  //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
  //const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
  //const WSP$$ = "[\\x20\\x09]";
  //const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
  //const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
  //const VCHAR$$ = "[\\x21-\\x7E]";
  //const WSP$$ = "[\\x20\\x09]";
  //const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
  //const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
  //const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
  //const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');

  var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
  var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
  var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
  var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
  var UNRESERVED = new RegExp(UNRESERVED$$, "g");
  var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
  var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
  var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
  var NOT_HFVALUE = NOT_HFNAME;

  function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
  }

  var handler$2 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
      var mailtoComponents = components;
      var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
      mailtoComponents.path = undefined;

      if (mailtoComponents.query) {
        var unknownHeaders = false;
        var headers = {};
        var hfields = mailtoComponents.query.split("&");

        for (var x = 0, xl = hfields.length; x < xl; ++x) {
          var hfield = hfields[x].split("=");

          switch (hfield[0]) {
            case "to":
              var toAddrs = hfield[1].split(",");

              for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                to.push(toAddrs[_x]);
              }

              break;

            case "subject":
              mailtoComponents.subject = unescapeComponent(hfield[1], options);
              break;

            case "body":
              mailtoComponents.body = unescapeComponent(hfield[1], options);
              break;

            default:
              unknownHeaders = true;
              headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
              break;
          }
        }

        if (unknownHeaders) mailtoComponents.headers = headers;
      }

      mailtoComponents.query = undefined;

      for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
        var addr = to[_x2].split("@");

        addr[0] = unescapeComponent(addr[0]);

        if (!options.unicodeSupport) {
          //convert Unicode IDN -> ASCII IDN
          try {
            addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
          } catch (e) {
            mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
          }
        } else {
          addr[1] = unescapeComponent(addr[1], options).toLowerCase();
        }

        to[_x2] = addr.join("@");
      }

      return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
      var components = mailtoComponents;
      var to = toArray(mailtoComponents.to);

      if (to) {
        for (var x = 0, xl = to.length; x < xl; ++x) {
          var toAddr = String(to[x]);
          var atIdx = toAddr.lastIndexOf("@");
          var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
          var domain = toAddr.slice(atIdx + 1); //convert IDN via punycode

          try {
            domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
          } catch (e) {
            components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }

          to[x] = localPart + "@" + domain;
        }

        components.path = to.join(",");
      }

      var headers = mailtoComponents.headers = mailtoComponents.headers || {};
      if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
      if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
      var fields = [];

      for (var name in headers) {
        if (headers[name] !== O[name]) {
          fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
        }
      }

      if (fields.length) {
        components.query = fields.join("&");
      }

      return components;
    }
  };
  var URN_PARSE = /^([^\:]+)\:(.*)/; //RFC 2141

  var handler$3 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
      var matches = components.path && components.path.match(URN_PARSE);
      var urnComponents = components;

      if (matches) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = matches[1].toLowerCase();
        var nss = matches[2];
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        urnComponents.nid = nid;
        urnComponents.nss = nss;
        urnComponents.path = undefined;

        if (schemeHandler) {
          urnComponents = schemeHandler.parse(urnComponents, options);
        }
      } else {
        urnComponents.error = urnComponents.error || "URN can not be parsed.";
      }

      return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
      var scheme = options.scheme || urnComponents.scheme || "urn";
      var nid = urnComponents.nid;
      var urnScheme = scheme + ":" + (options.nid || nid);
      var schemeHandler = SCHEMES[urnScheme];

      if (schemeHandler) {
        urnComponents = schemeHandler.serialize(urnComponents, options);
      }

      var uriComponents = urnComponents;
      var nss = urnComponents.nss;
      uriComponents.path = (nid || options.nid) + ":" + nss;
      return uriComponents;
    }
  };
  var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/; //RFC 4122

  var handler$4 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
      var uuidComponents = urnComponents;
      uuidComponents.uuid = uuidComponents.nss;
      uuidComponents.nss = undefined;

      if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
        uuidComponents.error = uuidComponents.error || "UUID is not valid.";
      }

      return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
      var urnComponents = uuidComponents; //normalize UUID

      urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
      return urnComponents;
    }
  };
  SCHEMES[handler.scheme] = handler;
  SCHEMES[handler$1.scheme] = handler$1;
  SCHEMES[handler$2.scheme] = handler$2;
  SCHEMES[handler$3.scheme] = handler$3;
  SCHEMES[handler$4.scheme] = handler$4;
  exports.SCHEMES = SCHEMES;
  exports.pctEncChar = pctEncChar;
  exports.pctDecChars = pctDecChars;
  exports.parse = parse;
  exports.removeDotSegments = removeDotSegments;
  exports.serialize = serialize;
  exports.resolveComponents = resolveComponents;
  exports.resolve = resolve;
  exports.normalize = normalize;
  exports.equal = equal;
  exports.escapeComponent = escapeComponent;
  exports.unescapeComponent = unescapeComponent;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Kc29uUmVmcy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvY29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2Rmcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLWFsbC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvZmluZC1jeWNsZXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9mbG95ZC13YXJzaGFsbC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvaXMtYWN5Y2xpYy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3Bvc3RvcmRlci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3ByZW9yZGVyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvcHJpbS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3Rhcmphbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3RvcHNvcnQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2RhdGEvcHJpb3JpdHktcXVldWUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2dyYXBoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvanNvbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvbG9kYXNoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi92ZXJzaW9uLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19IYXNoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTGlzdENhY2hlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19Qcm9taXNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUVhY2guanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UmVkdWNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTb21lLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNjaWlTaXplLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NvY0luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbkluLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnblZhbHVlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNsb25lLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VFYWNoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbHRlci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3IuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yT3duLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRBbGxLZXlzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzSW4uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc0VxdWFsLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWFwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTWF0Y2guanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYU4uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNTZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUl0ZXJhdGVlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hcC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1hdGNoZXNQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VQcm9wZXJ0eURlZXAuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVkdWNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVGltZXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5hcnkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5pcS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nhc3RQYXRoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lQnVmZmVyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVEYXRhVmlldy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVR5cGVkQXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5T2JqZWN0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weVN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29yZUpzRGF0YS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZUJhc2VFYWNoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVNldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2RlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxBcnJheXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZXF1YWxPYmplY3RzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZnJlZUdsb2JhbC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRNYXBEYXRhLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TmF0aXZlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UHJvdG90eXBlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9scy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFZhbHVlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzUGF0aC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1VuaWNvZGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoRGVsZXRlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hIYXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoU2V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVCeVRhZy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0luZGV4LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNLZXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc01hc2tlZC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzUHJvdG90eXBlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVEZWxldGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVTZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBUb0FycmF5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tZW1vaXplQ2FwcGVkLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlQ3JlYXRlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25hdGl2ZUtleXNJbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX25vZGVVdGlsLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyQXJnLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlclJlc3QuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NldFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaWN0SW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmluZ1NpemUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b0tleS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3RvU291cmNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdW5pY29kZVNpemUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2Nsb25lLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZWFjaC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZXEuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZm9yRWFjaC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZ2V0LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2hhc0luLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRW1wdHkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTGVuZ3RoLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc01hcC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTZXQuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3RyaW5nLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1VuZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9sb2Rhc2guanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21hcC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbWVtb2l6ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm9vcC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3JlZHVjZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc2l6ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc3R1YkFycmF5LmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViRmFsc2UuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvU3RyaW5nLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3VuaW9uLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC92YWx1ZXMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvbmF0aXZlLXByb21pc2Utb25seS9saWIvbnBvLnNyYy5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9wYXRoLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvcGF0aC1sb2FkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvcGF0aC1sb2FkZXIvbGliL2xvYWRlcnMvZmlsZS1icm93c2VyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL3BhdGgtbG9hZGVyL2xpYi9sb2FkZXJzL2h0dHAuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9zbGFzaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9hZ2VudC1iYXNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi9pcy1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvcmVxdWVzdC1iYXNlLmpzIiwid2VicGFjazovL0pzb25SZWZzLy4vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3Jlc3BvbnNlLWJhc2UuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi8uLi9zcmMvdXRpbC50cyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi8uLi9zcmMvcmVnZXhwcy11cmkudHMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vLi4vc3JjL3JlZ2V4cHMtaXJpLnRzIiwid2VicGFjazovL0pzb25SZWZzLy4uLy4uL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5lczYuanMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vLi4vc3JjL3VyaS50cyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi8uLi9zcmMvc2NoZW1lcy9odHRwLnRzIiwid2VicGFjazovL0pzb25SZWZzLy4uLy4uL3NyYy9zY2hlbWVzL2h0dHBzLnRzIiwid2VicGFjazovL0pzb25SZWZzLy4uLy4uL3NyYy9zY2hlbWVzL21haWx0by50cyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8uLi8uLi9zcmMvc2NoZW1lcy91cm4udHMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vLi4vc3JjL3NjaGVtZXMvdXJuLXV1aWQudHMiLCJ3ZWJwYWNrOi8vSnNvblJlZnMvLi4vLi4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL0pzb25SZWZzLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIiwid2VicGFjazovL0pzb25SZWZzLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9Kc29uUmVmcy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiXSwibmFtZXMiOlsiYmFkUHRyVG9rZW5SZWdleCIsInJlbW90ZUNhY2hlIiwicmVtb3RlVHlwZXMiLCJyZW1vdGVVcmlUeXBlcyIsInVyaURldGFpbHNDYWNoZSIsImNvbWJpbmVRdWVyeVBhcmFtcyIsInFzMSIsInFzMiIsImNvbWJpbmVkIiwibWVyZ2VRdWVyeVBhcmFtcyIsIm9iaiIsIl8iLCJmb3JPd24iLCJ2YWwiLCJrZXkiLCJxcyIsInBhcnNlIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInN0cmluZ2lmeSIsImNvbWJpbmVVUklzIiwidTEiLCJ1MiIsImlzU3RyaW5nIiwic2xhc2giLCJ1MkRldGFpbHMiLCJwYXJzZVVSSSIsImlzVW5kZWZpbmVkIiwidTFEZXRhaWxzIiwiY29tYmluZWREZXRhaWxzIiwiaW5kZXhPZiIsInJlZmVyZW5jZSIsInBhdGgiLCJqb2luIiwicXVlcnkiLCJmcmFnbWVudCIsIlVSSSIsInNlcmlhbGl6ZSIsImZpbmRBbmNlc3RvcnMiLCJhbmNlc3RvcnMiLCJub2RlIiwic2xpY2UiLCJmb3JFYWNoIiwic2VnIiwicHVzaCIsImlzUmVtb3RlIiwicmVmRGV0YWlscyIsImdldFJlZlR5cGUiLCJpc1ZhbGlkIiwiZXJyb3IiLCJ0eXBlIiwiZmluZFZhbHVlIiwidmFsdWUiLCJFcnJvciIsIl9wYXRoVG9QdHIiLCJnZXRFeHRyYVJlZktleXMiLCJyZWYiLCJmaWx0ZXIiLCJ1cmlEZXRhaWxzIiwiZ2V0UmVtb3RlRG9jdW1lbnQiLCJ1cmwiLCJvcHRpb25zIiwiY2FjaGVFbnRyeSIsImFsbFRhc2tzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJsb2FkZXJPcHRpb25zIiwiY2xvbmVEZWVwIiwicHJvY2Vzc0NvbnRlbnQiLCJyZXMiLCJjYWxsYmFjayIsIkpTT04iLCJ0ZXh0IiwiUGF0aExvYWRlciIsImxvYWQiLCJkZWNvZGVVUkkiLCJ0aGVuIiwiY2F0Y2giLCJlcnIiLCJpc0Vycm9yIiwiaXNSZWZMaWtlIiwidGhyb3dXaXRoRGV0YWlscyIsInJlZkxpa2UiLCJpc1BsYWluT2JqZWN0IiwiJHJlZiIsIm1ha2VBYnNvbHV0ZSIsImxvY2F0aW9uIiwiaXNBYnNvbHV0ZSIsInByb2Nlc3MiLCJjd2QiLCJtYWtlUmVmRmlsdGVyIiwicmVmRmlsdGVyIiwidmFsaWRUeXBlcyIsImlzQXJyYXkiLCJpc0Z1bmN0aW9uIiwiaW5jbHVkZUludmFsaWQiLCJtYWtlU3ViRG9jUGF0aCIsInN1YkRvY1BhdGgiLCJfcGF0aEZyb21QdHIiLCJtYXJrTWlzc2luZyIsIm1lc3NhZ2UiLCJtaXNzaW5nIiwidXJpIiwiYnVpbGRSZWZNb2RlbCIsImRvY3VtZW50IiwibWV0YWRhdGEiLCJzdWJEb2NQdHIiLCJhYnNMb2NhdGlvbiIsInJlbGF0aXZlQmFzZSIsImRpcm5hbWUiLCJkb2NEZXBLZXkiLCJyZWZzIiwick9wdGlvbnMiLCJkb2NzIiwiZGVwcyIsIl9maW5kUmVmcyIsInJlZlB0ciIsInJlZktleSIsInJlZmRLZXkiLCJyZWZkSWQiLCJzcGxpdCIsImZxVVJJIiwicmVwbGFjZSIsImNpcmN1bGFyIiwibk1ldGFkYXRhIiwibk9wdGlvbnMiLCJyQWJzTG9jYXRpb24iLCJyRG9jIiwiblJlZkRldGFpbHMiLCJkb2MiLCJzZXRWYWx1ZSIsInJlZlBhdGgiLCJ3YWxrIiwiZm4iLCJwcm9jZXNzQ2hpbGRyZW4iLCJ3YWxrSXRlbSIsIml0ZW0iLCJzZWdtZW50IiwicG9wIiwibWVtYmVyIiwiaW5kZXgiLCJ0b1N0cmluZyIsImlzT2JqZWN0IiwiY05vZGUiLCJ2YWxpZGF0ZU9wdGlvbnMiLCJsb2NhdGlvblBhcnRzIiwic2hvdWxkRGVjb2RlIiwiVHlwZUVycm9yIiwicmVzb2x2ZUNpcmN1bGFycyIsImlzQm9vbGVhbiIsInJlZlByZVByb2Nlc3NvciIsInJlZlBvc3RQcm9jZXNzb3IiLCJfaXNQdHIiLCJfZGVjb2RlUGF0aCIsIm1hcCIsIl9lbmNvZGVQYXRoIiwiX2dldFJlZkRldGFpbHMiLCJfZmluZFJlZnNBdCIsImNPcHRpb25zIiwiZGV0YWlscyIsImRlZiIsImNhY2hlS2V5IiwiZXh0cmFLZXlzIiwid2FybmluZyIsInB0ciIsInZhbGlkIiwiZmlyc3RDaGFyIiwiY2hhckF0IiwibWF0Y2giLCJfaXNSZWYiLCJzZWdtZW50cyIsInNoaWZ0IiwiaGFzaFByZWZpeCIsIl9yZXNvbHZlUmVmcyIsInJlc3VsdHMiLCJhbGxSZWZzIiwiY2lyY3VsYXJQYXRocyIsImNpcmN1bGFycyIsImRlcEdyYXBoIiwiZ2wiLCJHcmFwaCIsImZ1bGxMb2NhdGlvbiIsInJlZnNSb290Iiwic2V0Tm9kZSIsInByb3BzIiwiZGVwIiwic2V0RWRnZSIsImFsZyIsImZpbmRDeWNsZXMiLCJwcm9wIiwiaXNDaXJjdWxhciIsInJlbW90ZSIsInBhdGhJbmRleCIsInJldmVyc2UiLCJwYXJlbnRQdHIiLCJwUHRyUGFydHMiLCJwRG9jdW1lbnQiLCJwUHRyUGF0aCIsImRlcFBhcnRzIiwiZERvY3VtZW50IiwiZFB0clBhdGgiLCJjb25jYXQiLCJ3YWxrUmVmcyIsInJvb3QiLCJyZWZQdHJQYXJ0cyIsInJlZkRlcHMiLCJzdWJzdHIiLCJmcVVSSVNlZ21lbnRzIiwidXJpU2VnbWVudHMiLCJ0aW1lcyIsInRpbWUiLCJuU2VnIiwiZnFTZWdJbmRleCIsImZxU2VnIiwicmVzb2x2ZWQiLCJfcmVzb2x2ZVJlZnNBdCIsInJlczIiLCJjbGVhckNhY2hlIiwiZGVjb2RlUGF0aCIsImVuY29kZVBhdGgiLCJmaW5kUmVmcyIsImZpbmRSZWZzQXQiLCJnZXRSZWZEZXRhaWxzIiwiaXNQdHIiLCJpc1JlZiIsInBhdGhGcm9tUHRyIiwicGF0aFRvUHRyIiwicmVzb2x2ZVJlZnMiLCJyZXNvbHZlUmVmc0F0IiwibW9kdWxlIiwiZXhwb3J0cyIsIkVtaXR0ZXIiLCJtaXhpbiIsInByb3RvdHlwZSIsIm9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiX2NhbGxiYWNrcyIsIm9uY2UiLCJvZmYiLCJhcHBseSIsImFyZ3VtZW50cyIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbGxiYWNrcyIsImNiIiwiaSIsInNwbGljZSIsImVtaXQiLCJhcmdzIiwiY2FsbCIsImxlbiIsImxpc3RlbmVycyIsImhhc0xpc3RlbmVycyIsImxpYiIsInJlcXVpcmUiLCJqc29uIiwidmVyc2lvbiIsImNvbXBvbmVudHMiLCJnIiwidmlzaXRlZCIsImNtcHRzIiwiY21wdCIsImRmcyIsInYiLCJoYXMiLCJlYWNoIiwic3VjY2Vzc29ycyIsInByZWRlY2Vzc29ycyIsIm5vZGVzIiwidnMiLCJvcmRlciIsIm5hdmlnYXRpb24iLCJpc0RpcmVjdGVkIiwibmVpZ2hib3JzIiwiYmluZCIsImFjYyIsImhhc05vZGUiLCJkb0RmcyIsInBvc3RvcmRlciIsInciLCJkaWprc3RyYSIsImRpamtzdHJhQWxsIiwid2VpZ2h0RnVuYyIsImVkZ2VGdW5jIiwidHJhbnNmb3JtIiwiUHJpb3JpdHlRdWV1ZSIsIkRFRkFVTFRfV0VJR0hUX0ZVTkMiLCJjb25zdGFudCIsInNvdXJjZSIsIndlaWdodEZuIiwiZWRnZUZuIiwicnVuRGlqa3N0cmEiLCJTdHJpbmciLCJvdXRFZGdlcyIsInBxIiwidkVudHJ5IiwidXBkYXRlTmVpZ2hib3JzIiwiZWRnZSIsIndFbnRyeSIsIndlaWdodCIsImRpc3RhbmNlIiwicHJlZGVjZXNzb3IiLCJkZWNyZWFzZSIsIk51bWJlciIsIlBPU0lUSVZFX0lORklOSVRZIiwiYWRkIiwic2l6ZSIsInJlbW92ZU1pbiIsInRhcmphbiIsImhhc0VkZ2UiLCJmbG95ZFdhcnNoYWxsIiwicnVuRmxveWRXYXJzaGFsbCIsImQiLCJrIiwicm93SyIsInJvd0kiLCJqIiwiaWsiLCJraiIsImlqIiwiYWx0RGlzdGFuY2UiLCJpc0FjeWNsaWMiLCJwcmVvcmRlciIsInByaW0iLCJ0b3Bzb3J0IiwiZSIsIkN5Y2xlRXhjZXB0aW9uIiwicmVzdWx0IiwicGFyZW50cyIsInByaSIsInByaW9yaXR5IiwiZWRnZVdlaWdodCIsIm5vZGVDb3VudCIsImluaXQiLCJub2RlRWRnZXMiLCJzdGFjayIsImVudHJ5Iiwib25TdGFjayIsImxvd2xpbmsiLCJNYXRoIiwibWluIiwidmlzaXQiLCJzaW5rcyIsIl9hcnIiLCJfa2V5SW5kaWNlcyIsIngiLCJrZXlJbmRpY2VzIiwiYXJyIiwiX2RlY3JlYXNlIiwiX3N3YXAiLCJfaGVhcGlmeSIsImwiLCJyIiwibGFyZ2VzdCIsInBhcmVudCIsIm9yaWdBcnJJIiwib3JpZ0FyckoiLCJERUZBVUxUX0VER0VfTkFNRSIsIkdSQVBIX05PREUiLCJFREdFX0tFWV9ERUxJTSIsIm9wdHMiLCJfaXNEaXJlY3RlZCIsImRpcmVjdGVkIiwiX2lzTXVsdGlncmFwaCIsIm11bHRpZ3JhcGgiLCJfaXNDb21wb3VuZCIsImNvbXBvdW5kIiwiX2xhYmVsIiwiX2RlZmF1bHROb2RlTGFiZWxGbiIsIl9kZWZhdWx0RWRnZUxhYmVsRm4iLCJfbm9kZXMiLCJfcGFyZW50IiwiX2NoaWxkcmVuIiwiX2luIiwiX3ByZWRzIiwiX291dCIsIl9zdWNzIiwiX2VkZ2VPYmpzIiwiX2VkZ2VMYWJlbHMiLCJfbm9kZUNvdW50IiwiX2VkZ2VDb3VudCIsImlzTXVsdGlncmFwaCIsImlzQ29tcG91bmQiLCJzZXRHcmFwaCIsImxhYmVsIiwiZ3JhcGgiLCJzZXREZWZhdWx0Tm9kZUxhYmVsIiwibmV3RGVmYXVsdCIsInNvdXJjZXMiLCJzZWxmIiwiaXNFbXB0eSIsInNldE5vZGVzIiwicmVtb3ZlTm9kZSIsInJlbW92ZUVkZ2UiLCJfcmVtb3ZlRnJvbVBhcmVudHNDaGlsZExpc3QiLCJjaGlsZHJlbiIsImNoaWxkIiwic2V0UGFyZW50IiwiYW5jZXN0b3IiLCJwcmVkc1YiLCJzdWNzViIsInByZWRzIiwidW5pb24iLCJpc0xlYWYiLCJmaWx0ZXJOb2RlcyIsImNvcHkiLCJjb25zdHJ1Y3RvciIsImZpbmRQYXJlbnQiLCJzZXREZWZhdWx0RWRnZUxhYmVsIiwiZWRnZUNvdW50IiwiZWRnZXMiLCJ2YWx1ZXMiLCJzZXRQYXRoIiwicmVkdWNlIiwibmFtZSIsInZhbHVlU3BlY2lmaWVkIiwiYXJnMCIsImVkZ2VBcmdzVG9JZCIsImVkZ2VPYmoiLCJlZGdlQXJnc1RvT2JqIiwiZnJlZXplIiwiaW5jcmVtZW50T3JJbml0RW50cnkiLCJlZGdlT2JqVG9JZCIsImRlY3JlbWVudE9yUmVtb3ZlRW50cnkiLCJpbkVkZ2VzIiwidSIsImluViIsIm91dFYiLCJ2XyIsIndfIiwidG1wIiwid3JpdGUiLCJyZWFkIiwid3JpdGVOb2RlcyIsIndyaXRlRWRnZXMiLCJjbG9uZSIsIm5vZGVWYWx1ZSIsImVkZ2VWYWx1ZSIsImxvZGFzaCIsIndpbmRvdyIsImdldE5hdGl2ZSIsIkRhdGFWaWV3IiwiaGFzaENsZWFyIiwiaGFzaERlbGV0ZSIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsIkhhc2giLCJlbnRyaWVzIiwiY2xlYXIiLCJzZXQiLCJnZXQiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIkxpc3RDYWNoZSIsIk1hcCIsIm1hcENhY2hlQ2xlYXIiLCJtYXBDYWNoZURlbGV0ZSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsIk1hcENhY2hlIiwiU2V0Iiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlNldENhY2hlIiwiX19kYXRhX18iLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJTdGFjayIsImRhdGEiLCJTeW1ib2wiLCJVaW50OEFycmF5IiwiV2Vha01hcCIsImZ1bmMiLCJ0aGlzQXJnIiwiYXJyYXlFYWNoIiwiYXJyYXkiLCJpdGVyYXRlZSIsImFycmF5RmlsdGVyIiwicHJlZGljYXRlIiwicmVzSW5kZXgiLCJiYXNlSW5kZXhPZiIsImFycmF5SW5jbHVkZXMiLCJhcnJheUluY2x1ZGVzV2l0aCIsImNvbXBhcmF0b3IiLCJiYXNlVGltZXMiLCJpc0FyZ3VtZW50cyIsImlzQnVmZmVyIiwiaXNJbmRleCIsImlzVHlwZWRBcnJheSIsIm9iamVjdFByb3RvIiwiaGFzT3duUHJvcGVydHkiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcnIiLCJpc0FyZyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiYXJyYXlNYXAiLCJBcnJheSIsImFycmF5UHVzaCIsIm9mZnNldCIsImFycmF5UmVkdWNlIiwiYWNjdW11bGF0b3IiLCJpbml0QWNjdW0iLCJhcnJheVNvbWUiLCJiYXNlUHJvcGVydHkiLCJhc2NpaVNpemUiLCJiYXNlQXNzaWduVmFsdWUiLCJlcSIsImFzc2lnblZhbHVlIiwib2JqZWN0Iiwib2JqVmFsdWUiLCJhc3NvY0luZGV4T2YiLCJjb3B5T2JqZWN0IiwiYmFzZUFzc2lnbiIsImtleXNJbiIsImJhc2VBc3NpZ25JbiIsImRlZmluZVByb3BlcnR5IiwiY2xvbmVCdWZmZXIiLCJjb3B5QXJyYXkiLCJjb3B5U3ltYm9scyIsImNvcHlTeW1ib2xzSW4iLCJnZXRBbGxLZXlzIiwiZ2V0QWxsS2V5c0luIiwiZ2V0VGFnIiwiaW5pdENsb25lQXJyYXkiLCJpbml0Q2xvbmVCeVRhZyIsImluaXRDbG9uZU9iamVjdCIsImlzTWFwIiwiaXNTZXQiLCJDTE9ORV9ERUVQX0ZMQUciLCJDTE9ORV9GTEFUX0ZMQUciLCJDTE9ORV9TWU1CT0xTX0ZMQUciLCJhcmdzVGFnIiwiYXJyYXlUYWciLCJib29sVGFnIiwiZGF0ZVRhZyIsImVycm9yVGFnIiwiZnVuY1RhZyIsImdlblRhZyIsIm1hcFRhZyIsIm51bWJlclRhZyIsIm9iamVjdFRhZyIsInJlZ2V4cFRhZyIsInNldFRhZyIsInN0cmluZ1RhZyIsInN5bWJvbFRhZyIsIndlYWtNYXBUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwiY2xvbmVhYmxlVGFncyIsImJhc2VDbG9uZSIsImJpdG1hc2siLCJjdXN0b21pemVyIiwiaXNEZWVwIiwiaXNGbGF0IiwiaXNGdWxsIiwidGFnIiwiaXNGdW5jIiwic3RhY2tlZCIsInN1YlZhbHVlIiwia2V5c0Z1bmMiLCJvYmplY3RDcmVhdGUiLCJjcmVhdGUiLCJiYXNlQ3JlYXRlIiwicHJvdG8iLCJiYXNlRm9yT3duIiwiY3JlYXRlQmFzZUVhY2giLCJiYXNlRWFjaCIsImJhc2VGaWx0ZXIiLCJjb2xsZWN0aW9uIiwiYmFzZUZpbmRJbmRleCIsImZyb21JbmRleCIsImZyb21SaWdodCIsImlzRmxhdHRlbmFibGUiLCJiYXNlRmxhdHRlbiIsImRlcHRoIiwiaXNTdHJpY3QiLCJjcmVhdGVCYXNlRm9yIiwiYmFzZUZvciIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0IiwiYmFzZUdldEFsbEtleXMiLCJzeW1ib2xzRnVuYyIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwibnVsbFRhZyIsInVuZGVmaW5lZFRhZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJiYXNlR2V0VGFnIiwiYmFzZUhhcyIsImJhc2VIYXNJbiIsImJhc2VJc05hTiIsInN0cmljdEluZGV4T2YiLCJpc09iamVjdExpa2UiLCJiYXNlSXNBcmd1bWVudHMiLCJiYXNlSXNFcXVhbERlZXAiLCJiYXNlSXNFcXVhbCIsIm90aGVyIiwiZXF1YWxBcnJheXMiLCJlcXVhbEJ5VGFnIiwiZXF1YWxPYmplY3RzIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJlcXVhbEZ1bmMiLCJvYmpJc0FyciIsIm90aElzQXJyIiwib2JqVGFnIiwib3RoVGFnIiwib2JqSXNPYmoiLCJvdGhJc09iaiIsImlzU2FtZVRhZyIsIm9iaklzV3JhcHBlZCIsIm90aElzV3JhcHBlZCIsIm9ialVud3JhcHBlZCIsIm90aFVud3JhcHBlZCIsImJhc2VJc01hcCIsIkNPTVBBUkVfVU5PUkRFUkVEX0ZMQUciLCJiYXNlSXNNYXRjaCIsIm1hdGNoRGF0YSIsIm5vQ3VzdG9taXplciIsInNyY1ZhbHVlIiwiaXNNYXNrZWQiLCJ0b1NvdXJjZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsImZ1bmNQcm90byIsIkZ1bmN0aW9uIiwiZnVuY1RvU3RyaW5nIiwicmVJc05hdGl2ZSIsIlJlZ0V4cCIsImJhc2VJc05hdGl2ZSIsInBhdHRlcm4iLCJ0ZXN0IiwiYmFzZUlzU2V0IiwiaXNMZW5ndGgiLCJ0eXBlZEFycmF5VGFncyIsImJhc2VJc1R5cGVkQXJyYXkiLCJiYXNlTWF0Y2hlcyIsImJhc2VNYXRjaGVzUHJvcGVydHkiLCJpZGVudGl0eSIsInByb3BlcnR5IiwiYmFzZUl0ZXJhdGVlIiwiaXNQcm90b3R5cGUiLCJuYXRpdmVLZXlzIiwiYmFzZUtleXMiLCJuYXRpdmVLZXlzSW4iLCJiYXNlS2V5c0luIiwiaXNQcm90byIsImlzQXJyYXlMaWtlIiwiYmFzZU1hcCIsImdldE1hdGNoRGF0YSIsIm1hdGNoZXNTdHJpY3RDb21wYXJhYmxlIiwiaGFzSW4iLCJpc0tleSIsImlzU3RyaWN0Q29tcGFyYWJsZSIsImJhc2VQcm9wZXJ0eURlZXAiLCJiYXNlUmVkdWNlIiwiZWFjaEZ1bmMiLCJvdmVyUmVzdCIsInNldFRvU3RyaW5nIiwiYmFzZVJlc3QiLCJzdGFydCIsImJhc2VTZXRUb1N0cmluZyIsInN0cmluZyIsIm4iLCJpc1N5bWJvbCIsIklORklOSVRZIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xUb1N0cmluZyIsImJhc2VUb1N0cmluZyIsImJhc2VVbmFyeSIsImNhY2hlSGFzIiwiY3JlYXRlU2V0Iiwic2V0VG9BcnJheSIsIkxBUkdFX0FSUkFZX1NJWkUiLCJiYXNlVW5pcSIsImluY2x1ZGVzIiwiaXNDb21tb24iLCJzZWVuIiwib3V0ZXIiLCJjb21wdXRlZCIsInNlZW5JbmRleCIsImJhc2VWYWx1ZXMiLCJjYWNoZSIsImNhc3RGdW5jdGlvbiIsInN0cmluZ1RvUGF0aCIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImJ1ZmZlciIsImNsb25lRGF0YVZpZXciLCJkYXRhVmlldyIsImJ5dGVPZmZzZXQiLCJyZUZsYWdzIiwiY2xvbmVSZWdFeHAiLCJyZWdleHAiLCJleGVjIiwibGFzdEluZGV4Iiwic3ltYm9sVmFsdWVPZiIsInZhbHVlT2YiLCJjbG9uZVN5bWJvbCIsInN5bWJvbCIsImNsb25lVHlwZWRBcnJheSIsInR5cGVkQXJyYXkiLCJpc05ldyIsIm5ld1ZhbHVlIiwiZ2V0U3ltYm9scyIsImdldFN5bWJvbHNJbiIsImNvcmVKc0RhdGEiLCJpdGVyYWJsZSIsIm5vb3AiLCJpc1BhcnRpYWwiLCJhcnJMZW5ndGgiLCJvdGhMZW5ndGgiLCJhcnJWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJvdGhJbmRleCIsIm1hcFRvQXJyYXkiLCJjb252ZXJ0Iiwib2JqUHJvcHMiLCJvYmpMZW5ndGgiLCJvdGhQcm9wcyIsInNraXBDdG9yIiwib2JqQ3RvciIsIm90aEN0b3IiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiaXNLZXlhYmxlIiwiZ2V0TWFwRGF0YSIsImdldFZhbHVlIiwib3ZlckFyZyIsImdldFByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJpc093biIsInVubWFza2VkIiwic3R1YkFycmF5IiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJuYXRpdmVHZXRTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvbWlzZVRhZyIsImRhdGFWaWV3Q3RvclN0cmluZyIsIm1hcEN0b3JTdHJpbmciLCJwcm9taXNlQ3RvclN0cmluZyIsInNldEN0b3JTdHJpbmciLCJ3ZWFrTWFwQ3RvclN0cmluZyIsIkFycmF5QnVmZmVyIiwiQ3RvciIsImN0b3JTdHJpbmciLCJoYXNQYXRoIiwiaGFzRnVuYyIsInJzQXN0cmFsUmFuZ2UiLCJyc0NvbWJvTWFya3NSYW5nZSIsInJlQ29tYm9IYWxmTWFya3NSYW5nZSIsInJzQ29tYm9TeW1ib2xzUmFuZ2UiLCJyc0NvbWJvUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNaV0oiLCJyZUhhc1VuaWNvZGUiLCJoYXNVbmljb2RlIiwibmF0aXZlQ3JlYXRlIiwiSEFTSF9VTkRFRklORUQiLCJpbnB1dCIsInNwcmVhZGFibGVTeW1ib2wiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmVJc1VpbnQiLCJyZUlzRGVlcFByb3AiLCJyZUlzUGxhaW5Qcm9wIiwibWFza1NyY0tleSIsInVpZCIsIklFX1BST1RPIiwiYXJyYXlQcm90byIsIm1lbW9pemUiLCJNQVhfTUVNT0laRV9TSVpFIiwibWVtb2l6ZUNhcHBlZCIsImZyZWVQcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsImJpbmRpbmciLCJhcmciLCJuYXRpdmVNYXgiLCJtYXgiLCJvdGhlckFyZ3MiLCJmcmVlU2VsZiIsInNob3J0T3V0IiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJuYXRpdmVOb3ciLCJEYXRlIiwibm93IiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJwYWlycyIsInVuaWNvZGVTaXplIiwic3RyaW5nU2l6ZSIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJjaGFyQ29kZUF0IiwibnVtYmVyIiwicXVvdGUiLCJzdWJTdHJpbmciLCJyc0FzdHJhbCIsInJzQ29tYm8iLCJyc0ZpdHoiLCJyc01vZGlmaWVyIiwicnNOb25Bc3RyYWwiLCJyc1JlZ2lvbmFsIiwicnNTdXJyUGFpciIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJyc1NlcSIsInJzU3ltYm9sIiwicmVVbmljb2RlIiwiZGVmYXVsdFZhbHVlIiwiaXNBcnJheUxpa2VPYmplY3QiLCJzdHViRmFsc2UiLCJuYXRpdmVJc0J1ZmZlciIsImFzeW5jVGFnIiwicHJveHlUYWciLCJub2RlSXNNYXAiLCJub2RlSXNTZXQiLCJub2RlSXNUeXBlZEFycmF5IiwiVkVSU0lPTiIsIkNPUkVfRVJST1JfVEVYVCIsIkZVTkNfRVJST1JfVEVYVCIsIlBMQUNFSE9MREVSIiwiV1JBUF9CSU5EX0ZMQUciLCJXUkFQX0JJTkRfS0VZX0ZMQUciLCJXUkFQX0NVUlJZX0JPVU5EX0ZMQUciLCJXUkFQX0NVUlJZX0ZMQUciLCJXUkFQX0NVUlJZX1JJR0hUX0ZMQUciLCJXUkFQX1BBUlRJQUxfRkxBRyIsIldSQVBfUEFSVElBTF9SSUdIVF9GTEFHIiwiV1JBUF9BUllfRkxBRyIsIldSQVBfUkVBUkdfRkxBRyIsIldSQVBfRkxJUF9GTEFHIiwiREVGQVVMVF9UUlVOQ19MRU5HVEgiLCJERUZBVUxUX1RSVU5DX09NSVNTSU9OIiwiTEFaWV9GSUxURVJfRkxBRyIsIkxBWllfTUFQX0ZMQUciLCJMQVpZX1dISUxFX0ZMQUciLCJNQVhfSU5URUdFUiIsIk5BTiIsIk1BWF9BUlJBWV9MRU5HVEgiLCJNQVhfQVJSQVlfSU5ERVgiLCJIQUxGX01BWF9BUlJBWV9MRU5HVEgiLCJ3cmFwRmxhZ3MiLCJkb21FeGNUYWciLCJ3ZWFrU2V0VGFnIiwicmVFbXB0eVN0cmluZ0xlYWRpbmciLCJyZUVtcHR5U3RyaW5nTWlkZGxlIiwicmVFbXB0eVN0cmluZ1RyYWlsaW5nIiwicmVFc2NhcGVkSHRtbCIsInJlVW5lc2NhcGVkSHRtbCIsInJlSGFzRXNjYXBlZEh0bWwiLCJyZUhhc1VuZXNjYXBlZEh0bWwiLCJyZUVzY2FwZSIsInJlRXZhbHVhdGUiLCJyZUludGVycG9sYXRlIiwicmVIYXNSZWdFeHBDaGFyIiwicmVUcmltIiwicmVUcmltU3RhcnQiLCJyZVRyaW1FbmQiLCJyZVdyYXBDb21tZW50IiwicmVXcmFwRGV0YWlscyIsInJlU3BsaXREZXRhaWxzIiwicmVBc2NpaVdvcmQiLCJyZUVzVGVtcGxhdGUiLCJyZUlzQmFkSGV4IiwicmVJc0JpbmFyeSIsInJlSXNPY3RhbCIsInJlTGF0aW4iLCJyZU5vTWF0Y2giLCJyZVVuZXNjYXBlZFN0cmluZyIsInJzRGluZ2JhdFJhbmdlIiwicnNMb3dlclJhbmdlIiwicnNNYXRoT3BSYW5nZSIsInJzTm9uQ2hhclJhbmdlIiwicnNQdW5jdHVhdGlvblJhbmdlIiwicnNTcGFjZVJhbmdlIiwicnNVcHBlclJhbmdlIiwicnNCcmVha1JhbmdlIiwicnNBcG9zIiwicnNCcmVhayIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzVXBwZXIiLCJyc01pc2NMb3dlciIsInJzTWlzY1VwcGVyIiwicnNPcHRDb250ckxvd2VyIiwicnNPcHRDb250clVwcGVyIiwicnNPcmRMb3dlciIsInJzT3JkVXBwZXIiLCJyc0Vtb2ppIiwicmVBcG9zIiwicmVDb21ib01hcmsiLCJyZVVuaWNvZGVXb3JkIiwicmVIYXNVbmljb2RlV29yZCIsImNvbnRleHRQcm9wcyIsInRlbXBsYXRlQ291bnRlciIsImRlYnVycmVkTGV0dGVycyIsImh0bWxFc2NhcGVzIiwiaHRtbFVuZXNjYXBlcyIsInN0cmluZ0VzY2FwZXMiLCJmcmVlUGFyc2VGbG9hdCIsInBhcnNlRmxvYXQiLCJmcmVlUGFyc2VJbnQiLCJwYXJzZUludCIsIm5vZGVJc0FycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlciIsIm5vZGVJc0RhdGUiLCJpc0RhdGUiLCJub2RlSXNSZWdFeHAiLCJpc1JlZ0V4cCIsImFycmF5QWdncmVnYXRvciIsInNldHRlciIsImFycmF5RWFjaFJpZ2h0IiwiYXJyYXlFdmVyeSIsImFycmF5UmVkdWNlUmlnaHQiLCJhc2NpaVRvQXJyYXkiLCJhc2NpaVdvcmRzIiwiYmFzZUZpbmRLZXkiLCJiYXNlSW5kZXhPZldpdGgiLCJiYXNlTWVhbiIsImJhc2VTdW0iLCJiYXNlUHJvcGVydHlPZiIsImJhc2VTb3J0QnkiLCJjb21wYXJlciIsInNvcnQiLCJjdXJyZW50IiwiYmFzZVRvUGFpcnMiLCJjaGFyc1N0YXJ0SW5kZXgiLCJzdHJTeW1ib2xzIiwiY2hyU3ltYm9scyIsImNoYXJzRW5kSW5kZXgiLCJjb3VudEhvbGRlcnMiLCJwbGFjZWhvbGRlciIsImRlYnVyckxldHRlciIsImVzY2FwZUh0bWxDaGFyIiwiZXNjYXBlU3RyaW5nQ2hhciIsImNociIsImhhc1VuaWNvZGVXb3JkIiwiaXRlcmF0b3JUb0FycmF5IiwiaXRlcmF0b3IiLCJuZXh0IiwiZG9uZSIsInJlcGxhY2VIb2xkZXJzIiwic2V0VG9QYWlycyIsInN0cmljdExhc3RJbmRleE9mIiwic3RyaW5nVG9BcnJheSIsInVuaWNvZGVUb0FycmF5IiwidW5lc2NhcGVIdG1sQ2hhciIsInVuaWNvZGVXb3JkcyIsInJ1bkluQ29udGV4dCIsImNvbnRleHQiLCJkZWZhdWx0cyIsInBpY2siLCJpZENvdW50ZXIiLCJvYmplY3RDdG9yU3RyaW5nIiwib2xkRGFzaCIsInN5bUl0ZXJhdG9yIiwiY3R4Q2xlYXJUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY3R4Tm93IiwiY3R4U2V0VGltZW91dCIsInNldFRpbWVvdXQiLCJuYXRpdmVDZWlsIiwiY2VpbCIsIm5hdGl2ZUZsb29yIiwiZmxvb3IiLCJuYXRpdmVJc0Zpbml0ZSIsImlzRmluaXRlIiwibmF0aXZlSm9pbiIsIm5hdGl2ZU1pbiIsIm5hdGl2ZVBhcnNlSW50IiwibmF0aXZlUmFuZG9tIiwicmFuZG9tIiwibmF0aXZlUmV2ZXJzZSIsIm1ldGFNYXAiLCJyZWFsTmFtZXMiLCJMYXp5V3JhcHBlciIsIkxvZGFzaFdyYXBwZXIiLCJ3cmFwcGVyQ2xvbmUiLCJiYXNlTG9kYXNoIiwiY2hhaW5BbGwiLCJfX3dyYXBwZWRfXyIsIl9fYWN0aW9uc19fIiwiX19jaGFpbl9fIiwiX19pbmRleF9fIiwiX192YWx1ZXNfXyIsInRlbXBsYXRlU2V0dGluZ3MiLCJfX2Rpcl9fIiwiX19maWx0ZXJlZF9fIiwiX19pdGVyYXRlZXNfXyIsIl9fdGFrZUNvdW50X18iLCJfX3ZpZXdzX18iLCJsYXp5Q2xvbmUiLCJsYXp5UmV2ZXJzZSIsImxhenlWYWx1ZSIsImRpciIsImlzUmlnaHQiLCJ2aWV3IiwiZ2V0VmlldyIsImVuZCIsIml0ZXJhdGVlcyIsIml0ZXJMZW5ndGgiLCJ0YWtlQ291bnQiLCJiYXNlV3JhcHBlclZhbHVlIiwiaXRlckluZGV4IiwiYXJyYXlTYW1wbGUiLCJiYXNlUmFuZG9tIiwiYXJyYXlTYW1wbGVTaXplIiwic2h1ZmZsZVNlbGYiLCJiYXNlQ2xhbXAiLCJhcnJheVNodWZmbGUiLCJhc3NpZ25NZXJnZVZhbHVlIiwiYmFzZUFnZ3JlZ2F0b3IiLCJiYXNlQXQiLCJwYXRocyIsInNraXAiLCJsb3dlciIsInVwcGVyIiwiYmFzZUNvbmZvcm1zIiwiYmFzZUNvbmZvcm1zVG8iLCJiYXNlRGVsYXkiLCJ3YWl0IiwiYmFzZURpZmZlcmVuY2UiLCJ2YWx1ZXNMZW5ndGgiLCJ2YWx1ZXNJbmRleCIsImJhc2VFYWNoUmlnaHQiLCJiYXNlRm9yT3duUmlnaHQiLCJiYXNlRXZlcnkiLCJiYXNlRXh0cmVtdW0iLCJiYXNlRmlsbCIsInRvSW50ZWdlciIsInRvTGVuZ3RoIiwiYmFzZUZvclJpZ2h0IiwiYmFzZUZ1bmN0aW9ucyIsImJhc2VHdCIsImJhc2VJblJhbmdlIiwiYmFzZUludGVyc2VjdGlvbiIsImFycmF5cyIsImNhY2hlcyIsIm1heExlbmd0aCIsIkluZmluaXR5IiwiYmFzZUludmVydGVyIiwiYmFzZUludm9rZSIsImxhc3QiLCJiYXNlSXNBcnJheUJ1ZmZlciIsImJhc2VJc0RhdGUiLCJiYXNlSXNSZWdFeHAiLCJiYXNlTHQiLCJiYXNlTWVyZ2UiLCJzcmNJbmRleCIsImJhc2VNZXJnZURlZXAiLCJzYWZlR2V0IiwibWVyZ2VGdW5jIiwiaXNUeXBlZCIsInRvUGxhaW5PYmplY3QiLCJiYXNlTnRoIiwiYmFzZU9yZGVyQnkiLCJvcmRlcnMiLCJnZXRJdGVyYXRlZSIsImNyaXRlcmlhIiwiY29tcGFyZU11bHRpcGxlIiwiYmFzZVBpY2siLCJiYXNlUGlja0J5IiwiYmFzZVNldCIsImJhc2VQdWxsQWxsIiwiYmFzZVB1bGxBdCIsImluZGV4ZXMiLCJwcmV2aW91cyIsImJhc2VVbnNldCIsImJhc2VSYW5nZSIsInN0ZXAiLCJiYXNlUmVwZWF0IiwiYmFzZVNhbXBsZSIsImJhc2VTYW1wbGVTaXplIiwibmVzdGVkIiwiYmFzZVNldERhdGEiLCJiYXNlU2h1ZmZsZSIsImJhc2VTbGljZSIsImJhc2VTb21lIiwiYmFzZVNvcnRlZEluZGV4IiwicmV0SGlnaGVzdCIsImxvdyIsImhpZ2giLCJtaWQiLCJiYXNlU29ydGVkSW5kZXhCeSIsInZhbElzTmFOIiwidmFsSXNOdWxsIiwidmFsSXNTeW1ib2wiLCJ2YWxJc1VuZGVmaW5lZCIsIm90aElzRGVmaW5lZCIsIm90aElzTnVsbCIsIm90aElzUmVmbGV4aXZlIiwib3RoSXNTeW1ib2wiLCJzZXRMb3ciLCJiYXNlU29ydGVkVW5pcSIsImJhc2VUb051bWJlciIsImJhc2VVcGRhdGUiLCJ1cGRhdGVyIiwiYmFzZVdoaWxlIiwiaXNEcm9wIiwiYWN0aW9ucyIsImFjdGlvbiIsImJhc2VYb3IiLCJiYXNlWmlwT2JqZWN0IiwiYXNzaWduRnVuYyIsInZhbHNMZW5ndGgiLCJjYXN0QXJyYXlMaWtlT2JqZWN0IiwiY2FzdFJlc3QiLCJjYXN0U2xpY2UiLCJpZCIsImNvbXBhcmVBc2NlbmRpbmciLCJ2YWxJc0RlZmluZWQiLCJ2YWxJc1JlZmxleGl2ZSIsIm9iakNyaXRlcmlhIiwib3RoQ3JpdGVyaWEiLCJvcmRlcnNMZW5ndGgiLCJjb21wb3NlQXJncyIsInBhcnRpYWxzIiwiaG9sZGVycyIsImlzQ3VycmllZCIsImFyZ3NJbmRleCIsImFyZ3NMZW5ndGgiLCJob2xkZXJzTGVuZ3RoIiwibGVmdEluZGV4IiwibGVmdExlbmd0aCIsInJhbmdlTGVuZ3RoIiwiaXNVbmN1cnJpZWQiLCJjb21wb3NlQXJnc1JpZ2h0IiwiaG9sZGVyc0luZGV4IiwicmlnaHRJbmRleCIsInJpZ2h0TGVuZ3RoIiwiY3JlYXRlQWdncmVnYXRvciIsImluaXRpYWxpemVyIiwiY3JlYXRlQXNzaWduZXIiLCJhc3NpZ25lciIsImd1YXJkIiwiaXNJdGVyYXRlZUNhbGwiLCJjcmVhdGVCaW5kIiwiaXNCaW5kIiwiY3JlYXRlQ3RvciIsIndyYXBwZXIiLCJjcmVhdGVDYXNlRmlyc3QiLCJtZXRob2ROYW1lIiwidHJhaWxpbmciLCJjcmVhdGVDb21wb3VuZGVyIiwid29yZHMiLCJkZWJ1cnIiLCJ0aGlzQmluZGluZyIsImNyZWF0ZUN1cnJ5IiwiYXJpdHkiLCJnZXRIb2xkZXIiLCJjcmVhdGVSZWN1cnJ5IiwiY3JlYXRlSHlicmlkIiwiY3JlYXRlRmluZCIsImZpbmRJbmRleEZ1bmMiLCJjcmVhdGVGbG93IiwiZmxhdFJlc3QiLCJmdW5jcyIsInByZXJlcSIsInRocnUiLCJnZXRGdW5jTmFtZSIsImZ1bmNOYW1lIiwiZ2V0RGF0YSIsImlzTGF6aWFibGUiLCJwbGFudCIsInBhcnRpYWxzUmlnaHQiLCJob2xkZXJzUmlnaHQiLCJhcmdQb3MiLCJhcnkiLCJpc0FyeSIsImlzQmluZEtleSIsImlzRmxpcCIsImhvbGRlcnNDb3VudCIsIm5ld0hvbGRlcnMiLCJyZW9yZGVyIiwiY3JlYXRlSW52ZXJ0ZXIiLCJ0b0l0ZXJhdGVlIiwiY3JlYXRlTWF0aE9wZXJhdGlvbiIsIm9wZXJhdG9yIiwiY3JlYXRlT3ZlciIsImFycmF5RnVuYyIsImNyZWF0ZVBhZGRpbmciLCJjaGFycyIsImNoYXJzTGVuZ3RoIiwiY3JlYXRlUGFydGlhbCIsImNyZWF0ZVJhbmdlIiwidG9GaW5pdGUiLCJjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uIiwidG9OdW1iZXIiLCJ3cmFwRnVuYyIsImlzQ3VycnkiLCJuZXdIb2xkZXJzUmlnaHQiLCJuZXdQYXJ0aWFscyIsIm5ld1BhcnRpYWxzUmlnaHQiLCJuZXdEYXRhIiwic2V0RGF0YSIsInNldFdyYXBUb1N0cmluZyIsImNyZWF0ZVJvdW5kIiwicHJlY2lzaW9uIiwicGFpciIsImNyZWF0ZVRvUGFpcnMiLCJjcmVhdGVXcmFwIiwibWVyZ2VEYXRhIiwiY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiIsImN1c3RvbURlZmF1bHRzTWVyZ2UiLCJjdXN0b21PbWl0Q2xvbmUiLCJmbGF0dGVuIiwib3RoZXJGdW5jIiwidHJhbnNmb3JtcyIsImdldFdyYXBEZXRhaWxzIiwiaW5zZXJ0V3JhcERldGFpbHMiLCJpc01hc2thYmxlIiwic3JjQml0bWFzayIsIm5ld0JpdG1hc2siLCJpc0NvbWJvIiwib2xkQXJyYXkiLCJ1cGRhdGVXcmFwRGV0YWlscyIsInJhbmQiLCJjaHVuayIsImNvbXBhY3QiLCJkaWZmZXJlbmNlIiwiZGlmZmVyZW5jZUJ5IiwiZGlmZmVyZW5jZVdpdGgiLCJkcm9wIiwiZHJvcFJpZ2h0IiwiZHJvcFJpZ2h0V2hpbGUiLCJkcm9wV2hpbGUiLCJmaWxsIiwiZmluZEluZGV4IiwiZmluZExhc3RJbmRleCIsImZsYXR0ZW5EZWVwIiwiZmxhdHRlbkRlcHRoIiwiZnJvbVBhaXJzIiwiaGVhZCIsImluaXRpYWwiLCJpbnRlcnNlY3Rpb24iLCJtYXBwZWQiLCJpbnRlcnNlY3Rpb25CeSIsImludGVyc2VjdGlvbldpdGgiLCJzZXBhcmF0b3IiLCJsYXN0SW5kZXhPZiIsIm50aCIsInB1bGwiLCJwdWxsQWxsIiwicHVsbEFsbEJ5IiwicHVsbEFsbFdpdGgiLCJwdWxsQXQiLCJyZW1vdmUiLCJzb3J0ZWRJbmRleCIsInNvcnRlZEluZGV4QnkiLCJzb3J0ZWRJbmRleE9mIiwic29ydGVkTGFzdEluZGV4Iiwic29ydGVkTGFzdEluZGV4QnkiLCJzb3J0ZWRMYXN0SW5kZXhPZiIsInNvcnRlZFVuaXEiLCJzb3J0ZWRVbmlxQnkiLCJ0YWlsIiwidGFrZSIsInRha2VSaWdodCIsInRha2VSaWdodFdoaWxlIiwidGFrZVdoaWxlIiwidW5pb25CeSIsInVuaW9uV2l0aCIsInVuaXEiLCJ1bmlxQnkiLCJ1bmlxV2l0aCIsInVuemlwIiwiZ3JvdXAiLCJ1bnppcFdpdGgiLCJ3aXRob3V0IiwieG9yIiwieG9yQnkiLCJ4b3JXaXRoIiwiemlwIiwiemlwT2JqZWN0IiwiemlwT2JqZWN0RGVlcCIsInppcFdpdGgiLCJjaGFpbiIsInRhcCIsImludGVyY2VwdG9yIiwid3JhcHBlckF0Iiwid3JhcHBlckNoYWluIiwid3JhcHBlckNvbW1pdCIsIndyYXBwZXJOZXh0IiwidG9BcnJheSIsIndyYXBwZXJUb0l0ZXJhdG9yIiwid3JhcHBlclBsYW50Iiwid3JhcHBlclJldmVyc2UiLCJ3cmFwcGVkIiwid3JhcHBlclZhbHVlIiwiY291bnRCeSIsImV2ZXJ5IiwiZmluZCIsImZpbmRMYXN0IiwiZmxhdE1hcCIsImZsYXRNYXBEZWVwIiwiZmxhdE1hcERlcHRoIiwiZm9yRWFjaFJpZ2h0IiwiZ3JvdXBCeSIsImludm9rZU1hcCIsImtleUJ5Iiwib3JkZXJCeSIsInBhcnRpdGlvbiIsInJlZHVjZVJpZ2h0IiwicmVqZWN0IiwibmVnYXRlIiwic2FtcGxlIiwic2FtcGxlU2l6ZSIsInNodWZmbGUiLCJzb21lIiwic29ydEJ5IiwiYWZ0ZXIiLCJiZWZvcmUiLCJiaW5kS2V5IiwiY3VycnkiLCJjdXJyeVJpZ2h0IiwiZGVib3VuY2UiLCJsYXN0QXJncyIsImxhc3RUaGlzIiwibWF4V2FpdCIsInRpbWVySWQiLCJsYXN0Q2FsbFRpbWUiLCJsYXN0SW52b2tlVGltZSIsImxlYWRpbmciLCJtYXhpbmciLCJpbnZva2VGdW5jIiwibGVhZGluZ0VkZ2UiLCJ0aW1lckV4cGlyZWQiLCJyZW1haW5pbmdXYWl0IiwidGltZVNpbmNlTGFzdENhbGwiLCJ0aW1lU2luY2VMYXN0SW52b2tlIiwidGltZVdhaXRpbmciLCJzaG91bGRJbnZva2UiLCJ0cmFpbGluZ0VkZ2UiLCJjYW5jZWwiLCJmbHVzaCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJkZWZlciIsImRlbGF5IiwiZmxpcCIsInJlc29sdmVyIiwibWVtb2l6ZWQiLCJDYWNoZSIsIm92ZXJBcmdzIiwiZnVuY3NMZW5ndGgiLCJwYXJ0aWFsIiwicGFydGlhbFJpZ2h0IiwicmVhcmciLCJyZXN0Iiwic3ByZWFkIiwidGhyb3R0bGUiLCJ1bmFyeSIsIndyYXAiLCJjYXN0QXJyYXkiLCJjbG9uZVdpdGgiLCJjbG9uZURlZXBXaXRoIiwiY29uZm9ybXNUbyIsImd0IiwiZ3RlIiwiaXNFbGVtZW50IiwiaXNFcXVhbCIsImlzRXF1YWxXaXRoIiwiaXNJbnRlZ2VyIiwiaXNNYXRjaCIsImlzTWF0Y2hXaXRoIiwiaXNOYU4iLCJpc051bWJlciIsImlzTmF0aXZlIiwiaXNOdWxsIiwiaXNOaWwiLCJpc1NhZmVJbnRlZ2VyIiwiaXNXZWFrTWFwIiwiaXNXZWFrU2V0IiwibHQiLCJsdGUiLCJzaWduIiwicmVtYWluZGVyIiwiaXNCaW5hcnkiLCJ0b1NhZmVJbnRlZ2VyIiwiYXNzaWduIiwiYXNzaWduSW4iLCJhc3NpZ25JbldpdGgiLCJhc3NpZ25XaXRoIiwiYXQiLCJwcm9wZXJ0aWVzIiwicHJvcHNJbmRleCIsInByb3BzTGVuZ3RoIiwiZGVmYXVsdHNEZWVwIiwibWVyZ2VXaXRoIiwiZmluZEtleSIsImZpbmRMYXN0S2V5IiwiZm9ySW4iLCJmb3JJblJpZ2h0IiwiZm9yT3duUmlnaHQiLCJmdW5jdGlvbnMiLCJmdW5jdGlvbnNJbiIsImludmVydCIsImludmVydEJ5IiwiaW52b2tlIiwibWFwS2V5cyIsIm1hcFZhbHVlcyIsIm1lcmdlIiwib21pdCIsIm9taXRCeSIsInBpY2tCeSIsInNldFdpdGgiLCJ0b1BhaXJzIiwidG9QYWlyc0luIiwiaXNBcnJMaWtlIiwidW5zZXQiLCJ1cGRhdGUiLCJ1cGRhdGVXaXRoIiwidmFsdWVzSW4iLCJjbGFtcCIsImluUmFuZ2UiLCJmbG9hdGluZyIsInRlbXAiLCJjYW1lbENhc2UiLCJ3b3JkIiwidG9Mb3dlckNhc2UiLCJjYXBpdGFsaXplIiwidXBwZXJGaXJzdCIsImVuZHNXaXRoIiwidGFyZ2V0IiwicG9zaXRpb24iLCJlc2NhcGUiLCJlc2NhcGVSZWdFeHAiLCJrZWJhYkNhc2UiLCJsb3dlckNhc2UiLCJsb3dlckZpcnN0IiwicGFkIiwic3RyTGVuZ3RoIiwicGFkRW5kIiwicGFkU3RhcnQiLCJyYWRpeCIsInJlcGVhdCIsInNuYWtlQ2FzZSIsImxpbWl0Iiwic3RhcnRDYXNlIiwic3RhcnRzV2l0aCIsInRlbXBsYXRlIiwic2V0dGluZ3MiLCJpbXBvcnRzIiwiaW1wb3J0c0tleXMiLCJpbXBvcnRzVmFsdWVzIiwiaXNFc2NhcGluZyIsImlzRXZhbHVhdGluZyIsImludGVycG9sYXRlIiwicmVEZWxpbWl0ZXJzIiwiZXZhbHVhdGUiLCJzb3VyY2VVUkwiLCJlc2NhcGVWYWx1ZSIsImludGVycG9sYXRlVmFsdWUiLCJlc1RlbXBsYXRlVmFsdWUiLCJldmFsdWF0ZVZhbHVlIiwidmFyaWFibGUiLCJhdHRlbXB0IiwidG9Mb3dlciIsInRvVXBwZXIiLCJ0b1VwcGVyQ2FzZSIsInRyaW0iLCJ0cmltRW5kIiwidHJpbVN0YXJ0IiwidHJ1bmNhdGUiLCJvbWlzc2lvbiIsInNlYXJjaCIsInN1YnN0cmluZyIsIm5ld0VuZCIsInVuZXNjYXBlIiwidXBwZXJDYXNlIiwiYmluZEFsbCIsIm1ldGhvZE5hbWVzIiwiY29uZCIsImNvbmZvcm1zIiwiZGVmYXVsdFRvIiwiZmxvdyIsImZsb3dSaWdodCIsIm1hdGNoZXMiLCJtYXRjaGVzUHJvcGVydHkiLCJtZXRob2QiLCJtZXRob2RPZiIsIm5vQ29uZmxpY3QiLCJudGhBcmciLCJvdmVyIiwib3ZlckV2ZXJ5Iiwib3ZlclNvbWUiLCJwcm9wZXJ0eU9mIiwicmFuZ2UiLCJyYW5nZVJpZ2h0Iiwic3R1Yk9iamVjdCIsInN0dWJTdHJpbmciLCJzdHViVHJ1ZSIsInRvUGF0aCIsInVuaXF1ZUlkIiwicHJlZml4IiwiYXVnZW5kIiwiYWRkZW5kIiwiZGl2aWRlIiwiZGl2aWRlbmQiLCJkaXZpc29yIiwibWF4QnkiLCJtZWFuIiwibWVhbkJ5IiwibWluQnkiLCJtdWx0aXBseSIsIm11bHRpcGxpZXIiLCJtdWx0aXBsaWNhbmQiLCJyb3VuZCIsInN1YnRyYWN0IiwibWludWVuZCIsInN1YnRyYWhlbmQiLCJzdW0iLCJzdW1CeSIsImVudHJpZXNJbiIsImV4dGVuZCIsImV4dGVuZFdpdGgiLCJlYWNoUmlnaHQiLCJmaXJzdCIsImlzRmlsdGVyIiwidGFrZU5hbWUiLCJkcm9wTmFtZSIsImNoZWNrSXRlcmF0ZWUiLCJpc1Rha2VyIiwibG9kYXNoRnVuYyIsInJldFVud3JhcHBlZCIsImlzTGF6eSIsInVzZUxhenkiLCJpc0h5YnJpZCIsImlzVW53cmFwcGVkIiwib25seUxhenkiLCJjaGFpbk5hbWUiLCJuYW1lcyIsImNvbW1pdCIsInRvSlNPTiIsImRlZmluZSIsIlVNRCIsImRlZmluaXRpb24iLCIkQU1EJCIsIkRFRiIsImJ1aWx0SW5Qcm9wIiwiY3ljbGUiLCJzY2hlZHVsaW5nX3F1ZXVlIiwiVG9TdHJpbmciLCJ0aW1lciIsInNldEltbWVkaWF0ZSIsImNvbmZpZyIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiUXVldWUiLCJJdGVtIiwiZHJhaW4iLCJmIiwic2NoZWR1bGUiLCJpc1RoZW5hYmxlIiwibyIsIl90aGVuIiwib190eXBlIiwibm90aWZ5Iiwibm90aWZ5SXNvbGF0ZWQiLCJzdGF0ZSIsInN1Y2Nlc3MiLCJmYWlsdXJlIiwicmV0IiwibXNnIiwicHJvbWlzZSIsInRyaWdnZXJlZCIsImRlZl93cmFwcGVyIiwiTWFrZURlZldyYXBwZXIiLCIkcmVzb2x2ZSQiLCIkcmVqZWN0JCIsIml0ZXJhdGVQcm9taXNlcyIsIkNvbnN0cnVjdG9yIiwicmVqZWN0ZXIiLCJpZHgiLCJJSUZFIiwiJHJlc29sdmVyJCIsIk1ha2VEZWYiLCJleGVjdXRvciIsIl9fTlBPX18iLCJleHRyYWN0Q2hhaW4iLCIkY2F0Y2gkIiwicHVibGljUmVzb2x2ZSIsInB1YmxpY1JlamVjdCIsIlByb21pc2VQcm90b3R5cGUiLCJQcm9taXNlJHJlc29sdmUiLCJQcm9taXNlJHJlamVjdCIsIlByb21pc2UkYWxsIiwibXNncyIsIlByb21pc2UkcmFjZSIsIm5vcm1hbGl6ZUFycmF5IiwicGFydHMiLCJhbGxvd0Fib3ZlUm9vdCIsInVwIiwidW5zaGlmdCIsInNwbGl0UGF0aFJlIiwic3BsaXRQYXRoIiwiZmlsZW5hbWUiLCJyZXNvbHZlZFBhdGgiLCJyZXNvbHZlZEFic29sdXRlIiwicCIsIm5vcm1hbGl6ZSIsInRyYWlsaW5nU2xhc2giLCJyZWxhdGl2ZSIsImZyb20iLCJ0byIsImZyb21QYXJ0cyIsInRvUGFydHMiLCJzYW1lUGFydHNMZW5ndGgiLCJvdXRwdXRQYXJ0cyIsInNlcCIsImRlbGltaXRlciIsImJhc2VuYW1lIiwiZXh0IiwiZXh0bmFtZSIsInhzIiwic3RyIiwic3VwcG9ydGVkTG9hZGVycyIsImZpbGUiLCJodHRwIiwiaHR0cHMiLCJkZWZhdWx0TG9hZGVyIiwiaW1wb3J0U2NyaXB0cyIsImdldFNjaGVtZSIsImdldExvYWRlciIsInNjaGVtZSIsImxvYWRlciIsInByb2Nlc3NlZCIsInVuc3VwcG9ydGVkRXJyb3IiLCJnZXRCYXNlIiwicmVxdWVzdCIsInN1cHBvcnRlZEh0dHBNZXRob2RzIiwicmVhbE1ldGhvZCIsInJlYWxSZXF1ZXN0IiwibWFrZVJlcXVlc3QiLCJyZXEiLCJlcnIyIiwicHJlcGFyZVJlcXVlc3QiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJydW5UaW1lb3V0IiwiZnVuIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJkcmFpblF1ZXVlIiwidGltZW91dCIsInJ1biIsIm5leHRUaWNrIiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb25zIiwiYWRkTGlzdGVuZXIiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwiY2hkaXIiLCJ1bWFzayIsIm1heEtleXMiLCJrc3RyIiwidnN0ciIsImRlY29kZVVSSUNvbXBvbmVudCIsInN0cmluZ2lmeVByaW1pdGl2ZSIsIm9iamVjdEtleXMiLCJrcyIsImVuY29kZVVSSUNvbXBvbmVudCIsImRlY29kZSIsImVuY29kZSIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwicmVnaXN0ZXJJbW1lZGlhdGUiLCJ0YXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJoYW5kbGUiLCJydW5JZlByZXNlbnQiLCJpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbiIsImNhblVzZVBvc3RNZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzIiwib2xkT25NZXNzYWdlIiwib25tZXNzYWdlIiwiaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24iLCJtZXNzYWdlUHJlZml4Iiwib25HbG9iYWxNZXNzYWdlIiwiYXR0YWNoRXZlbnQiLCJpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNoYW5uZWwiLCJNZXNzYWdlQ2hhbm5lbCIsInBvcnQxIiwicG9ydDIiLCJpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uIiwiaHRtbCIsImRvY3VtZW50RWxlbWVudCIsInNjcmlwdCIsImNyZWF0ZUVsZW1lbnQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwiaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbiIsImF0dGFjaFRvIiwiaXNFeHRlbmRlZExlbmd0aFBhdGgiLCJoYXNOb25Bc2NpaSIsIkFnZW50IiwiX2RlZmF1bHRzIiwiX3NldERlZmF1bHRzIiwiY29uc29sZSIsIndhcm4iLCJSZXF1ZXN0QmFzZSIsIlJlc3BvbnNlQmFzZSIsIlJlcXVlc3QiLCJnZXRYSFIiLCJYTUxIdHRwUmVxdWVzdCIsInByb3RvY29sIiwiQWN0aXZlWE9iamVjdCIsInMiLCJwdXNoRW5jb2RlZEtleVZhbHVlUGFpciIsInN1YmtleSIsInNlcmlhbGl6ZU9iamVjdCIsInBhcnNlU3RyaW5nIiwicG9zIiwieG1sIiwidXJsZW5jb2RlZCIsInBhcnNlSGVhZGVyIiwibGluZXMiLCJmaWVsZHMiLCJsaW5lIiwiZmllbGQiLCJpc0pTT04iLCJtaW1lIiwiUmVzcG9uc2UiLCJ4aHIiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJzdGF0dXNUZXh0Iiwic3RhdHVzIiwiX3NldFN0YXR1c1Byb3BlcnRpZXMiLCJoZWFkZXIiLCJoZWFkZXJzIiwiZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJfc2V0SGVhZGVyUHJvcGVydGllcyIsIl9yZXNwb25zZVR5cGUiLCJib2R5IiwicmVzcG9uc2UiLCJfcGFyc2VCb2R5IiwiX3BhcnNlciIsInRvRXJyb3IiLCJfcXVlcnkiLCJfaGVhZGVyIiwib3JpZ2luYWwiLCJyYXdSZXNwb25zZSIsInN0YXR1c0NvZGUiLCJuZXdfZXJyIiwiX2lzUmVzcG9uc2VPSyIsImN1c3RvbV9lcnIiLCJhY2NlcHQiLCJhdXRoIiwidXNlciIsInBhc3MiLCJidG9hIiwiZW5jb2RlciIsIl9hdXRoIiwiYXR0YWNoIiwiX2RhdGEiLCJfZ2V0Rm9ybURhdGEiLCJhcHBlbmQiLCJfZm9ybURhdGEiLCJGb3JtRGF0YSIsIl9zaG91bGRSZXRyeSIsIl9yZXRyeSIsIl9jYWxsYmFjayIsIl9tYXhSZXRyaWVzIiwicmV0cmllcyIsIl9yZXRyaWVzIiwiY3Jvc3NEb21haW5FcnJvciIsImNyb3NzRG9tYWluIiwiY2EiLCJhZ2VudCIsInBpcGUiLCJfaXNIb3N0IiwiX2VuZENhbGxlZCIsIl9maW5hbGl6ZVF1ZXJ5U3RyaW5nIiwiX2VuZCIsIl9zZXRUaW1lb3V0cyIsInJlYWR5U3RhdGUiLCJfcmVzcG9uc2VUaW1lb3V0VGltZXIiLCJ0aW1lZG91dCIsIl9hYm9ydGVkIiwiaGFuZGxlUHJvZ3Jlc3MiLCJkaXJlY3Rpb24iLCJ0b3RhbCIsInBlcmNlbnQiLCJsb2FkZWQiLCJvbnByb2dyZXNzIiwidXBsb2FkIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIm9wZW4iLCJfd2l0aENyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwiY29udGVudFR5cGUiLCJfc2VyaWFsaXplciIsInNldFJlcXVlc3RIZWFkZXIiLCJzZW5kIiwiZGVsIiwicGF0Y2giLCJwb3N0IiwicHV0IiwiX2NsZWFyVGltZW91dCIsIl90aW1lciIsIl90aW1lb3V0IiwiX3Jlc3BvbnNlVGltZW91dCIsIm9wdGlvbiIsImRlYWRsaW5lIiwicmV0cnkiLCJfcmV0cnlDYWxsYmFjayIsIkVSUk9SX0NPREVTIiwib3ZlcnJpZGUiLCJjb2RlIiwiX2Z1bGxmaWxsZWRQcm9taXNlIiwiaW5uZXJSZXNvbHZlIiwiaW5uZXJSZWplY3QiLCJ1c2UiLCJvayIsIl9va0NhbGxiYWNrIiwiZ2V0SGVhZGVyIiwiYWJvcnQiLCJiYXNlNjRFbmNvZGVyIiwicmVkaXJlY3RzIiwiX21heFJlZGlyZWN0cyIsIm1heFJlc3BvbnNlU2l6ZSIsIl9tYXhSZXNwb25zZVNpemUiLCJpc09iaiIsInNvcnRRdWVyeSIsIl9zb3J0IiwicXVlcnlBcnIiLCJfYXBwZW5kUXVlcnlTdHJpbmciLCJ0cmFjZSIsIl90aW1lb3V0RXJyb3IiLCJyZWFzb24iLCJlcnJubyIsInV0aWxzIiwiY3QiLCJwYXJhbXMiLCJsaW5rcyIsImxpbmsiLCJwYXJzZUxpbmtzIiwic3RhdHVzVHlwZSIsImluZm8iLCJyZWRpcmVjdCIsImNsaWVudEVycm9yIiwic2VydmVyRXJyb3IiLCJjcmVhdGVkIiwiYWNjZXB0ZWQiLCJub0NvbnRlbnQiLCJiYWRSZXF1ZXN0IiwidW5hdXRob3JpemVkIiwibm90QWNjZXB0YWJsZSIsImZvcmJpZGRlbiIsIm5vdEZvdW5kIiwidW5wcm9jZXNzYWJsZUVudGl0eSIsInJlbCIsImNsZWFuSGVhZGVyIiwiY2hhbmdlc09yaWdpbiIsInNjb3BlIiwiVGltZW91dCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImNsb3NlIiwiY2xlYXJGbiIsIl9pZCIsIl9jbGVhckZuIiwidW5yZWYiLCJlbnJvbGwiLCJtc2VjcyIsIl9pZGxlVGltZW91dElkIiwiX2lkbGVUaW1lb3V0IiwidW5lbnJvbGwiLCJfdW5yZWZBY3RpdmUiLCJhY3RpdmUiLCJvblRpbWVvdXQiLCJfb25UaW1lb3V0Iiwic2V0cyIsInhsIiwiQUxQSEEkJCIsIkNSJCIsIkRJR0lUJCQiLCJEUVVPVEUkJCIsIkhFWERJRyQkIiwiU1AkJCIsIlBDVF9FTkNPREVEJCIsInN1YmV4cCIsIlNVQl9ERUxJTVMkJCIsIlJFU0VSVkVEJCQiLCJVQ1NDSEFSJCQiLCJpc0lSSSIsIlNDSEVNRSQiLCJVU0VSSU5GTyQiLCJERUNfT0NURVQkIiwiREVDX09DVEVUX1JFTEFYRUQkIiwiSDE2JCIsIkxTMzIkIiwiSVBWNkFERFJFU1MxJCIsIlpPTkVJRCQiLCJVTlJFU0VSVkVEJCQiLCJJUFY2QUREUkVTUyQiLCJJUF9MSVRFUkFMJCIsIklQVjZBRERSWl9SRUxBWEVEJCIsIkhPU1QkIiwiUE9SVCQiLCJBVVRIT1JJVFkkIiwiUENIQVIkIiwiU0VHTUVOVCQiLCJTRUdNRU5UX05aJCIsIlNFR01FTlRfTlpfTkMkIiwiUEFUSF9BQkVNUFRZJCIsIlBBVEhfQUJTT0xVVEUkIiwiUEFUSCQiLCJRVUVSWSQiLCJGUkFHTUVOVCQiLCJISUVSX1BBUlQkIiwiVVJJJCIsIlJFTEFUSVZFX1BBUlQkIiwiUkVMQVRJVkUkIiwiVVJJX1JFRkVSRU5DRSQiLCJBQlNPTFVURV9VUkkkIiwiR0VORVJJQ19SRUYkIiwiUkVMQVRJVkVfUkVGJCIsIkFCU09MVVRFX1JFRiQiLCJTQU1FRE9DX1JFRiQiLCJBVVRIT1JJVFlfUkVGJCIsImJ1aWxkRXhwcyIsIm1heEludCIsImJhc2UiLCJ0TWluIiwidE1heCIsInNrZXciLCJkYW1wIiwiaW5pdGlhbEJpYXMiLCJpbml0aWFsTiIsInJlZ2V4UHVueWNvZGUiLCJyZWdleE5vbkFTQ0lJIiwicmVnZXhTZXBhcmF0b3JzIiwiZXJyb3JzIiwiYmFzZU1pbnVzVE1pbiIsInN0cmluZ0Zyb21DaGFyQ29kZSIsImxhYmVscyIsImVuY29kZWQiLCJvdXRwdXQiLCJjb3VudGVyIiwiZXh0cmEiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiY29kZVBvaW50IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJmaXJzdFRpbWUiLCJkZWx0YSIsImlucHV0TGVuZ3RoIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsInQiLCJiYXNlTWludXNUIiwib3V0IiwidWNzMmRlY29kZSIsImN1cnJlbnRWYWx1ZSIsImJhc2ljTGVuZ3RoIiwiaGFuZGxlZENQQ291bnQiLCJtIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicSIsInFNaW51c1QiLCJ0b1VuaWNvZGUiLCJ0b0FTQ0lJIiwicHVueWNvZGUiLCJTQ0hFTUVTIiwiYyIsIm5ld1N0ciIsImlsIiwiYzIiLCJjMyIsImRlY29kZVVucmVzZXJ2ZWQiLCJkZWNTdHIiLCJwY3REZWNDaGFycyIsImhvc3QiLCJhZGRyZXNzIiwiem9uZSIsImZpcnN0RmllbGRzIiwibGFzdEZpZWxkcyIsImlzTGFzdEZpZWxkSVB2NEFkZHJlc3MiLCJmaWVsZENvdW50IiwibGFzdEZpZWxkc1N0YXJ0IiwiX25vcm1hbGl6ZUlQdjQiLCJhbGxaZXJvRmllbGRzIiwibGFzdExvbmdlc3QiLCJsb25nZXN0WmVyb0ZpZWxkcyIsImIiLCJhIiwibmV3SG9zdCIsIm5ld0ZpcnN0IiwibmV3TGFzdCIsIlVSSV9QQVJTRSIsIk5PX01BVENIX0lTX1VOREVGSU5FRCIsInVyaVN0cmluZyIsIl9ub3JtYWxpemVJUHY2Iiwic2NoZW1lSGFuZGxlciIsInVyaVRva2VucyIsIiQyIiwiUkRTMSIsIlJEUzIiLCJSRFMzIiwiUkRTNSIsImltIiwiYXV0aG9yaXR5IiwiX3JlY29tcG9zZUF1dGhvcml0eSIsInJlbW92ZURvdFNlZ21lbnRzIiwic2tpcE5vcm1hbGl6YXRpb24iLCJzY2hlbWVsZXNzT3B0aW9ucyIsInJlc29sdmVDb21wb25lbnRzIiwidHlwZU9mIiwidXJpQSIsIlVSSV9QUk9UT0NPTCIsIklSSV9QUk9UT0NPTCIsImhhbmRsZXIiLCJPIiwiQVRFWFQkJCIsIlFURVhUJCQiLCJWQ0hBUiQkIiwiU09NRV9ERUxJTVMkJCIsIlVOUkVTRVJWRUQiLCJQQ1RfRU5DT0RFRCIsIk5PVF9MT0NBTF9QQVJUIiwiTk9UX0hGTkFNRSIsIk5PVF9IRlZBTFVFIiwibWFpbHRvQ29tcG9uZW50cyIsInVua25vd25IZWFkZXJzIiwiaGZpZWxkcyIsImhmaWVsZCIsInRvQWRkcnMiLCJ1bmVzY2FwZUNvbXBvbmVudCIsImFkZHIiLCJ0b0FkZHIiLCJhdElkeCIsImxvY2FsUGFydCIsImRvbWFpbiIsIlVSTl9QQVJTRSIsInVybkNvbXBvbmVudHMiLCJuaWQiLCJuc3MiLCJ1cm5TY2hlbWUiLCJ1cmlDb21wb25lbnRzIiwiVVVJRCIsInV1aWRDb21wb25lbnRzIiwibWFpbHRvIiwidXJuIiwidXVpZCIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsImVudW1lcmFibGUiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7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QUFDdEI5WCxVQUFNLENBQUNpZ0IsY0FBUCxDQUFzQjNTLE1BQXRCLEVBQThCLFFBQTlCLEVBQXdDO0FBQ3ZDdTFELGdCQUFVLEVBQUUsSUFEMkI7QUFFdkN2bkQsU0FBRyxFQUFFLGVBQVc7QUFDZixlQUFPaE8sTUFBTSxDQUFDNEgsQ0FBZDtBQUNBO0FBSnNDLEtBQXhDO0FBTUFsVixVQUFNLENBQUNpZ0IsY0FBUCxDQUFzQjNTLE1BQXRCLEVBQThCLElBQTlCLEVBQW9DO0FBQ25DdTFELGdCQUFVLEVBQUUsSUFEdUI7QUFFbkN2bkQsU0FBRyxFQUFFLGVBQVc7QUFDZixlQUFPaE8sTUFBTSxDQUFDa0IsQ0FBZDtBQUNBO0FBSmtDLEtBQXBDO0FBTUFsQixVQUFNLENBQUNxMUQsZUFBUCxHQUF5QixDQUF6QjtBQUNBOztBQUNELFNBQU9yMUQsTUFBUDtBQUNBLENBckJELEMiLCJmaWxlIjoianNvbi1yZWZzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9pbmRleC5qc1wiKTtcbiIsIi8qXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgSmVyZW15IFdoaXRsb2NrXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGdsIGZyb20gJ2dyYXBobGliJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IFBhdGhMb2FkZXIgZnJvbSAncGF0aC1sb2FkZXInO1xuaW1wb3J0IHFzIGZyb20gJ3F1ZXJ5c3RyaW5nJztcbmltcG9ydCBzbGFzaCBmcm9tICdzbGFzaCc7XG5pbXBvcnQgVVJJIGZyb20gJ3VyaS1qcyc7XG5cbnZhciBiYWRQdHJUb2tlblJlZ2V4ID0gL34oPzpbXjAxXXwkKS9nO1xudmFyIHJlbW90ZUNhY2hlID0ge307XG52YXIgcmVtb3RlVHlwZXMgPSBbJ3JlbGF0aXZlJywgJ3JlbW90ZSddO1xudmFyIHJlbW90ZVVyaVR5cGVzID0gWydhYnNvbHV0ZScsICd1cmknXTtcbnZhciB1cmlEZXRhaWxzQ2FjaGUgPSB7fTtcblxuLyogSW50ZXJuYWwgRnVuY3Rpb25zICovXG5cbmZ1bmN0aW9uIGNvbWJpbmVRdWVyeVBhcmFtcyAocXMxLCBxczIpIHtcbiAgdmFyIGNvbWJpbmVkID0ge307XG5cbiAgZnVuY3Rpb24gbWVyZ2VRdWVyeVBhcmFtcyAob2JqKSB7XG4gICAgXy5mb3JPd24ob2JqLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICAgIGNvbWJpbmVkW2tleV0gPSB2YWw7XG4gICAgfSk7XG4gIH1cblxuICBtZXJnZVF1ZXJ5UGFyYW1zKHFzLnBhcnNlKHFzMSB8fCAnJykpO1xuICBtZXJnZVF1ZXJ5UGFyYW1zKHFzLnBhcnNlKHFzMiB8fCAnJykpO1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhjb21iaW5lZCkubGVuZ3RoID09PSAwID8gdW5kZWZpbmVkIDogcXMuc3RyaW5naWZ5KGNvbWJpbmVkKTtcbn1cblxuZnVuY3Rpb24gY29tYmluZVVSSXMgKHUxLCB1Mikge1xuICAvLyBDb252ZXJ0IFdpbmRvd3MgcGF0aHNcbiAgaWYgKF8uaXNTdHJpbmcodTEpKSB7XG4gICAgdTEgPSBzbGFzaCh1MSk7XG4gIH1cblxuICBpZiAoXy5pc1N0cmluZyh1MikpIHtcbiAgICB1MiA9IHNsYXNoKHUyKTtcbiAgfVxuXG4gIHZhciB1MkRldGFpbHMgPSBwYXJzZVVSSShfLmlzVW5kZWZpbmVkKHUyKSA/ICcnIDogdTIpO1xuICB2YXIgdTFEZXRhaWxzO1xuICB2YXIgY29tYmluZWREZXRhaWxzO1xuXG4gIGlmIChyZW1vdGVVcmlUeXBlcy5pbmRleE9mKHUyRGV0YWlscy5yZWZlcmVuY2UpID4gLTEpIHtcbiAgICBjb21iaW5lZERldGFpbHMgPSB1MkRldGFpbHM7XG4gIH0gZWxzZSB7XG4gICAgdTFEZXRhaWxzID0gXy5pc1VuZGVmaW5lZCh1MSkgPyB1bmRlZmluZWQgOiBwYXJzZVVSSSh1MSk7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQodTFEZXRhaWxzKSkge1xuICAgICAgY29tYmluZWREZXRhaWxzID0gdTFEZXRhaWxzO1xuXG4gICAgICAvLyBKb2luIHRoZSBwYXRoc1xuICAgICAgY29tYmluZWREZXRhaWxzLnBhdGggPSBzbGFzaChwYXRoLmpvaW4odTFEZXRhaWxzLnBhdGgsIHUyRGV0YWlscy5wYXRoKSk7XG5cbiAgICAgIC8vIEpvaW4gcXVlcnkgcGFyYW1ldGVyc1xuICAgICAgY29tYmluZWREZXRhaWxzLnF1ZXJ5ID0gY29tYmluZVF1ZXJ5UGFyYW1zKHUxRGV0YWlscy5xdWVyeSwgdTJEZXRhaWxzLnF1ZXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tYmluZWREZXRhaWxzID0gdTJEZXRhaWxzO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSB0aGUgZnJhZ21lbnRcbiAgY29tYmluZWREZXRhaWxzLmZyYWdtZW50ID0gdW5kZWZpbmVkO1xuXG4gIC8vIEZvciByZWxhdGl2ZSBVUklzLCBhZGQgYmFjayB0aGUgJy4uJyBzaW5jZSBpdCB3YXMgcmVtb3ZlZCBhYm92ZVxuICByZXR1cm4gKHJlbW90ZVVyaVR5cGVzLmluZGV4T2YoY29tYmluZWREZXRhaWxzLnJlZmVyZW5jZSkgPT09IC0xICYmXG4gICAgICAgICAgY29tYmluZWREZXRhaWxzLnBhdGguaW5kZXhPZignLi4vJykgPT09IDAgPyAnLi4vJyA6ICcnKSArIFVSSS5zZXJpYWxpemUoY29tYmluZWREZXRhaWxzKTtcbn1cblxuZnVuY3Rpb24gZmluZEFuY2VzdG9ycyAob2JqLCBwYXRoKSB7XG4gIHZhciBhbmNlc3RvcnMgPSBbXTtcbiAgdmFyIG5vZGU7XG5cbiAgaWYgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgIG5vZGUgPSBvYmo7XG5cbiAgICBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMSkuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XG4gICAgICBpZiAoc2VnIGluIG5vZGUpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVbc2VnXTtcblxuICAgICAgICBhbmNlc3RvcnMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhbmNlc3RvcnM7XG59XG5cbmZ1bmN0aW9uIGlzUmVtb3RlIChyZWZEZXRhaWxzKSB7XG4gIHJldHVybiByZW1vdGVUeXBlcy5pbmRleE9mKGdldFJlZlR5cGUocmVmRGV0YWlscykpID4gLTE7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQgKHJlZkRldGFpbHMpIHtcbiAgcmV0dXJuIF8uaXNVbmRlZmluZWQocmVmRGV0YWlscy5lcnJvcikgJiYgcmVmRGV0YWlscy50eXBlICE9PSAnaW52YWxpZCc7XG59XG5cbmZ1bmN0aW9uIGZpbmRWYWx1ZSAob2JqLCBwYXRoKSB7XG4gIHZhciB2YWx1ZSA9IG9iajtcblxuICAvLyBVc2luZyB0aGlzIG1hbnVhbCBhcHByb2FjaCBpbnN0ZWFkIG9mIF8uZ2V0IHNpbmNlIHdlIGhhdmUgdG8gZGVjb2RlVVJJIHRoZSBzZWdtZW50c1xuICBwYXRoLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xuICAgIGlmIChzZWcgaW4gdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbc2VnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ0pTT04gUG9pbnRlciBwb2ludHMgdG8gbWlzc2luZyBsb2NhdGlvbjogJyArIF9wYXRoVG9QdHIocGF0aCkpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRFeHRyYVJlZktleXMgKHJlZikge1xuICByZXR1cm4gT2JqZWN0LmtleXMocmVmKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkgIT09ICckcmVmJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlZlR5cGUgKHJlZkRldGFpbHMpIHtcbiAgdmFyIHR5cGU7XG5cbiAgLy8gQ29udmVydCB0aGUgVVJJIHJlZmVyZW5jZSB0byBvbmUgb2Ygb3VyIHR5cGVzXG4gIHN3aXRjaCAocmVmRGV0YWlscy51cmlEZXRhaWxzLnJlZmVyZW5jZSkge1xuICBjYXNlICdhYnNvbHV0ZSc6XG4gIGNhc2UgJ3VyaSc6XG4gICAgdHlwZSA9ICdyZW1vdGUnO1xuICAgIGJyZWFrO1xuICBjYXNlICdzYW1lLWRvY3VtZW50JzpcbiAgICB0eXBlID0gJ2xvY2FsJztcbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICB0eXBlID0gcmVmRGV0YWlscy51cmlEZXRhaWxzLnJlZmVyZW5jZTtcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xufVxuXG5mdW5jdGlvbiBnZXRSZW1vdGVEb2N1bWVudCAodXJsLCBvcHRpb25zKSB7XG4gIHZhciBjYWNoZUVudHJ5ID0gcmVtb3RlQ2FjaGVbdXJsXTtcbiAgdmFyIGFsbFRhc2tzID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHZhciBsb2FkZXJPcHRpb25zID0gXy5jbG9uZURlZXAob3B0aW9ucy5sb2FkZXJPcHRpb25zIHx8IHt9KTtcblxuICBpZiAoXy5pc1VuZGVmaW5lZChjYWNoZUVudHJ5KSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGNvbnRlbnQgcHJvY2Vzc29yLCBkZWZhdWx0IHRvIHByb2Nlc3NpbmcgdGhlIHJhdyByZXNwb25zZSBhcyBKU09OXG4gICAgaWYgKF8uaXNVbmRlZmluZWQobG9hZGVyT3B0aW9ucy5wcm9jZXNzQ29udGVudCkpIHtcbiAgICAgIGxvYWRlck9wdGlvbnMucHJvY2Vzc0NvbnRlbnQgPSBmdW5jdGlvbiAocmVzLCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayh1bmRlZmluZWQsIEpTT04ucGFyc2UocmVzLnRleHQpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQXR0ZW1wdCB0byBsb2FkIHRoZSByZXNvdXJjZSB1c2luZyBwYXRoLWxvYWRlclxuICAgIGFsbFRhc2tzID0gUGF0aExvYWRlci5sb2FkKGRlY29kZVVSSSh1cmwpLCBsb2FkZXJPcHRpb25zKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgY2FjaGVcbiAgICBhbGxUYXNrcyA9IGFsbFRhc2tzXG4gICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHJlbW90ZUNhY2hlW3VybF0gPSB7XG4gICAgICAgICAgdmFsdWU6IHJlc1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmVtb3RlQ2FjaGVbdXJsXSA9IHtcbiAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmV0dXJuIHRoZSBjYWNoZWQgdmVyc2lvblxuICAgIGFsbFRhc2tzID0gYWxsVGFza3MudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoXy5pc0Vycm9yKGNhY2hlRW50cnkuZXJyb3IpKSB7XG4gICAgICAgIHRocm93IGNhY2hlRW50cnkuZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2FjaGVFbnRyeS52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJldHVybiBhIGNsb25lZCB2ZXJzaW9uIHRvIGF2b2lkIHVwZGF0aW5nIHRoZSBjYWNoZVxuICBhbGxUYXNrcyA9IGFsbFRhc2tzLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgIHJldHVybiBfLmNsb25lRGVlcChyZXMpO1xuICB9KTtcblxuICByZXR1cm4gYWxsVGFza3M7XG59XG5cbmZ1bmN0aW9uIGlzUmVmTGlrZSAob2JqLCB0aHJvd1dpdGhEZXRhaWxzKSB7XG4gIHZhciByZWZMaWtlID0gdHJ1ZTtcblxuICB0cnkge1xuICAgIGlmICghXy5pc1BsYWluT2JqZWN0KG9iaikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb2JqIGlzIG5vdCBhbiBPYmplY3QnKTtcbiAgICB9IGVsc2UgaWYgKCFfLmlzU3RyaW5nKG9iai4kcmVmKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvYmouJHJlZiBpcyBub3QgYSBTdHJpbmcnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0aHJvd1dpdGhEZXRhaWxzKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgcmVmTGlrZSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHJlZkxpa2U7XG59XG5cbmZ1bmN0aW9uIG1ha2VBYnNvbHV0ZSAobG9jYXRpb24pIHtcbiAgaWYgKGxvY2F0aW9uLmluZGV4T2YoJzovLycpID09PSAtMSAmJiAhcGF0aC5pc0Fic29sdXRlKGxvY2F0aW9uKSkge1xuICAgIHJldHVybiBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgbG9jYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsb2NhdGlvbjtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlUmVmRmlsdGVyIChvcHRpb25zKSB7XG4gIHZhciByZWZGaWx0ZXI7XG4gIHZhciB2YWxpZFR5cGVzO1xuXG4gIGlmIChfLmlzQXJyYXkob3B0aW9ucy5maWx0ZXIpIHx8IF8uaXNTdHJpbmcob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgdmFsaWRUeXBlcyA9IF8uaXNTdHJpbmcob3B0aW9ucy5maWx0ZXIpID8gW29wdGlvbnMuZmlsdGVyXSA6IG9wdGlvbnMuZmlsdGVyO1xuICAgIHJlZkZpbHRlciA9IGZ1bmN0aW9uIChyZWZEZXRhaWxzKSB7XG4gICAgICAvLyBDaGVjayB0aGUgZXhhY3QgdHlwZSBvciBmb3IgaW52YWxpZCBVUklzLCBjaGVjayBpdHMgb3JpZ2luYWwgdHlwZVxuICAgICAgcmV0dXJuIHZhbGlkVHlwZXMuaW5kZXhPZihyZWZEZXRhaWxzLnR5cGUpID4gLTEgfHwgdmFsaWRUeXBlcy5pbmRleE9mKGdldFJlZlR5cGUocmVmRGV0YWlscykpID4gLTE7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChfLmlzRnVuY3Rpb24ob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgcmVmRmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gIH0gZWxzZSBpZiAoXy5pc1VuZGVmaW5lZChvcHRpb25zLmZpbHRlcikpIHtcbiAgICByZWZGaWx0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZWZEZXRhaWxzLCBwYXRoKSB7XG4gICAgcmV0dXJuIChyZWZEZXRhaWxzLnR5cGUgIT09ICdpbnZhbGlkJyB8fCBvcHRpb25zLmluY2x1ZGVJbnZhbGlkID09PSB0cnVlKSAmJiByZWZGaWx0ZXIocmVmRGV0YWlscywgcGF0aCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VTdWJEb2NQYXRoIChvcHRpb25zKSB7XG4gIHZhciBzdWJEb2NQYXRoO1xuXG4gIGlmIChfLmlzQXJyYXkob3B0aW9ucy5zdWJEb2NQYXRoKSkge1xuICAgIHN1YkRvY1BhdGggPSBvcHRpb25zLnN1YkRvY1BhdGg7XG4gIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhvcHRpb25zLnN1YkRvY1BhdGgpKSB7XG4gICAgc3ViRG9jUGF0aCA9IF9wYXRoRnJvbVB0cihvcHRpb25zLnN1YkRvY1BhdGgpO1xuICB9IGVsc2UgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9ucy5zdWJEb2NQYXRoKSkge1xuICAgIHN1YkRvY1BhdGggPSBbXTtcbiAgfVxuXG4gIHJldHVybiBzdWJEb2NQYXRoO1xufVxuXG5mdW5jdGlvbiBtYXJrTWlzc2luZyAocmVmRGV0YWlscywgZXJyKSB7XG4gIHJlZkRldGFpbHMuZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgcmVmRGV0YWlscy5taXNzaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVUkkgKHVyaSkge1xuICAvLyBXZSBkZWNvZGUgZmlyc3QgdG8gYXZvaWQgZG91Ymx5IGVuY29kaW5nXG4gIHJldHVybiBVUkkucGFyc2UodXJpKTtcbn1cblxuZnVuY3Rpb24gYnVpbGRSZWZNb2RlbCAoZG9jdW1lbnQsIG9wdGlvbnMsIG1ldGFkYXRhKSB7XG4gIHZhciBhbGxUYXNrcyA9IFByb21pc2UucmVzb2x2ZSgpO1xuICB2YXIgc3ViRG9jUHRyID0gX3BhdGhUb1B0cihvcHRpb25zLnN1YkRvY1BhdGgpO1xuICB2YXIgYWJzTG9jYXRpb24gPSBtYWtlQWJzb2x1dGUob3B0aW9ucy5sb2NhdGlvbik7XG4gIHZhciByZWxhdGl2ZUJhc2UgPSBwYXRoLmRpcm5hbWUob3B0aW9ucy5sb2NhdGlvbik7XG4gIHZhciBkb2NEZXBLZXkgPSBhYnNMb2NhdGlvbiArIHN1YkRvY1B0cjtcbiAgdmFyIHJlZnM7XG4gIHZhciByT3B0aW9ucztcblxuICAvLyBTdG9yZSB0aGUgZG9jdW1lbnQgaW4gdGhlIG1ldGFkYXRhIGlmIG5lY2Vzc2FyeVxuICBpZiAoXy5pc1VuZGVmaW5lZChtZXRhZGF0YS5kb2NzW2Fic0xvY2F0aW9uXSkpIHtcbiAgICBtZXRhZGF0YS5kb2NzW2Fic0xvY2F0aW9uXSA9IGRvY3VtZW50O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG5vIGRlcGVuZGVuY2llcyBzdG9yZWQgZm9yIHRoZSBsb2NhdGlvbitzdWJEb2NQYXRoLCB3ZSd2ZSBuZXZlciBzZWVuIGl0IGJlZm9yZSBhbmQgd2lsbCBwcm9jZXNzIGl0XG4gIGlmIChfLmlzVW5kZWZpbmVkKG1ldGFkYXRhLmRlcHNbZG9jRGVwS2V5XSkpIHtcbiAgICBtZXRhZGF0YS5kZXBzW2RvY0RlcEtleV0gPSB7fTtcblxuICAgIC8vIEZpbmQgdGhlIHJlZmVyZW5jZXMgYmFzZWQgb24gdGhlIG9wdGlvbnNcbiAgICByZWZzID0gX2ZpbmRSZWZzKGRvY3VtZW50LCBvcHRpb25zKTtcblxuICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgcmVmZXJlbmNlcyBhbmQgcHJvY2Vzc1xuICAgIF8uZm9yT3duKHJlZnMsIGZ1bmN0aW9uIChyZWZEZXRhaWxzLCByZWZQdHIpIHtcbiAgICAgIHZhciByZWZLZXkgPSBtYWtlQWJzb2x1dGUob3B0aW9ucy5sb2NhdGlvbikgKyByZWZQdHI7XG4gICAgICB2YXIgcmVmZEtleSA9IHJlZkRldGFpbHMucmVmZElkID0gZGVjb2RlVVJJKG1ha2VBYnNvbHV0ZShpc1JlbW90ZShyZWZEZXRhaWxzKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZVVSSXMocmVsYXRpdmVCYXNlLCByZWZEZXRhaWxzLnVyaSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYXRpb24pICsgJyMnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWZEZXRhaWxzLnVyaS5pbmRleE9mKCcjJykgPiAtMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZEZXRhaWxzLnVyaS5zcGxpdCgnIycpWzFdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnKSk7XG5cbiAgICAgIC8vIFJlY29yZCByZWZlcmVuY2UgbWV0YWRhdGFcbiAgICAgIG1ldGFkYXRhLnJlZnNbcmVmS2V5XSA9IHJlZkRldGFpbHM7XG5cbiAgICAgIC8vIERvIG5vdCBwcm9jZXNzIGludmFsaWQgcmVmZXJlbmNlc1xuICAgICAgaWYgKCFpc1ZhbGlkKHJlZkRldGFpbHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVjb3JkIHRoZSBmdWxseS1xdWFsaWZpZWQgVVJJXG4gICAgICByZWZEZXRhaWxzLmZxVVJJID0gcmVmZEtleTtcblxuICAgICAgLy8gUmVjb3JkIGRlcGVuZGVuY3kgKHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCdzIHN1Yi1kb2N1bWVudCBwYXRoKVxuICAgICAgbWV0YWRhdGEuZGVwc1tkb2NEZXBLZXldW3JlZlB0ciA9PT0gc3ViRG9jUHRyID8gJyMnIDogcmVmUHRyLnJlcGxhY2Uoc3ViRG9jUHRyICsgJy8nLCAnIy8nKV0gPSByZWZkS2V5O1xuXG4gICAgICAvLyBEbyBub3QgcHJvY2VzcyBkaXJlY3RseS1jaXJjdWxhciByZWZlcmVuY2VzICh0byBhbiBhbmNlc3RvciBvciBzZWxmKVxuICAgICAgaWYgKHJlZktleS5pbmRleE9mKHJlZmRLZXkgKyAnLycpID09PSAwKSB7XG4gICAgICAgIHJlZkRldGFpbHMuY2lyY3VsYXIgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgb3B0aW9ucyBmb3Igc3Vic2VxdWVudCBwcm9jZXNzRG9jdW1lbnQgY2FsbHNcbiAgICAgIHJPcHRpb25zID0gXy5jbG9uZURlZXAob3B0aW9ucyk7XG5cbiAgICAgIHJPcHRpb25zLnN1YkRvY1BhdGggPSBfLmlzVW5kZWZpbmVkKHJlZkRldGFpbHMudXJpRGV0YWlscy5mcmFnbWVudCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGF0aEZyb21QdHIoZGVjb2RlVVJJKHJlZkRldGFpbHMudXJpRGV0YWlscy5mcmFnbWVudCkpO1xuXG4gICAgICAvLyBSZXNvbHZlIHRoZSByZWZlcmVuY2VcbiAgICAgIGlmIChpc1JlbW90ZShyZWZEZXRhaWxzKSkge1xuICAgICAgICAvLyBEZWxldGUgZmlsdGVyLm9wdGlvbnMgYmVjYXVzZSBhbGwgcmVtb3RlIHJlZmVyZW5jZXMgc2hvdWxkIGJlIGZ1bGx5IHJlc29sdmVkXG4gICAgICAgIGRlbGV0ZSByT3B0aW9ucy5maWx0ZXI7XG4gICAgICAgIC8vIFRoZSBuZXcgbG9jYXRpb24gYmVpbmcgcmVmZXJlbmNlZFxuICAgICAgICByT3B0aW9ucy5sb2NhdGlvbiA9IHJlZmRLZXkuc3BsaXQoJyMnKVswXTtcblxuICAgICAgICBhbGxUYXNrcyA9IGFsbFRhc2tzXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG5NZXRhZGF0YSwgbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciByQWJzTG9jYXRpb24gPSBtYWtlQWJzb2x1dGUobk9wdGlvbnMubG9jYXRpb24pO1xuICAgICAgICAgICAgICB2YXIgckRvYyA9IG5NZXRhZGF0YS5kb2NzW3JBYnNMb2NhdGlvbl07XG5cbiAgICAgICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQockRvYykpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIG5vIGNhY2hlIHNvIHdlIG11c3QgcmV0cmlldmUgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFJlbW90ZURvY3VtZW50KHJBYnNMb2NhdGlvbiwgbk9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgcmVzcG9uc2UgaW4gdGhlIGRvY3VtZW50IGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5NZXRhZGF0YS5kb2NzW3JBYnNMb2NhdGlvbl0gPSBlcnI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBlcnJvciB0byBhbGxvdyB0aGUgc3Vic2VxdWVudCBgdGhlbmAgdG8gaGFuZGxlIGJvdGggZXJyb3JzIGFuZCBzdWNjZXNzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSByZXRyaWV2ZWQgKG9yIGF0dGVtcHRlZCB0bykgdGhlIGRvY3VtZW50IGFuZCBzaG91bGQgdXNlIHRoZSBjYWNoZWQgdmVyc2lvbiBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBtZXRhZGF0YSBzaW5jZSBpdCBjb3VsZCBhbHJlYWR5IGJlIHByb2Nlc3NlZCBzb21lLlxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gckRvYztcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0obWV0YWRhdGEsIHJPcHRpb25zKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxUYXNrcyA9IGFsbFRhc2tzXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBQcm9jZXNzIHRoZSByZW1vdGUgZG9jdW1lbnQgb3IgdGhlIHJlZmVyZW5jZWQgcG9ydGlvbiBvZiB0aGUgbG9jYWwgZG9jdW1lbnRcbiAgICAgIGFsbFRhc2tzID0gYWxsVGFza3NcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKG5NZXRhZGF0YSwgbk9wdGlvbnMsIG5SZWZEZXRhaWxzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgICAgICAgIGlmIChfLmlzRXJyb3IoZG9jKSkge1xuICAgICAgICAgICAgICBtYXJrTWlzc2luZyhuUmVmRGV0YWlscywgZG9jKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFdyYXBwZWQgaW4gYSB0cnkvY2F0Y2ggc2luY2UgZmluZFJlZnMgdGhyb3dzXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkUmVmTW9kZWwoZG9jLCBuT3B0aW9ucywgbk1ldGFkYXRhKVxuICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFya01pc3NpbmcoblJlZkRldGFpbHMsIGVycik7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbWFya01pc3NpbmcoblJlZkRldGFpbHMsIGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KG1ldGFkYXRhLCByT3B0aW9ucywgcmVmRGV0YWlscykpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGFsbFRhc2tzO1xufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZSAob2JqLCByZWZQYXRoLCB2YWx1ZSkge1xuICBmaW5kVmFsdWUob2JqLCByZWZQYXRoLnNsaWNlKDAsIHJlZlBhdGgubGVuZ3RoIC0gMSkpW3JlZlBhdGhbcmVmUGF0aC5sZW5ndGggLSAxXV0gPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gd2FsayAoYW5jZXN0b3JzLCBub2RlLCBwYXRoLCBmbikge1xuICB2YXIgcHJvY2Vzc0NoaWxkcmVuID0gdHJ1ZTtcblxuICBmdW5jdGlvbiB3YWxrSXRlbSAoaXRlbSwgc2VnbWVudCkge1xuICAgIHBhdGgucHVzaChzZWdtZW50KTtcbiAgICB3YWxrKGFuY2VzdG9ycywgaXRlbSwgcGF0aCwgZm4pO1xuICAgIHBhdGgucG9wKCk7XG4gIH1cblxuICAvLyBDYWxsIHRoZSBpdGVyYXRlZVxuICBpZiAoXy5pc0Z1bmN0aW9uKGZuKSkge1xuICAgIHByb2Nlc3NDaGlsZHJlbiA9IGZuKGFuY2VzdG9ycywgbm9kZSwgcGF0aCk7XG4gIH1cblxuICAvLyBXZSBkbyBub3QgcHJvY2VzcyBjaXJjdWxhciBvYmplY3RzIGFnYWluXG4gIGlmIChhbmNlc3RvcnMuaW5kZXhPZihub2RlKSA9PT0gLTEpIHtcbiAgICBhbmNlc3RvcnMucHVzaChub2RlKTtcblxuICAgIGlmIChwcm9jZXNzQ2hpbGRyZW4gIT09IGZhbHNlKSB7XG4gICAgICBpZiAoXy5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIG5vZGUuZm9yRWFjaChmdW5jdGlvbiAobWVtYmVyLCBpbmRleCkge1xuICAgICAgICAgIHdhbGtJdGVtKG1lbWJlciwgaW5kZXgudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KG5vZGUpKSB7XG4gICAgICAgIF8uZm9yT3duKG5vZGUsIGZ1bmN0aW9uIChjTm9kZSwga2V5KSB7XG4gICAgICAgICAgd2Fsa0l0ZW0oY05vZGUsIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFuY2VzdG9ycy5wb3AoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMgKG9wdGlvbnMsIG9iaikge1xuICB2YXIgbG9jYXRpb25QYXJ0cztcbiAgdmFyIHNob3VsZERlY29kZTtcblxuICBpZiAoXy5pc1VuZGVmaW5lZChvcHRpb25zKSkge1xuICAgIC8vIERlZmF1bHQgdG8gYW4gZW1wdHkgb3B0aW9ucyBvYmplY3RcbiAgICBvcHRpb25zID0ge307XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2xvbmUgdGhlIG9wdGlvbnMgc28gd2UgZG8gbm90IGFsdGVyIHRoZSBvbmVzIHBhc3NlZCBpblxuICAgIG9wdGlvbnMgPSBfLmNsb25lRGVlcChvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghXy5pc09iamVjdChvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBPYmplY3QnKTtcbiAgfSBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zLnJlc29sdmVDaXJjdWxhcnMpICYmXG4gICAgICAgICAgICAgIV8uaXNCb29sZWFuKG9wdGlvbnMucmVzb2x2ZUNpcmN1bGFycykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLnJlc29sdmVDaXJjdWxhcnMgbXVzdCBiZSBhIEJvb2xlYW4nKTtcbiAgfSBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zLmZpbHRlcikgJiZcbiAgICAgICAgICAgICAhXy5pc0FycmF5KG9wdGlvbnMuZmlsdGVyKSAmJlxuICAgICAgICAgICAgICFfLmlzRnVuY3Rpb24ob3B0aW9ucy5maWx0ZXIpICYmXG4gICAgICAgICAgICAgIV8uaXNTdHJpbmcob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5maWx0ZXIgbXVzdCBiZSBhbiBBcnJheSwgYSBGdW5jdGlvbiBvZiBhIFN0cmluZycpO1xuICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKG9wdGlvbnMuaW5jbHVkZUludmFsaWQpICYmXG4gICAgICAgICAgICAgIV8uaXNCb29sZWFuKG9wdGlvbnMuaW5jbHVkZUludmFsaWQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5pbmNsdWRlSW52YWxpZCBtdXN0IGJlIGEgQm9vbGVhbicpO1xuICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKG9wdGlvbnMubG9jYXRpb24pICYmXG4gICAgICAgICAgICAgIV8uaXNTdHJpbmcob3B0aW9ucy5sb2NhdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmxvY2F0aW9uIG11c3QgYmUgYSBTdHJpbmcnKTtcbiAgfSBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zLnJlZlByZVByb2Nlc3NvcikgJiZcbiAgICAgICAgICAgICAhXy5pc0Z1bmN0aW9uKG9wdGlvbnMucmVmUHJlUHJvY2Vzc29yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMucmVmUHJlUHJvY2Vzc29yIG11c3QgYmUgYSBGdW5jdGlvbicpO1xuICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKG9wdGlvbnMucmVmUG9zdFByb2Nlc3NvcikgJiZcbiAgICAgICAgICAgICAhXy5pc0Z1bmN0aW9uKG9wdGlvbnMucmVmUG9zdFByb2Nlc3NvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLnJlZlBvc3RQcm9jZXNzb3IgbXVzdCBiZSBhIEZ1bmN0aW9uJyk7XG4gIH0gZWxzZSBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5zdWJEb2NQYXRoKSAmJlxuICAgICAgICAgICAgICFfLmlzQXJyYXkob3B0aW9ucy5zdWJEb2NQYXRoKSAmJlxuICAgICAgICAgICAgICFfaXNQdHIob3B0aW9ucy5zdWJEb2NQYXRoKSkge1xuICAgIC8vIElmIGEgcG9pbnRlciBpcyBwcm92aWRlZCwgdGhyb3cgYW4gZXJyb3IgaWYgaXQncyBub3QgdGhlIHByb3BlciB0eXBlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5zdWJEb2NQYXRoIG11c3QgYmUgYW4gQXJyYXkgb2YgcGF0aCBzZWdtZW50cyBvciBhIHZhbGlkIEpTT04gUG9pbnRlcicpO1xuICB9XG5cbiAgLy8gRGVmYXVsdCB0byBmYWxzZSBmb3IgYWxsb3dpbmcgY2lyY3VsYXJzXG4gIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbnMucmVzb2x2ZUNpcmN1bGFycykpIHtcbiAgICBvcHRpb25zLnJlc29sdmVDaXJjdWxhcnMgPSBmYWxzZTtcbiAgfVxuXG4gIG9wdGlvbnMuZmlsdGVyID0gbWFrZVJlZkZpbHRlcihvcHRpb25zKTtcblxuICAvLyBvcHRpb25zLmxvY2F0aW9uIGlzIG5vdCBvZmZpY2lhbGx5IHN1cHBvcnRlZCB5ZXQgYnV0IHdpbGwgYmUgd2hlbiBJc3N1ZSA4OCBpcyBjb21wbGV0ZVxuICBpZiAoXy5pc1VuZGVmaW5lZChvcHRpb25zLmxvY2F0aW9uKSkge1xuICAgIG9wdGlvbnMubG9jYXRpb24gPSBtYWtlQWJzb2x1dGUoJy4vcm9vdC5qc29uJyk7XG4gIH1cblxuICBsb2NhdGlvblBhcnRzID0gb3B0aW9ucy5sb2NhdGlvbi5zcGxpdCgnIycpO1xuXG4gIC8vIElmIG9wdGlvbnMubG9jYXRpb24gY29udGFpbnMgYSBmcmFnbWVudCwgdHVybiBpdCBpbnRvIGFuIG9wdGlvbnMuc3ViRG9jUGF0aFxuICBpZiAobG9jYXRpb25QYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgb3B0aW9ucy5zdWJEb2NQYXRoID0gJyMnICsgbG9jYXRpb25QYXJ0c1sxXTtcbiAgfVxuXG4gIHNob3VsZERlY29kZSA9IGRlY29kZVVSSShvcHRpb25zLmxvY2F0aW9uKSA9PT0gb3B0aW9ucy5sb2NhdGlvbjtcblxuICAvLyBKdXN0IHRvIGJlIHNhZmUsIHJlbW92ZSBhbnkgYWNjaWRlbnRhbCBmcmFnbWVudCBhcyBpdCB3b3VsZCBicmVhayB0aGluZ3NcbiAgb3B0aW9ucy5sb2NhdGlvbiA9IGNvbWJpbmVVUklzKG9wdGlvbnMubG9jYXRpb24sIHVuZGVmaW5lZCk7XG5cbiAgLy8gSWYgdGhlIGxvY2F0aW9uIHdhcyBub3QgZW5jb2RlZCwgbWVrZSBzdXJlIGl0J3Mgbm90IHdoZW4gd2UgZ2V0IGl0IGJhY2sgKElzc3VlICMxMzgpXG4gIGlmIChzaG91bGREZWNvZGUpIHtcbiAgICBvcHRpb25zLmxvY2F0aW9uID0gZGVjb2RlVVJJKG9wdGlvbnMubG9jYXRpb24pO1xuICB9XG5cbiAgLy8gU2V0IHRoZSBzdWJEb2NQYXRoIHRvIGF2b2lkIGV2ZXJ5b25lIGVsc2UgaGF2aW5nIHRvIGNvbXB1dGUgaXRcbiAgb3B0aW9ucy5zdWJEb2NQYXRoID0gbWFrZVN1YkRvY1BhdGgob3B0aW9ucyk7XG5cbiAgaWYgKCFfLmlzVW5kZWZpbmVkKG9iaikpIHtcbiAgICB0cnkge1xuICAgICAgZmluZFZhbHVlKG9iaiwgb3B0aW9ucy5zdWJEb2NQYXRoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5tZXNzYWdlID0gZXJyLm1lc3NhZ2UucmVwbGFjZSgnSlNPTiBQb2ludGVyJywgJ29wdGlvbnMuc3ViRG9jUGF0aCcpO1xuXG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIF9kZWNvZGVQYXRoIChwYXRoKSB7XG4gIGlmICghXy5pc0FycmF5KHBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gIH1cblxuICByZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24gKHNlZykge1xuICAgIGlmICghXy5pc1N0cmluZyhzZWcpKSB7XG4gICAgICBzZWcgPSBKU09OLnN0cmluZ2lmeShzZWcpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWcucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gX2VuY29kZVBhdGggKHBhdGgpIHtcbiAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXRoIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfVxuXG4gIHJldHVybiBwYXRoLm1hcChmdW5jdGlvbiAoc2VnKSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHNlZykpIHtcbiAgICAgIHNlZyA9IEpTT04uc3RyaW5naWZ5KHNlZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlZy5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIF9maW5kUmVmcyAob2JqLCBvcHRpb25zKSB7XG4gIHZhciByZWZzID0ge307XG5cbiAgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIGRvY3VtZW50XG4gIGlmICghXy5pc0FycmF5KG9iaikgJiYgIV8uaXNPYmplY3Qob2JqKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29iaiBtdXN0IGJlIGFuIEFycmF5IG9yIGFuIE9iamVjdCcpO1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgb3B0aW9uc1xuICBvcHRpb25zID0gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMsIG9iaik7XG5cbiAgLy8gV2FsayB0aGUgZG9jdW1lbnQgKG9yIHN1YiBkb2N1bWVudCkgYW5kIGZpbmQgYWxsIEpTT04gUmVmZXJlbmNlc1xuICB3YWxrKGZpbmRBbmNlc3RvcnMob2JqLCBvcHRpb25zLnN1YkRvY1BhdGgpLFxuICAgICAgIGZpbmRWYWx1ZShvYmosIG9wdGlvbnMuc3ViRG9jUGF0aCksXG4gICAgICAgXy5jbG9uZURlZXAob3B0aW9ucy5zdWJEb2NQYXRoKSxcbiAgICAgICBmdW5jdGlvbiAoYW5jZXN0b3JzLCBub2RlLCBwYXRoKSB7XG4gICAgICAgICB2YXIgcHJvY2Vzc0NoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgIHZhciByZWZEZXRhaWxzO1xuICAgICAgICAgdmFyIHJlZlB0cjtcblxuICAgICAgICAgaWYgKGlzUmVmTGlrZShub2RlKSkge1xuICAgICAgICAgICAvLyBQcmUtcHJvY2VzcyB0aGUgbm9kZSB3aGVuIG5lY2Vzc2FyeVxuICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5yZWZQcmVQcm9jZXNzb3IpKSB7XG4gICAgICAgICAgICAgbm9kZSA9IG9wdGlvbnMucmVmUHJlUHJvY2Vzc29yKF8uY2xvbmVEZWVwKG5vZGUpLCBwYXRoKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIHJlZkRldGFpbHMgPSBfZ2V0UmVmRGV0YWlscyhub2RlKTtcblxuICAgICAgICAgICAvLyBQb3N0LXByb2Nlc3MgdGhlIHJlZmVyZW5jZSBkZXRhaWxzXG4gICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChvcHRpb25zLnJlZlBvc3RQcm9jZXNzb3IpKSB7XG4gICAgICAgICAgICAgcmVmRGV0YWlscyA9IG9wdGlvbnMucmVmUG9zdFByb2Nlc3NvcihyZWZEZXRhaWxzLCBwYXRoKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlcihyZWZEZXRhaWxzLCBwYXRoKSkge1xuICAgICAgICAgICAgIHJlZlB0ciA9IF9wYXRoVG9QdHIocGF0aCk7XG5cbiAgICAgICAgICAgICByZWZzW3JlZlB0cl0gPSByZWZEZXRhaWxzO1xuICAgICAgICAgICB9XG5cbiAgICAgICAgICAgLy8gV2hlbmV2ZXIgYSBKU09OIFJlZmVyZW5jZSBoYXMgZXh0cmEgY2hpbGRyZW4sIGl0cyBjaGlsZHJlbiBzaG91bGQgbm90IGJlIHByb2Nlc3NlZC5cbiAgICAgICAgICAgLy8gICBTZWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBicnlhbi16eXAtanNvbi1yZWYtMDMjc2VjdGlvbi0zXG4gICAgICAgICAgIGlmIChnZXRFeHRyYVJlZktleXMobm9kZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgIHByb2Nlc3NDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAgICB9XG4gICAgICAgICB9XG5cbiAgICAgICAgIHJldHVybiBwcm9jZXNzQ2hpbGRyZW47XG4gICAgICAgfSk7XG5cbiAgcmV0dXJuIHJlZnM7XG59XG5cbmZ1bmN0aW9uIF9maW5kUmVmc0F0IChsb2NhdGlvbiwgb3B0aW9ucykge1xuICB2YXIgYWxsVGFza3MgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICBhbGxUYXNrcyA9IGFsbFRhc2tzXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIGxvY2F0aW9uXG4gICAgICBpZiAoIV8uaXNTdHJpbmcobG9jYXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xvY2F0aW9uIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQob3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAvLyBBZGQgdGhlIGxvY2F0aW9uIHRvIHRoZSBvcHRpb25zIGZvciBwcm9jZXNzaW5nL3ZhbGlkYXRpb25cbiAgICAgICAgb3B0aW9ucy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSBvcHRpb25zXG4gICAgICBvcHRpb25zID0gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gZ2V0UmVtb3RlRG9jdW1lbnQob3B0aW9ucy5sb2NhdGlvbiwgb3B0aW9ucyk7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICB2YXIgY2FjaGVFbnRyeSA9IF8uY2xvbmVEZWVwKHJlbW90ZUNhY2hlW29wdGlvbnMubG9jYXRpb25dKTtcbiAgICAgIHZhciBjT3B0aW9ucyA9IF8uY2xvbmVEZWVwKG9wdGlvbnMpO1xuICAgICAgdmFyIHVyaURldGFpbHMgPSBwYXJzZVVSSShvcHRpb25zLmxvY2F0aW9uKTtcblxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoY2FjaGVFbnRyeS5yZWZzKSkge1xuICAgICAgICAvLyBEbyBub3QgZmlsdGVyIGFueSByZWZlcmVuY2VzIHNvIHRoZSBjYWNoZSBpcyBjb21wbGV0ZVxuICAgICAgICBkZWxldGUgY09wdGlvbnMuZmlsdGVyO1xuICAgICAgICBkZWxldGUgY09wdGlvbnMuc3ViRG9jUGF0aDtcblxuICAgICAgICBjT3B0aW9ucy5pbmNsdWRlSW52YWxpZCA9IHRydWU7XG5cbiAgICAgICAgcmVtb3RlQ2FjaGVbb3B0aW9ucy5sb2NhdGlvbl0ucmVmcyA9IF9maW5kUmVmcyhyZXMsIGNPcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoZSBmaWx0ZXIgb3B0aW9ucyBiYWNrXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQob3B0aW9ucy5maWx0ZXIpKSB7XG4gICAgICAgIGNPcHRpb25zLmZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV8uaXNVbmRlZmluZWQodXJpRGV0YWlscy5mcmFnbWVudCkpIHtcbiAgICAgICAgY09wdGlvbnMuc3ViRG9jUGF0aCA9IF9wYXRoRnJvbVB0cihkZWNvZGVVUkkodXJpRGV0YWlscy5mcmFnbWVudCkpO1xuICAgICAgfSBlbHNlIGlmICghXy5pc1VuZGVmaW5lZCh1cmlEZXRhaWxzLnN1YkRvY1BhdGgpKSB7XG4gICAgICAgIGNPcHRpb25zLnN1YkRvY1BhdGggPSBvcHRpb25zLnN1YkRvY1BhdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgd2lsbCB1c2UgdGhlIGNhY2hlIHNvIGRvbid0IHdvcnJ5IGFib3V0IGNhbGxpbmcgaXQgdHdpY2VcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZnM6IF9maW5kUmVmcyhyZXMsIGNPcHRpb25zKSxcbiAgICAgICAgdmFsdWU6IHJlc1xuICAgICAgfTtcbiAgICB9KTtcblxuICByZXR1cm4gYWxsVGFza3M7XG59XG5cbmZ1bmN0aW9uIF9nZXRSZWZEZXRhaWxzIChvYmopIHtcbiAgdmFyIGRldGFpbHMgPSB7XG4gICAgZGVmOiBvYmpcbiAgfTtcbiAgdmFyIGNhY2hlS2V5O1xuICB2YXIgZXh0cmFLZXlzO1xuICB2YXIgdXJpRGV0YWlscztcblxuICB0cnkge1xuICAgIGlmIChpc1JlZkxpa2Uob2JqLCB0cnVlKSkge1xuICAgICAgY2FjaGVLZXkgPSBvYmouJHJlZjtcbiAgICAgIHVyaURldGFpbHMgPSB1cmlEZXRhaWxzQ2FjaGVbY2FjaGVLZXldO1xuXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZCh1cmlEZXRhaWxzKSkge1xuICAgICAgICB1cmlEZXRhaWxzID0gdXJpRGV0YWlsc0NhY2hlW2NhY2hlS2V5XSA9IHBhcnNlVVJJKGNhY2hlS2V5KTtcbiAgICAgIH1cblxuICAgICAgZGV0YWlscy51cmkgPSBjYWNoZUtleTtcbiAgICAgIGRldGFpbHMudXJpRGV0YWlscyA9IHVyaURldGFpbHM7XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHVyaURldGFpbHMuZXJyb3IpKSB7XG4gICAgICAgIGRldGFpbHMudHlwZSA9IGdldFJlZlR5cGUoZGV0YWlscyk7XG5cbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIEpTT04gUG9pbnRlclxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChbJyMnLCAnLyddLmluZGV4T2YoY2FjaGVLZXlbMF0pID4gLTEpIHtcbiAgICAgICAgICAgIF9pc1B0cihjYWNoZUtleSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjYWNoZUtleS5pbmRleE9mKCcjJykgPiAtMSkge1xuICAgICAgICAgICAgX2lzUHRyKHVyaURldGFpbHMuZnJhZ21lbnQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgZGV0YWlscy5lcnJvciA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgIGRldGFpbHMudHlwZSA9ICdpbnZhbGlkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGV0YWlscy5lcnJvciA9IGRldGFpbHMudXJpRGV0YWlscy5lcnJvcjtcbiAgICAgICAgZGV0YWlscy50eXBlID0gJ2ludmFsaWQnO1xuICAgICAgfVxuXG4gICAgICAvLyBJZGVudGlmeSB3YXJuaW5nXG4gICAgICBleHRyYUtleXMgPSBnZXRFeHRyYVJlZktleXMob2JqKTtcblxuICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRldGFpbHMud2FybmluZyA9ICdFeHRyYSBKU09OIFJlZmVyZW5jZSBwcm9wZXJ0aWVzIHdpbGwgYmUgaWdub3JlZDogJyArIGV4dHJhS2V5cy5qb2luKCcsICcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhaWxzLnR5cGUgPSAnaW52YWxpZCc7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZXRhaWxzLmVycm9yID0gZXJyLm1lc3NhZ2U7XG4gICAgZGV0YWlscy50eXBlID0gJ2ludmFsaWQnO1xuICB9XG5cbiAgcmV0dXJuIGRldGFpbHM7XG59XG5cbmZ1bmN0aW9uIF9pc1B0ciAocHRyLCB0aHJvd1dpdGhEZXRhaWxzKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBmaXJzdENoYXI7XG5cbiAgdHJ5IHtcbiAgICBpZiAoXy5pc1N0cmluZyhwdHIpKSB7XG4gICAgICBpZiAocHRyICE9PSAnJykge1xuICAgICAgICBmaXJzdENoYXIgPSBwdHIuY2hhckF0KDApO1xuXG4gICAgICAgIGlmIChbJyMnLCAnLyddLmluZGV4T2YoZmlyc3RDaGFyKSA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3B0ciBtdXN0IHN0YXJ0IHdpdGggYSAvIG9yICMvJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGFyID09PSAnIycgJiYgcHRyICE9PSAnIycgJiYgcHRyLmNoYXJBdCgxKSAhPT0gJy8nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdHIgbXVzdCBzdGFydCB3aXRoIGEgLyBvciAjLycpO1xuICAgICAgICB9IGVsc2UgaWYgKHB0ci5tYXRjaChiYWRQdHJUb2tlblJlZ2V4KSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHRyIGhhcyBpbnZhbGlkIHRva2VuKHMpJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdHIgaXMgbm90IGEgU3RyaW5nJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodGhyb3dXaXRoRGV0YWlscyA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdmFsaWQ7XG59XG5cbmZ1bmN0aW9uIF9pc1JlZiAob2JqLCB0aHJvd1dpdGhEZXRhaWxzKSB7XG4gIHJldHVybiBpc1JlZkxpa2Uob2JqLCB0aHJvd1dpdGhEZXRhaWxzKSAmJiBfZ2V0UmVmRGV0YWlscyhvYmosIHRocm93V2l0aERldGFpbHMpLnR5cGUgIT09ICdpbnZhbGlkJztcbn1cblxuZnVuY3Rpb24gX3BhdGhGcm9tUHRyIChwdHIpIHtcbiAgdHJ5IHtcbiAgICBfaXNQdHIocHRyLCB0cnVlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwdHIgbXVzdCBiZSBhIEpTT04gUG9pbnRlcjogJyArIGVyci5tZXNzYWdlKTtcbiAgfVxuXG4gIHZhciBzZWdtZW50cyA9IHB0ci5zcGxpdCgnLycpO1xuXG4gIC8vIFJlbW92ZSB0aGUgZmlyc3Qgc2VnbWVudFxuICBzZWdtZW50cy5zaGlmdCgpO1xuXG4gIHJldHVybiBfZGVjb2RlUGF0aChzZWdtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9wYXRoVG9QdHIgKHBhdGgsIGhhc2hQcmVmaXgpIHtcbiAgaWYgKCFfLmlzQXJyYXkocGF0aCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhdGggbXVzdCBiZSBhbiBBcnJheScpO1xuICB9XG5cbiAgLy8gRW5jb2RlIGVhY2ggc2VnbWVudCBhbmQgcmV0dXJuXG4gIHJldHVybiAoaGFzaFByZWZpeCAhPT0gZmFsc2UgPyAnIycgOiAnJykgKyAocGF0aC5sZW5ndGggPiAwID8gJy8nIDogJycpICsgX2VuY29kZVBhdGgocGF0aCkuam9pbignLycpO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVJlZnMgKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYWxsVGFza3MgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICBhbGxUYXNrcyA9IGFsbFRhc2tzXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIGRvY3VtZW50XG4gICAgICBpZiAoIV8uaXNBcnJheShvYmopICYmICFfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2JqIG11c3QgYmUgYW4gQXJyYXkgb3IgYW4gT2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZhbGlkYXRlIG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgPSB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucywgb2JqKTtcblxuICAgICAgLy8gQ2xvbmUgdGhlIGlucHV0IHNvIHdlIGRvIG5vdCBhbHRlciBpdFxuICAgICAgb2JqID0gXy5jbG9uZURlZXAob2JqKTtcbiAgICB9KVxuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtZXRhZGF0YSA9IHtcbiAgICAgICAgZGVwczoge30sIC8vIFRvIGF2b2lkIHByb2Nlc3NpbmcgdGhlIHNhbWUgcmVmZXJuZWNlIHR3aWNlLCBhbmQgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZSBpZGVudGlmaWNhdGlvblxuICAgICAgICBkb2NzOiB7fSwgLy8gQ2FjaGUgdG8gYXZvaWQgcHJvY2Vzc2luZyB0aGUgc2FtZSBkb2N1bWVudCBtb3JlIHRoYW4gb25jZVxuICAgICAgICByZWZzOiB7fSAvLyBSZWZlcmVuY2UgbG9jYXRpb25zIGFuZCB0aGVpciBtZXRhZGF0YVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGJ1aWxkUmVmTW9kZWwob2JqLCBvcHRpb25zLCBtZXRhZGF0YSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgdmFyIGFsbFJlZnMgPSB7fTtcbiAgICAgIHZhciBjaXJjdWxhclBhdGhzID0gW107XG4gICAgICB2YXIgY2lyY3VsYXJzID0gW107XG4gICAgICB2YXIgZGVwR3JhcGggPSBuZXcgZ2wuR3JhcGgoKTtcbiAgICAgIHZhciBmdWxsTG9jYXRpb24gPSBtYWtlQWJzb2x1dGUob3B0aW9ucy5sb2NhdGlvbik7XG4gICAgICB2YXIgcmVmc1Jvb3QgPSBmdWxsTG9jYXRpb24gKyBfcGF0aFRvUHRyKG9wdGlvbnMuc3ViRG9jUGF0aCk7XG4gICAgICB2YXIgcmVsYXRpdmVCYXNlID0gcGF0aC5kaXJuYW1lKGZ1bGxMb2NhdGlvbik7XG5cbiAgICAgIC8vIElkZW50aWZ5IGNpcmN1bGFyc1xuXG4gICAgICAvLyBBZGQgbm9kZXMgZmlyc3RcbiAgICAgIE9iamVjdC5rZXlzKHJlc3VsdHMuZGVwcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBkZXBHcmFwaC5zZXROb2RlKG5vZGUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCBlZGdlc1xuICAgICAgXy5mb3JPd24ocmVzdWx0cy5kZXBzLCBmdW5jdGlvbiAocHJvcHMsIG5vZGUpIHtcbiAgICAgICAgXy5mb3JPd24ocHJvcHMsIGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICBkZXBHcmFwaC5zZXRFZGdlKG5vZGUsIGRlcCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNpcmN1bGFyUGF0aHMgPSBnbC5hbGcuZmluZEN5Y2xlcyhkZXBHcmFwaCk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBsaXN0IG9mIGNpcmN1bGFyc1xuICAgICAgY2lyY3VsYXJQYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHBhdGguZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XG4gICAgICAgICAgaWYgKGNpcmN1bGFycy5pbmRleE9mKHNlZykgPT09IC0xKSB7XG4gICAgICAgICAgICBjaXJjdWxhcnMucHVzaChzZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSWRlbnRpZnkgY2lyY3VsYXJzXG4gICAgICBfLmZvck93bihyZXN1bHRzLmRlcHMsIGZ1bmN0aW9uIChwcm9wcywgbm9kZSkge1xuICAgICAgICBfLmZvck93bihwcm9wcywgZnVuY3Rpb24gKGRlcCwgcHJvcCkge1xuICAgICAgICAgIHZhciBpc0NpcmN1bGFyID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHJlZlB0ciA9IG5vZGUgKyBwcm9wLnNsaWNlKDEpO1xuICAgICAgICAgIHZhciByZWZEZXRhaWxzID0gcmVzdWx0cy5yZWZzW25vZGUgKyBwcm9wLnNsaWNlKDEpXTtcbiAgICAgICAgICB2YXIgcmVtb3RlID0gaXNSZW1vdGUocmVmRGV0YWlscyk7XG4gICAgICAgICAgdmFyIHBhdGhJbmRleDtcblxuICAgICAgICAgIGlmIChjaXJjdWxhcnMuaW5kZXhPZihkZXApID4gLTEpIHtcbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgdGhlIGNpcmN1bGFyIGlzIHBhcnQgb2YgYSBjaXJjdWxhciBjaGFpbiBvciBqdXN0IGEgcmVmZXJlbmNlIHRvIGEgY2lyY3VsYXJcbiAgICAgICAgICAgIGNpcmN1bGFyUGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgICAvLyBTaG9ydCBjaXJjdWl0XG4gICAgICAgICAgICAgIGlmIChpc0NpcmN1bGFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGF0aEluZGV4ID0gcGF0aC5pbmRleE9mKGRlcCk7XG5cbiAgICAgICAgICAgICAgaWYgKHBhdGhJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBwYXRoIHNlZ21lbnQgdG8gc2VlIGlmIHRoZSByZWZlcmVuY2UgbG9jYXRpb24gaXMgYmVuZWF0aCBvbmUgb2YgaXRzIHNlZ21lbnRzXG4gICAgICAgICAgICAgICAgcGF0aC5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFNob3J0IGNpcmN1aXRcbiAgICAgICAgICAgICAgICAgIGlmIChpc0NpcmN1bGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKHJlZlB0ci5pbmRleE9mKHNlZyArICcvJykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBsb2NhbCwgbWFyayBpdCBhcyBjaXJjdWxhciBidXQgaWYgaXQncyBhIHJlbW90ZSByZWZlcmVuY2UsIG9ubHkgbWFyayBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBjaXJjdWxhciBpZiB0aGUgbWF0Y2hpbmcgcGF0aCBpcyB0aGUgbGFzdCBwYXRoIHNlZ21lbnQgb3IgaXRzIG1hdGNoIGlzIG5vdCB0byBhIGRvY3VtZW50IHJvb3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZW1vdGUgfHwgcGF0aEluZGV4ID09PSBwYXRoLmxlbmd0aCAtIDEgfHwgZGVwW2RlcC5sZW5ndGggLSAxXSAhPT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXNDaXJjdWxhciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGlzQ2lyY3VsYXIpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgcmVmZXJlbmNlcyBhbmQgcmVmZXJlbmNlIGRldGFpbHNcbiAgICAgICAgICAgIHJlZkRldGFpbHMuY2lyY3VsYXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVzb2x2ZSB0aGUgcmVmZXJlbmNlcyBpbiByZXZlcnNlIG9yZGVyIHNpbmNlIHRoZSBjdXJyZW50IG9yZGVyIGlzIHRvcC1kb3duXG4gICAgICBfLmZvck93bihPYmplY3Qua2V5cyhyZXN1bHRzLmRlcHMpLnJldmVyc2UoKSwgZnVuY3Rpb24gKHBhcmVudFB0cikge1xuICAgICAgICB2YXIgZGVwcyA9IHJlc3VsdHMuZGVwc1twYXJlbnRQdHJdO1xuICAgICAgICB2YXIgcFB0clBhcnRzID0gcGFyZW50UHRyLnNwbGl0KCcjJyk7XG4gICAgICAgIHZhciBwRG9jdW1lbnQgPSByZXN1bHRzLmRvY3NbcFB0clBhcnRzWzBdXTtcbiAgICAgICAgdmFyIHBQdHJQYXRoID0gX3BhdGhGcm9tUHRyKHBQdHJQYXJ0c1sxXSk7XG5cbiAgICAgICAgXy5mb3JPd24oZGVwcywgZnVuY3Rpb24gKGRlcCwgcHJvcCkge1xuICAgICAgICAgIHZhciBkZXBQYXJ0cyA9IGRlcC5zcGxpdCgnIycpO1xuICAgICAgICAgIHZhciBkRG9jdW1lbnQgPSByZXN1bHRzLmRvY3NbZGVwUGFydHNbMF1dO1xuICAgICAgICAgIHZhciBkUHRyUGF0aCA9IHBQdHJQYXRoLmNvbmNhdChfcGF0aEZyb21QdHIocHJvcCkpO1xuICAgICAgICAgIHZhciByZWZEZXRhaWxzID0gcmVzdWx0cy5yZWZzW3BQdHJQYXJ0c1swXSArIF9wYXRoVG9QdHIoZFB0clBhdGgpXTtcblxuICAgICAgICAgIC8vIFJlc29sdmUgcmVmZXJlbmNlIGlmIHZhbGlkXG4gICAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQocmVmRGV0YWlscy5lcnJvcikgJiYgXy5pc1VuZGVmaW5lZChyZWZEZXRhaWxzLm1pc3NpbmcpKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMucmVzb2x2ZUNpcmN1bGFycyAmJiByZWZEZXRhaWxzLmNpcmN1bGFyKSB7XG4gICAgICAgICAgICAgIHJlZkRldGFpbHMudmFsdWUgPSByZWZEZXRhaWxzLmRlZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVmRGV0YWlscy52YWx1ZSA9IGZpbmRWYWx1ZShkRG9jdW1lbnQsIF9wYXRoRnJvbVB0cihkZXBQYXJ0c1sxXSkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBtYXJrTWlzc2luZyhyZWZEZXRhaWxzLCBlcnIpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBpcyBhdCB0aGUgcm9vdCBvZiB0aGUgZG9jdW1lbnQsIHJlcGxhY2UgdGhlIGRvY3VtZW50IGluIHRoZSBjYWNoZS4gIE90aGVyd2lzZSwgcmVwbGFjZVxuICAgICAgICAgICAgICAvLyB0aGUgdmFsdWUgaW4gdGhlIGFwcHJvcHJpYXRlIGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudCBjYWNoZS5cbiAgICAgICAgICAgICAgaWYgKHBQdHJQYXJ0c1sxXSA9PT0gJycgJiYgcHJvcCA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5kb2NzW3BQdHJQYXJ0c1swXV0gPSByZWZEZXRhaWxzLnZhbHVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFZhbHVlKHBEb2N1bWVudCwgZFB0clBhdGgsIHJlZkRldGFpbHMudmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiB3YWxrUmVmcyAocm9vdCwgcmVmUHRyLCByZWZQYXRoKSB7XG4gICAgICAgIHZhciByZWZQdHJQYXJ0cyA9IHJlZlB0ci5zcGxpdCgnIycpO1xuICAgICAgICB2YXIgcmVmRGV0YWlscyA9IHJlc3VsdHMucmVmc1tyZWZQdHJdO1xuICAgICAgICB2YXIgcmVmRGVwcztcblxuICAgICAgICAvLyBSZWNvcmQgdGhlIHJlZmVyZW5jZSAocmVsYXRpdmUgdG8gdGhlIHJvb3QgZG9jdW1lbnQgdW5sZXNzIHRoZSByZWZlcmVuY2UgaXMgaW4gdGhlIHJvb3QgZG9jdW1lbnQpXG4gICAgICAgIGFsbFJlZnNbcmVmUHRyUGFydHNbMF0gPT09IG9wdGlvbnMubG9jYXRpb24gP1xuICAgICAgICAgICAgICAgICAgJyMnICsgcmVmUHRyUGFydHNbMV0gOlxuICAgICAgICAgICAgICAgICAgX3BhdGhUb1B0cihvcHRpb25zLnN1YkRvY1BhdGguY29uY2F0KHJlZlBhdGgpKV0gPSByZWZEZXRhaWxzO1xuXG4gICAgICAgIC8vIERvIG5vdCB3YWxrIGludmFsaWQgcmVmZXJlbmNlc1xuICAgICAgICBpZiAocmVmRGV0YWlscy5jaXJjdWxhciB8fCAhaXNWYWxpZChyZWZEZXRhaWxzKSkge1xuICAgICAgICAgIC8vIFNhbml0aXplIGVycm9yc1xuICAgICAgICAgIGlmICghcmVmRGV0YWlscy5jaXJjdWxhciAmJiByZWZEZXRhaWxzLmVycm9yKSB7XG4gICAgICAgICAgICAvLyBUaGUgd2F5IHdlIHVzZSBmaW5kUmVmcyBub3cgcmVzdWx0cyBpbiBhbiBlcnJvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIGV4cGVjdGF0aW9uXG4gICAgICAgICAgICByZWZEZXRhaWxzLmVycm9yID0gcmVmRGV0YWlscy5lcnJvci5yZXBsYWNlKCdvcHRpb25zLnN1YkRvY1BhdGgnLCAnSlNPTiBQb2ludGVyJyk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZXJyb3IgdG8gdXNlIHRoZSBhcHByb3ByaWF0ZSBKU09OIFBvaW50ZXJcbiAgICAgICAgICAgIGlmIChyZWZEZXRhaWxzLmVycm9yLmluZGV4T2YoJyMnKSA+IC0xKSB7XG4gICAgICAgICAgICAgIHJlZkRldGFpbHMuZXJyb3IgPSByZWZEZXRhaWxzLmVycm9yLnJlcGxhY2UocmVmRGV0YWlscy51cmkuc3Vic3RyKHJlZkRldGFpbHMudXJpLmluZGV4T2YoJyMnKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmRGV0YWlscy51cmkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXBvcnQgZXJyb3JzIG9wZW5pbmcgZmlsZXMgYXMgSlNPTiBQb2ludGVyIGVycm9yc1xuICAgICAgICAgICAgaWYgKHJlZkRldGFpbHMuZXJyb3IuaW5kZXhPZignRU5PRU5UOicpID09PSAwIHx8IHJlZkRldGFpbHMuZXJyb3IuaW5kZXhPZignTm90IEZvdW5kJykgPT09IDApIHtcbiAgICAgICAgICAgICAgcmVmRGV0YWlscy5lcnJvciA9ICdKU09OIFBvaW50ZXIgcG9pbnRzIHRvIG1pc3NpbmcgbG9jYXRpb246ICcgKyByZWZEZXRhaWxzLnVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZWZEZXBzID0gcmVzdWx0cy5kZXBzW3JlZkRldGFpbHMucmVmZElkXTtcblxuICAgICAgICBpZiAocmVmRGV0YWlscy5yZWZkSWQuaW5kZXhPZihyb290KSAhPT0gMCkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHJlZkRlcHMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHdhbGtSZWZzKHJlZkRldGFpbHMucmVmZElkLCByZWZEZXRhaWxzLnJlZmRJZCArIHByb3Auc3Vic3RyKDEpLCByZWZQYXRoLmNvbmNhdChfcGF0aEZyb21QdHIocHJvcCkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2Ugb25seSBwcm9jZXNzIGEgZG9jdW1lbnQgKG9yIHN1YiBkb2N1bWVudCkgYW5kIGVhY2ggcmVmZXJlbmNlIG9uY2UgZXZlci4gIFRoaXMgbWVhbnNcbiAgICAgIC8vIHRoYXQgaWYgd2Ugd2FudCB0byBwcm92aWRlIHRoZSBmdWxsIHBpY3R1cmUgYXMgdG8gd2hhdCBwYXRocyBpbiB0aGUgcmVzb2x2ZWQgZG9jdW1lbnQgd2VyZSBjcmVhdGVkIGFzIGEgcmVzdWx0XG4gICAgICAvLyBvZiBhIHJlZmVyZW5jZSwgd2UgaGF2ZSB0byB0YWtlIG91ciBmdWxseS1xdWFsaWZpZWQgcmVmZXJlbmNlIGxvY2F0aW9ucyBhbmQgZXhwYW5kIHRoZW0gdG8gYmUgYWxsIGxvY2FsIGJhc2VkXG4gICAgICAvLyBvbiB0aGUgb3JpZ2luYWwgZG9jdW1lbnQuXG4gICAgICBPYmplY3Qua2V5cyhyZXN1bHRzLnJlZnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZlB0cikge1xuICAgICAgICB2YXIgcmVmRGV0YWlscyA9IHJlc3VsdHMucmVmc1tyZWZQdHJdO1xuICAgICAgICB2YXIgZnFVUklTZWdtZW50cztcbiAgICAgICAgdmFyIHVyaVNlZ21lbnRzO1xuXG4gICAgICAgIC8vIE1ha2UgYWxsIGZ1bGx5LXF1YWxpZmllZCByZWZlcmVuY2UgVVJJcyByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgcm9vdCAoaWYgbmVjZXNzYXJ5KS4gIFRoaXMgc3RlcCBpcyBkb25lIGhlcmVcbiAgICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgaW5zdGVhZCBvZiBiZWxvdyB3aGVuIHRoZSBvZmZpY2lhbCBzYW5pdGl6YXRpb24gcHJvY2VzcyBydW5zLlxuICAgICAgICBpZiAocmVmRGV0YWlscy50eXBlICE9PSAnaW52YWxpZCcpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRyYWlsaW5nIGhhc2ggZnJvbSBkb2N1bWVudCByb290IHJlZmVyZW5jZXMgaWYgdGhleSB3ZXJlbid0IGluIHRoZSBvcmlnaW5hbCBVUklcbiAgICAgICAgICBpZiAocmVmRGV0YWlscy5mcVVSSVtyZWZEZXRhaWxzLmZxVVJJLmxlbmd0aCAtIDFdID09PSAnIycgJiZcbiAgICAgICAgICAgICAgICByZWZEZXRhaWxzLnVyaVtyZWZEZXRhaWxzLnVyaS5sZW5ndGggLSAxXSAhPT0gJyMnKSB7XG4gICAgICAgICAgICByZWZEZXRhaWxzLmZxVVJJID0gcmVmRGV0YWlscy5mcVVSSS5zdWJzdHIoMCwgcmVmRGV0YWlscy5mcVVSSS5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmcVVSSVNlZ21lbnRzID0gcmVmRGV0YWlscy5mcVVSSS5zcGxpdCgnLycpO1xuICAgICAgICAgIHVyaVNlZ21lbnRzID0gcmVmRGV0YWlscy51cmkuc3BsaXQoJy8nKTtcblxuICAgICAgICAgIC8vIFRoZSBmdWxseS1xdWFsaWZpZWQgVVJJIGlzIHVuZW5jb2RlZCBzbyB0byBrZWVwIHRoZSBvcmlnaW5hbCBmb3JtYXR0aW5nIG9mIHRoZSBVUkkgKGVuY29kZWQgdnMuIHVuZW5jb2RlZCksXG4gICAgICAgICAgLy8gd2UgbmVlZCB0byByZXBsYWNlIGVhY2ggVVJJIHNlZ21lbnQgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgICAgICBfLnRpbWVzKHVyaVNlZ21lbnRzLmxlbmd0aCAtIDEsIGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgblNlZyA9IHVyaVNlZ21lbnRzW3VyaVNlZ21lbnRzLmxlbmd0aCAtIHRpbWUgLSAxXTtcbiAgICAgICAgICAgIHZhciBmcVNlZ0luZGV4ID0gZnFVUklTZWdtZW50cy5sZW5ndGggLSB0aW1lIC0gMTtcbiAgICAgICAgICAgIHZhciBmcVNlZyA9IGZxVVJJU2VnbWVudHNbZnFTZWdJbmRleF07XG5cbiAgICAgICAgICAgIGlmIChuU2VnID09PSAnLicgfHwgblNlZyA9PT0gJy4uJykge1xuICAgICAgICAgICAgICBuU2VnID0gZnFTZWc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZxVVJJU2VnbWVudHNbZnFTZWdJbmRleF0gPSBuU2VnO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVmRGV0YWlscy5mcVVSSSA9IGZxVVJJU2VnbWVudHMuam9pbignLycpO1xuXG4gICAgICAgICAgLy8gTWFrZSB0aGUgZnVsbHktcXVhbGlmaWVkIFVSSXMgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50IHJvb3RcbiAgICAgICAgICBpZiAocmVmRGV0YWlscy5mcVVSSS5pbmRleE9mKGZ1bGxMb2NhdGlvbikgPT09IDApIHtcbiAgICAgICAgICAgIHJlZkRldGFpbHMuZnFVUkkgPSByZWZEZXRhaWxzLmZxVVJJLnJlcGxhY2UoZnVsbExvY2F0aW9uLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZWZEZXRhaWxzLmZxVVJJLmluZGV4T2YocmVsYXRpdmVCYXNlKSA9PT0gMCkge1xuICAgICAgICAgICAgcmVmRGV0YWlscy5mcVVSSSA9IHJlZkRldGFpbHMuZnFVUkkucmVwbGFjZShyZWxhdGl2ZUJhc2UsICcnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVmRGV0YWlscy5mcVVSSVswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICByZWZEZXRhaWxzLmZxVVJJID0gJy4nICsgcmVmRGV0YWlscy5mcVVSSTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gcHJvY2VzcyByZWZlcmVuY2VzIGZvdW5kIGF0IG9yIGJlbmVhdGggdGhlIHByb3ZpZGVkIGRvY3VtZW50IGFuZCBzdWItZG9jdW1lbnQgcGF0aFxuICAgICAgICBpZiAocmVmUHRyLmluZGV4T2YocmVmc1Jvb3QpICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgd2Fsa1JlZnMocmVmc1Jvb3QsIHJlZlB0ciwgX3BhdGhGcm9tUHRyKHJlZlB0ci5zdWJzdHIocmVmc1Jvb3QubGVuZ3RoKSkpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNhbml0aXplIHRoZSByZWZlcmVuY2UgZGV0YWlsc1xuICAgICAgXy5mb3JPd24ocmVzdWx0cy5yZWZzLCBmdW5jdGlvbiAocmVmRGV0YWlscykge1xuICAgICAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBpZCB1c2VkIGZvciBkZXBlbmRlbmN5IHRyYWNraW5nIGFuZCBjaXJjdWxhciBpZGVudGlmaWNhdGlvblxuICAgICAgICBkZWxldGUgcmVmRGV0YWlscy5yZWZkSWQ7XG5cbiAgICAgICAgLy8gVG8gYXZvaWQgdGhlIGVycm9yIG1lc3NhZ2UgYmVpbmcgVVJJIGVuY29kZWQvZGVjb2RlZCBieSBtaXN0YWtlLCByZXBsYWNlIHRoZSBjdXJyZW50IEpTT04gUG9pbnRlciB3aXRoIHRoZVxuICAgICAgICAvLyB2YWx1ZSBpbiB0aGUgSlNPTiBSZWZlcmVuY2UgZGVmaW5pdGlvbi5cbiAgICAgICAgaWYgKHJlZkRldGFpbHMubWlzc2luZykge1xuICAgICAgICAgIHJlZkRldGFpbHMuZXJyb3IgPSByZWZEZXRhaWxzLmVycm9yLnNwbGl0KCc6ICcpWzBdICsgJzogJyArIHJlZkRldGFpbHMuZGVmLiRyZWY7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWZzOiBhbGxSZWZzLFxuICAgICAgICByZXNvbHZlZDogcmVzdWx0cy5kb2NzW2Z1bGxMb2NhdGlvbl1cbiAgICAgIH07XG4gICAgfSk7XG5cbiAgcmV0dXJuIGFsbFRhc2tzO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVJlZnNBdCAobG9jYXRpb24sIG9wdGlvbnMpIHtcbiAgdmFyIGFsbFRhc2tzID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgYWxsVGFza3MgPSBhbGxUYXNrc1xuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBsb2NhdGlvblxuICAgICAgaWYgKCFfLmlzU3RyaW5nKGxvY2F0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsb2NhdGlvbiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgLy8gQWRkIHRoZSBsb2NhdGlvbiB0byB0aGUgb3B0aW9ucyBmb3IgcHJvY2Vzc2luZy92YWxpZGF0aW9uXG4gICAgICAgIG9wdGlvbnMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgb3B0aW9uc1xuICAgICAgb3B0aW9ucyA9IHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcblxuICAgICAgcmV0dXJuIGdldFJlbW90ZURvY3VtZW50KG9wdGlvbnMubG9jYXRpb24sIG9wdGlvbnMpO1xuICAgIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgdmFyIGNPcHRpb25zID0gXy5jbG9uZURlZXAob3B0aW9ucyk7XG4gICAgICB2YXIgdXJpRGV0YWlscyA9IHBhcnNlVVJJKG9wdGlvbnMubG9jYXRpb24pO1xuXG4gICAgICAvLyBTZXQgdGhlIHN1YiBkb2N1bWVudCBwYXRoIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHVyaURldGFpbHMuZnJhZ21lbnQpKSB7XG4gICAgICAgIGNPcHRpb25zLnN1YkRvY1BhdGggPSBfcGF0aEZyb21QdHIoZGVjb2RlVVJJKHVyaURldGFpbHMuZnJhZ21lbnQpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZXNvbHZlUmVmcyhyZXMsIGNPcHRpb25zKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzMikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWZzOiByZXMyLnJlZnMsXG4gICAgICAgICAgICByZXNvbHZlZDogcmVzMi5yZXNvbHZlZCxcbiAgICAgICAgICAgIHZhbHVlOiByZXNcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICByZXR1cm4gYWxsVGFza3M7XG59XG5cbi8qKlxuICogVmFyaW91cyB1dGlsaXRpZXMgZm9yIEpTT04gUmVmZXJlbmNlcyAqKGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LXBicnlhbi16eXAtanNvbi1yZWYtMDMpKiBhbmRcbiAqIEpTT04gUG9pbnRlcnMgKihodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMSkqLlxuICpcbiAqIEBtb2R1bGUganNvbi1yZWZzXG4gKi9cblxuLyoqXG4gKiBBIG51bWJlciBvZiBmdW5jdGlvbnMgZXhwb3J0ZWQgYmVsb3cgYXJlIHVzZWQgd2l0aGluIHRoZSBleHBvcnRlZCBmdW5jdGlvbnMuICBUeXBpY2FsbHksIEkgd291bGQgdXNlIGEgZnVuY3Rpb25cbiAqIGRlY2xhcmF0aW9uIF8od2l0aCBkb2N1bWVuYXRpb24pXyBhYm92ZSBhbmQgdGhlbiBqdXN0IGV4cG9ydCBhIHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gYnV0IGR1ZSB0byBhIGJ1ZyBpbiBKU0RvY1xuICogKGh0dHBzOi8vZ2l0aHViLmNvbS9qc2RvYzMvanNkb2MvaXNzdWVzLzY3OSksIHRoaXMgYnJlYWtzIHRoZSBnZW5lcmF0ZWQgQVBJIGRvY3VtZW50YXRpb24gYW5kIFR5cGVTY3JpcHRcbiAqIGRlY2xhcmF0aW9ucy4gIFNvIHRoYXQncyB3aHkgZWFjaCBgbW9kdWxlLmV4cG9ydHNgIGJlbG93IGJhc2ljYWxseSBqdXN0IHdyYXBzIGEgY2FsbCB0byB0aGUgZnVuY3Rpb24gZGVjbGFyYXRpb24uXG4gKi9cblxuIC8qKlxuICogQ2xlYXJzIHRoZSBpbnRlcm5hbCBjYWNoZSBvZiByZW1vdGUgZG9jdW1lbnRzLCByZWZlcmVuY2UgZGV0YWlscywgZXRjLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDYWNoZSAoKSB7XG4gIHJlbW90ZUNhY2hlID0ge307XG59XG5cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgcGF0aCBzZWdtZW50cyBhbmQgZGVjb2RlcyB0aGUgSlNPTiBQb2ludGVyIHRva2VucyBpbiB0aGVtLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGggLSBUaGUgYXJyYXkgb2YgcGF0aCBzZWdtZW50c1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzIHdpdGggdGhlaXIgSlNPTiBQb2ludGVyIHRva2VucyBkZWNvZGVkXG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBwYXRoIGlzIG5vdCBhbiBgQXJyYXlgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjc2VjdGlvbi0zfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUGF0aCAocGF0aCkge1xuICByZXR1cm4gX2RlY29kZVBhdGgocGF0aCk7XG59XG5cbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgcGF0aCBzZWdtZW50cyBhbmQgZW5jb2RlcyB0aGUgc3BlY2lhbCBKU09OIFBvaW50ZXIgY2hhcmFjdGVycyBpbiB0aGVtLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGggLSBUaGUgYXJyYXkgb2YgcGF0aCBzZWdtZW50c1xuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBhcnJheSBvZiBwYXRoIHNlZ21lbnRzIHdpdGggdGhlaXIgSlNPTiBQb2ludGVyIHRva2VucyBlbmNvZGVkXG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBwYXRoIGlzIG5vdCBhbiBgQXJyYXlgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjc2VjdGlvbi0zfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUGF0aCAocGF0aCkge1xuICByZXR1cm4gX2VuY29kZVBhdGgocGF0aCk7XG59XG5cbi8qKlxuICogRmluZHMgSlNPTiBSZWZlcmVuY2VzIGRlZmluZWQgd2l0aGluIHRoZSBwcm92aWRlZCBhcnJheS9vYmplY3QuXG4gKlxuICogQHBhcmFtIHthcnJheXxvYmplY3R9IG9iaiAtIFRoZSBzdHJ1Y3R1cmUgdG8gZmluZCBKU09OIFJlZmVyZW5jZXMgd2l0aGluXG4gKiBAcGFyYW0ge21vZHVsZTpqc29uLXJlZnN+SnNvblJlZnNPcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgSnNvblJlZnMgb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtvYmplY3R9IGFuIG9iamVjdCB3aG9zZSBrZXlzIGFyZSBKU09OIFBvaW50ZXJzICooZnJhZ21lbnQgdmVyc2lvbikqIHRvIHdoZXJlIHRoZSBKU09OIFJlZmVyZW5jZSBpcyBkZWZpbmVkXG4gKiBhbmQgd2hvc2UgdmFsdWVzIGFyZSB7QGxpbmsgVW5yZXNvbHZlZFJlZkRldGFpbHN9LlxuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIHRoZSBpbnB1dCBhcmd1bWVudHMgZmFpbCB2YWxpZGF0aW9uIG9yIGlmIGBvcHRpb25zLnN1YkRvY1BhdGhgIHBvaW50cyB0byBhbiBpbnZhbGlkIGxvY2F0aW9uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEZpbmRpbmcgYWxsIHZhbGlkIHJlZmVyZW5jZXNcbiAqIHZhciBhbGxSZWZzID0gSnNvblJlZnMuZmluZFJlZnMob2JqKTtcbiAqIC8vIEZpbmRpbmcgYWxsIHJlbW90ZSByZWZlcmVuY2VzXG4gKiB2YXIgcmVtb3RlUmVmcyA9IEpzb25SZWZzLmZpbmRSZWZzKG9iaiwge2ZpbHRlcjogWydyZWxhdGl2ZScsICdyZW1vdGUnXX0pO1xuICogLy8gRmluZGluZyBhbGwgaW52YWxpZCByZWZlcmVuY2VzXG4gKiB2YXIgaW52YWxpZFJlZnMgPSBKc29uUmVmcy5maW5kUmVmcyhvYmosIHtmaWx0ZXI6ICdpbnZhbGlkJywgaW5jbHVkZUludmFsaWQ6IHRydWV9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRSZWZzIChvYmosIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9maW5kUmVmcyhvYmosIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEZpbmRzIEpTT04gUmVmZXJlbmNlcyBkZWZpbmVkIHdpdGhpbiB0aGUgZG9jdW1lbnQgYXQgdGhlIHByb3ZpZGVkIGxvY2F0aW9uLlxuICpcbiAqIFRoaXMgQVBJIGlzIGlkZW50aWNhbCB0byB7QGxpbmsgZmluZFJlZnN9IGV4Y2VwdCB0aGlzIEFQSSB3aWxsIHJldHJpZXZlIGEgcmVtb3RlIGRvY3VtZW50IGFuZCB0aGVuXG4gKiByZXR1cm4gdGhlIHJlc3VsdCBvZiB7QGxpbmsgZmluZFJlZnN9IG9uIHRoZSByZXRyaWV2ZWQgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIC0gVGhlIGxvY2F0aW9uIHRvIHJldHJpZXZlICooQ2FuIGJlIHJlbGF0aXZlIG9yIGFic29sdXRlLCBqdXN0IG1ha2Ugc3VyZSB5b3UgbG9vayBhdCB0aGVcbiAqIHtAbGluayBtb2R1bGU6anNvbi1yZWZzfkpzb25SZWZzT3B0aW9uc3xvcHRpb25zIGRvY3VtZW50YXRpb259IHRvIHNlZSBob3cgcmVsYXRpdmUgcmVmZXJlbmNlcyBhcmUgaGFuZGxlZC4pKlxuICogQHBhcmFtIHttb2R1bGU6anNvbi1yZWZzfkpzb25SZWZzT3B0aW9uc30gW29wdGlvbnNdIC0gVGhlIEpzb25SZWZzIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxtb2R1bGU6anNvbi1yZWZzflJldHJpZXZlZFJlZnNSZXN1bHRzPn0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYVxuICoge0BsaW5rIG1vZHVsZTpqc29uLXJlZnN+UmV0cmlldmVkUmVmc1Jlc3VsdHN9IGFuZCByZWplY3RzIHdpdGggYW4gYEVycm9yYCB3aGVuIHRoZSBpbnB1dCBhcmd1bWVudHMgZmFpbCB2YWxpZGF0aW9uLFxuICogd2hlbiBgb3B0aW9ucy5zdWJEb2NQYXRoYCBwb2ludHMgdG8gYW4gaW52YWxpZCBsb2NhdGlvbiBvciB3aGVuIHRoZSBsb2NhdGlvbiBhcmd1bWVudCBwb2ludHMgdG8gYW4gdW5sb2FkYWJsZVxuICogcmVzb3VyY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSB0aGF0IG9ubHkgcmVzb2x2ZXMgcmVmZXJlbmNlcyB3aXRoaW4gYSBzdWIgZG9jdW1lbnRcbiAqIEpzb25SZWZzLmZpbmRSZWZzQXQoJ2h0dHA6Ly9wZXRzdG9yZS5zd2FnZ2VyLmlvL3YyL3N3YWdnZXIuanNvbicsIHtcbiAqICAgICBzdWJEb2NQYXRoOiAnIy9kZWZpbml0aW9ucydcbiAqICAgfSlcbiAqICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICogICAgICAvLyBEbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzcG9uc2VcbiAqICAgICAgLy9cbiAqICAgICAgLy8gcmVzLnJlZnM6IEpTT04gUmVmZXJlbmNlIGxvY2F0aW9ucyBhbmQgZGV0YWlsc1xuICogICAgICAvLyByZXMudmFsdWU6IFRoZSByZXRyaWV2ZWQgZG9jdW1lbnRcbiAqICAgfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKGVyci5zdGFjayk7XG4gKiAgIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZFJlZnNBdCAobG9jYXRpb24sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9maW5kUmVmc0F0KGxvY2F0aW9uLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IHRoZSBKU09OIFJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gVGhlIEpTT04gUmVmZXJlbmNlIGRlZmluaXRpb25cbiAqXG4gKiBAcmV0dXJucyB7bW9kdWxlOmpzb24tcmVmc35VbnJlc29sdmVkUmVmRGV0YWlsc30gdGhlIGRldGFpbGVkIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWZEZXRhaWxzIChvYmopIHtcbiAgcmV0dXJuIF9nZXRSZWZEZXRhaWxzKG9iaik7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBhcmd1bWVudCByZXByZXNlbnRzIGEgSlNPTiBQb2ludGVyLlxuICpcbiAqIEEgc3RyaW5nIGlzIGEgSlNPTiBQb2ludGVyIGlmIHRoZSBmb2xsb3dpbmcgYXJlIGFsbCB0cnVlOlxuICpcbiAqICAgKiBUaGUgc3RyaW5nIGlzIG9mIHR5cGUgYFN0cmluZ2BcbiAqICAgKiBUaGUgc3RyaW5nIG11c3QgYmUgZW1wdHksIGAjYCBvciBzdGFydCB3aXRoIGEgYC9gIG9yIGAjL2BcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHRyIC0gVGhlIHN0cmluZyB0byBjaGVja1xuICogQHBhcmFtIHtib29sZWFufSBbdGhyb3dXaXRoRGV0YWlscz1mYWxzZV0gLSBXaGV0aGVyIG9yIG5vdCB0byB0aHJvdyBhbiBgRXJyb3JgIHdpdGggdGhlIGRldGFpbHMgYXMgdG8gd2h5IHRoZSB2YWx1ZVxuICogcHJvdmlkZWQgaXMgaW52YWxpZFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSBjaGVja1xuICpcbiAqIEB0aHJvd3Mge2Vycm9yfSB3aGVuIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBpbnZhbGlkIGFuZCB0aGUgYHRocm93V2l0aERldGFpbHNgIGFyZ3VtZW50IGlzIGB0cnVlYFxuICpcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxI3NlY3Rpb24tM31cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU2VwYXJhdGluZyB0aGUgZGlmZmVyZW50IHdheXMgdG8gaW52b2tlIGlzUHRyIGZvciBkZW1vbnN0cmF0aW9uIHB1cnBvc2VzXG4gKiBpZiAoaXNQdHIoc3RyKSkge1xuICogICAvLyBIYW5kbGUgYSB2YWxpZCBKU09OIFBvaW50ZXJcbiAqIH0gZWxzZSB7XG4gKiAgIC8vIEdldCB0aGUgcmVhc29uIGFzIHRvIHdoeSB0aGUgdmFsdWUgaXMgbm90IGEgSlNPTiBQb2ludGVyIHNvIHlvdSBjYW4gZml4L3JlcG9ydCBpdFxuICogICB0cnkge1xuICogICAgIGlzUHRyKHN0ciwgdHJ1ZSk7XG4gKiAgIH0gY2F0Y2ggKGVycikge1xuICogICAgIC8vIFRoZSBlcnJvciBtZXNzYWdlIGNvbnRhaW5zIHRoZSBkZXRhaWxzIGFzIHRvIHdoeSB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgbm90IGEgSlNPTiBQb2ludGVyXG4gKiAgIH1cbiAqIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUHRyIChwdHIsIHRocm93V2l0aERldGFpbHMpIHtcbiAgcmV0dXJuIF9pc1B0cihwdHIsIHRocm93V2l0aERldGFpbHMpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgYXJndW1lbnQgcmVwcmVzZW50cyBhIEpTT04gUmVmZXJlbmNlLlxuICpcbiAqIEFuIG9iamVjdCBpcyBhIEpTT04gUmVmZXJlbmNlIG9ubHkgaWYgdGhlIGZvbGxvd2luZyBhcmUgYWxsIHRydWU6XG4gKlxuICogICAqIFRoZSBvYmplY3QgaXMgb2YgdHlwZSBgT2JqZWN0YFxuICogICAqIFRoZSBvYmplY3QgaGFzIGEgYCRyZWZgIHByb3BlcnR5XG4gKiAgICogVGhlIGAkcmVmYCBwcm9wZXJ0eSBpcyBhIHZhbGlkIFVSSSAqKFdlIGRvIG5vdCByZXF1aXJlIDEwMCUgc3RyaWN0IFVSSXMgYW5kIHdpbGwgaGFuZGxlIHVuZXNjYXBlZCBzcGVjaWFsXG4gKiAgICAgY2hhcmFjdGVycy4pKlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogLSBUaGUgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0aHJvd1dpdGhEZXRhaWxzPWZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIHRocm93IGFuIGBFcnJvcmAgd2l0aCB0aGUgZGV0YWlscyBhcyB0byB3aHkgdGhlIHZhbHVlXG4gKiBwcm92aWRlZCBpcyBpbnZhbGlkXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIGNoZWNrXG4gKlxuICogQHRocm93cyB7ZXJyb3J9IHdoZW4gdGhlIHByb3ZpZGVkIHZhbHVlIGlzIGludmFsaWQgYW5kIHRoZSBgdGhyb3dXaXRoRGV0YWlsc2AgYXJndW1lbnQgaXMgYHRydWVgXG4gKlxuICogQHNlZSB7QGxpbmsgaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtcGJyeWFuLXp5cC1qc29uLXJlZi0wMyNzZWN0aW9uLTN9XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFNlcGFyYXRpbmcgdGhlIGRpZmZlcmVudCB3YXlzIHRvIGludm9rZSBpc1JlZiBmb3IgZGVtb25zdHJhdGlvbiBwdXJwb3Nlc1xuICogaWYgKGlzUmVmKG9iaikpIHtcbiAqICAgLy8gSGFuZGxlIGEgdmFsaWQgSlNPTiBSZWZlcmVuY2VcbiAqIH0gZWxzZSB7XG4gKiAgIC8vIEdldCB0aGUgcmVhc29uIGFzIHRvIHdoeSB0aGUgdmFsdWUgaXMgbm90IGEgSlNPTiBSZWZlcmVuY2Ugc28geW91IGNhbiBmaXgvcmVwb3J0IGl0XG4gKiAgIHRyeSB7XG4gKiAgICAgaXNSZWYoc3RyLCB0cnVlKTtcbiAqICAgfSBjYXRjaCAoZXJyKSB7XG4gKiAgICAgLy8gVGhlIGVycm9yIG1lc3NhZ2UgY29udGFpbnMgdGhlIGRldGFpbHMgYXMgdG8gd2h5IHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3QgYSBKU09OIFJlZmVyZW5jZVxuICogICB9XG4gKiB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZiAob2JqLCB0aHJvd1dpdGhEZXRhaWxzKSB7XG4gIHJldHVybiBfaXNSZWYob2JqLCB0aHJvd1dpdGhEZXRhaWxzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIHBhdGggc2VnbWVudHMgZm9yIHRoZSBwcm92aWRlZCBKU09OIFBvaW50ZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHB0ciAtIFRoZSBKU09OIFBvaW50ZXJcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IHRoZSBwYXRoIHNlZ21lbnRzXG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBwcm92aWRlZCBgcHRyYCBhcmd1bWVudCBpcyBub3QgYSBKU09OIFBvaW50ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhdGhGcm9tUHRyIChwdHIpIHtcbiAgcmV0dXJuIF9wYXRoRnJvbVB0cihwdHIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBKU09OIFBvaW50ZXIgZm9yIHRoZSBwcm92aWRlZCBhcnJheSBvZiBwYXRoIHNlZ21lbnRzLlxuICpcbiAqICoqTm90ZToqKiBJZiBhIHBhdGggc2VnbWVudCBpbiBgcGF0aGAgaXMgbm90IGEgYFN0cmluZ2AsIGl0IHdpbGwgYmUgY29udmVydGVkIHRvIG9uZSB1c2luZyBgSlNPTi5zdHJpbmdpZnlgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGggLSBUaGUgYXJyYXkgb2YgcGF0aCBzZWdtZW50c1xuICogQHBhcmFtIHtib29sZWFufSBbaGFzaFByZWZpeD10cnVlXSAtIFdoZXRoZXIgb3Igbm90IGNyZWF0ZSBhIGhhc2gtcHJlZml4ZWQgSlNPTiBQb2ludGVyXG4gKlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIGNvcnJlc3BvbmRpbmcgSlNPTiBQb2ludGVyXG4gKlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBgcGF0aGAgYXJndW1lbnQgaXMgbm90IGFuIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXRoVG9QdHIgKHBhdGgsIGhhc2hQcmVmaXgpIHtcbiAgcmV0dXJuIF9wYXRoVG9QdHIocGF0aCwgaGFzaFByZWZpeCk7XG59XG5cbi8qKlxuICogRmluZHMgSlNPTiBSZWZlcmVuY2VzIGRlZmluZWQgd2l0aGluIHRoZSBwcm92aWRlZCBhcnJheS9vYmplY3QgYW5kIHJlc29sdmVzIHRoZW0uXG4gKlxuICogQHBhcmFtIHthcnJheXxvYmplY3R9IG9iaiAtIFRoZSBzdHJ1Y3R1cmUgdG8gZmluZCBKU09OIFJlZmVyZW5jZXMgd2l0aGluXG4gKiBAcGFyYW0ge21vZHVsZTpqc29uLXJlZnN+SnNvblJlZnNPcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgSnNvblJlZnMgb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPG1vZHVsZTpqc29uLXJlZnN+UmVzb2x2ZWRSZWZzUmVzdWx0cz59IGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFcbiAqIHtAbGluayBtb2R1bGU6anNvbi1yZWZzflJlc29sdmVkUmVmc1Jlc3VsdHN9IGFuZCByZWplY3RzIHdpdGggYW4gYEVycm9yYCB3aGVuIHRoZSBpbnB1dCBhcmd1bWVudHMgZmFpbCB2YWxpZGF0aW9uLFxuICogd2hlbiBgb3B0aW9ucy5zdWJEb2NQYXRoYCBwb2ludHMgdG8gYW4gaW52YWxpZCBsb2NhdGlvbiBvciB3aGVuIHRoZSBsb2NhdGlvbiBhcmd1bWVudCBwb2ludHMgdG8gYW4gdW5sb2FkYWJsZVxuICogcmVzb3VyY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gRXhhbXBsZSB0aGF0IG9ubHkgcmVzb2x2ZXMgcmVsYXRpdmUgYW5kIHJlbW90ZSByZWZlcmVuY2VzXG4gKiBKc29uUmVmcy5yZXNvbHZlUmVmcyhzd2FnZ2VyT2JqLCB7XG4gKiAgICAgZmlsdGVyOiBbJ3JlbGF0aXZlJywgJ3JlbW90ZSddXG4gKiAgIH0pXG4gKiAgIC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAqICAgICAgLy8gRG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3BvbnNlXG4gKiAgICAgIC8vXG4gKiAgICAgIC8vIHJlcy5yZWZzOiBKU09OIFJlZmVyZW5jZSBsb2NhdGlvbnMgYW5kIGRldGFpbHNcbiAqICAgICAgLy8gcmVzLnJlc29sdmVkOiBUaGUgZG9jdW1lbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSlNPTiBSZWZlcmVuY2VzIHJlc29sdmVkXG4gKiAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAqICAgICBjb25zb2xlLmxvZyhlcnIuc3RhY2spO1xuICogICB9KTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVSZWZzIChvYmosIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9yZXNvbHZlUmVmcyhvYmosIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFJlc29sdmVzIEpTT04gUmVmZXJlbmNlcyBkZWZpbmVkIHdpdGhpbiB0aGUgZG9jdW1lbnQgYXQgdGhlIHByb3ZpZGVkIGxvY2F0aW9uLlxuICpcbiAqIFRoaXMgQVBJIGlzIGlkZW50aWNhbCB0byB7QGxpbmsgbW9kdWxlOmpzb24tcmVmcy5yZXNvbHZlUmVmc30gZXhjZXB0IHRoaXMgQVBJIHdpbGwgcmV0cmlldmUgYSByZW1vdGUgZG9jdW1lbnQgYW5kXG4gKiB0aGVuIHJldHVybiB0aGUgcmVzdWx0IG9mIHtAbGluayBtb2R1bGU6anNvbi1yZWZzLnJlc29sdmVSZWZzfSBvbiB0aGUgcmV0cmlldmVkIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byByZXRyaWV2ZSAqKENhbiBiZSByZWxhdGl2ZSBvciBhYnNvbHV0ZSwganVzdCBtYWtlIHN1cmUgeW91IGxvb2sgYXQgdGhlXG4gKiB7QGxpbmsgbW9kdWxlOmpzb24tcmVmc35Kc29uUmVmc09wdGlvbnN8b3B0aW9ucyBkb2N1bWVudGF0aW9ufSB0byBzZWUgaG93IHJlbGF0aXZlIHJlZmVyZW5jZXMgYXJlIGhhbmRsZWQuKSpcbiAqIEBwYXJhbSB7bW9kdWxlOmpzb24tcmVmc35Kc29uUmVmc09wdGlvbnN9IFtvcHRpb25zXSAtIFRoZSBKc29uUmVmcyBvcHRpb25zXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8bW9kdWxlOmpzb24tcmVmc35SZXRyaWV2ZWRSZXNvbHZlZFJlZnNSZXN1bHRzPn0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYVxuICoge0BsaW5rIG1vZHVsZTpqc29uLXJlZnN+UmV0cmlldmVkUmVzb2x2ZWRSZWZzUmVzdWx0c30gYW5kIHJlamVjdHMgd2l0aCBhbiBgRXJyb3JgIHdoZW4gdGhlIGlucHV0IGFyZ3VtZW50cyBmYWlsXG4gKiB2YWxpZGF0aW9uLCB3aGVuIGBvcHRpb25zLnN1YkRvY1BhdGhgIHBvaW50cyB0byBhbiBpbnZhbGlkIGxvY2F0aW9uIG9yIHdoZW4gdGhlIGxvY2F0aW9uIGFyZ3VtZW50IHBvaW50cyB0byBhblxuICogdW5sb2FkYWJsZSByZXNvdXJjZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFeGFtcGxlIHRoYXQgbG9hZHMgYSBKU09OIGRvY3VtZW50IChObyBvcHRpb25zLmxvYWRlck9wdGlvbnMucHJvY2Vzc0NvbnRlbnQgcmVxdWlyZWQpIGFuZCByZXNvbHZlcyBhbGwgcmVmZXJlbmNlc1xuICogSnNvblJlZnMucmVzb2x2ZVJlZnNBdCgnLi9zd2FnZ2VyLmpzb24nKVxuICogICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gKiAgICAgIC8vIERvIHNvbWV0aGluZyB3aXRoIHRoZSByZXNwb25zZVxuICogICAgICAvL1xuICogICAgICAvLyByZXMucmVmczogSlNPTiBSZWZlcmVuY2UgbG9jYXRpb25zIGFuZCBkZXRhaWxzXG4gKiAgICAgIC8vIHJlcy5yZXNvbHZlZDogVGhlIGRvY3VtZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIEpTT04gUmVmZXJlbmNlcyByZXNvbHZlZFxuICogICAgICAvLyByZXMudmFsdWU6IFRoZSByZXRyaWV2ZWQgZG9jdW1lbnRcbiAqICAgfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUubG9nKGVyci5zdGFjayk7XG4gKiAgIH0pO1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVJlZnNBdCAobG9jYXRpb24sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9yZXNvbHZlUmVmc0F0KGxvY2F0aW9uLCBvcHRpb25zKTtcbn1cbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LCBDaHJpcyBQZXR0aXR0XG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gKiBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gKiB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uXG4gKiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiAzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9yc1xuICogbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXRcbiAqIHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbiAqIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG4gKiBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFXG4gKiBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxuICogREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1JcbiAqIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSXG4gKiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLFxuICogT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKi9cblxudmFyIGxpYiA9IHJlcXVpcmUoXCIuL2xpYlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdyYXBoOiBsaWIuR3JhcGgsXG4gIGpzb246IHJlcXVpcmUoXCIuL2xpYi9qc29uXCIpLFxuICBhbGc6IHJlcXVpcmUoXCIuL2xpYi9hbGdcIiksXG4gIHZlcnNpb246IGxpYi52ZXJzaW9uXG59O1xuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBvbmVudHM7XG5cbmZ1bmN0aW9uIGNvbXBvbmVudHMoZykge1xuICB2YXIgdmlzaXRlZCA9IHt9LFxuICAgICAgY21wdHMgPSBbXSxcbiAgICAgIGNtcHQ7XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICBpZiAoXy5oYXModmlzaXRlZCwgdikpIHJldHVybjtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICBjbXB0LnB1c2godik7XG4gICAgXy5lYWNoKGcuc3VjY2Vzc29ycyh2KSwgZGZzKTtcbiAgICBfLmVhY2goZy5wcmVkZWNlc3NvcnModiksIGRmcyk7XG4gIH1cblxuICBfLmVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgY21wdCA9IFtdO1xuICAgIGRmcyh2KTtcbiAgICBpZiAoY21wdC5sZW5ndGgpIHtcbiAgICAgIGNtcHRzLnB1c2goY21wdCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY21wdHM7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZGZzO1xuXG4vKlxuICogQSBoZWxwZXIgdGhhdCBwcmVmb3JtcyBhIHByZS0gb3IgcG9zdC1vcmRlciB0cmF2ZXJzYWwgb24gdGhlIGlucHV0IGdyYXBoXG4gKiBhbmQgcmV0dXJucyB0aGUgbm9kZXMgaW4gdGhlIG9yZGVyIHRoZXkgd2VyZSB2aXNpdGVkLiBJZiB0aGUgZ3JhcGggaXNcbiAqIHVuZGlyZWN0ZWQgdGhlbiB0aGlzIGFsZ29yaXRobSB3aWxsIG5hdmlnYXRlIHVzaW5nIG5laWdoYm9ycy4gSWYgdGhlIGdyYXBoXG4gKiBpcyBkaXJlY3RlZCB0aGVuIHRoaXMgYWxnb3JpdGhtIHdpbGwgbmF2aWdhdGUgdXNpbmcgc3VjY2Vzc29ycy5cbiAqXG4gKiBPcmRlciBtdXN0IGJlIG9uZSBvZiBcInByZVwiIG9yIFwicG9zdFwiLlxuICovXG5mdW5jdGlvbiBkZnMoZywgdnMsIG9yZGVyKSB7XG4gIGlmICghXy5pc0FycmF5KHZzKSkge1xuICAgIHZzID0gW3ZzXTtcbiAgfVxuXG4gIHZhciBuYXZpZ2F0aW9uID0gKGcuaXNEaXJlY3RlZCgpID8gZy5zdWNjZXNzb3JzIDogZy5uZWlnaGJvcnMpLmJpbmQoZyk7XG5cbiAgdmFyIGFjYyA9IFtdLFxuICAgICAgdmlzaXRlZCA9IHt9O1xuICBfLmVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoIWcuaGFzTm9kZSh2KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR3JhcGggZG9lcyBub3QgaGF2ZSBub2RlOiBcIiArIHYpO1xuICAgIH1cblxuICAgIGRvRGZzKGcsIHYsIG9yZGVyID09PSBcInBvc3RcIiwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKTtcbiAgfSk7XG4gIHJldHVybiBhY2M7XG59XG5cbmZ1bmN0aW9uIGRvRGZzKGcsIHYsIHBvc3RvcmRlciwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKSB7XG4gIGlmICghXy5oYXModmlzaXRlZCwgdikpIHtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcblxuICAgIGlmICghcG9zdG9yZGVyKSB7IGFjYy5wdXNoKHYpOyB9XG4gICAgXy5lYWNoKG5hdmlnYXRpb24odiksIGZ1bmN0aW9uKHcpIHtcbiAgICAgIGRvRGZzKGcsIHcsIHBvc3RvcmRlciwgdmlzaXRlZCwgbmF2aWdhdGlvbiwgYWNjKTtcbiAgICB9KTtcbiAgICBpZiAocG9zdG9yZGVyKSB7IGFjYy5wdXNoKHYpOyB9XG4gIH1cbn1cbiIsInZhciBkaWprc3RyYSA9IHJlcXVpcmUoXCIuL2RpamtzdHJhXCIpLFxuICAgIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpamtzdHJhQWxsO1xuXG5mdW5jdGlvbiBkaWprc3RyYUFsbChnLCB3ZWlnaHRGdW5jLCBlZGdlRnVuYykge1xuICByZXR1cm4gXy50cmFuc2Zvcm0oZy5ub2RlcygpLCBmdW5jdGlvbihhY2MsIHYpIHtcbiAgICBhY2Nbdl0gPSBkaWprc3RyYShnLCB2LCB3ZWlnaHRGdW5jLCBlZGdlRnVuYyk7XG4gIH0sIHt9KTtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKSxcbiAgICBQcmlvcml0eVF1ZXVlID0gcmVxdWlyZShcIi4uL2RhdGEvcHJpb3JpdHktcXVldWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZGlqa3N0cmE7XG5cbnZhciBERUZBVUxUX1dFSUdIVF9GVU5DID0gXy5jb25zdGFudCgxKTtcblxuZnVuY3Rpb24gZGlqa3N0cmEoZywgc291cmNlLCB3ZWlnaHRGbiwgZWRnZUZuKSB7XG4gIHJldHVybiBydW5EaWprc3RyYShnLCBTdHJpbmcoc291cmNlKSxcbiAgICAgICAgICAgICAgICAgICAgIHdlaWdodEZuIHx8IERFRkFVTFRfV0VJR0hUX0ZVTkMsXG4gICAgICAgICAgICAgICAgICAgICBlZGdlRm4gfHwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5vdXRFZGdlcyh2KTsgfSk7XG59XG5cbmZ1bmN0aW9uIHJ1bkRpamtzdHJhKGcsIHNvdXJjZSwgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICB2YXIgcmVzdWx0cyA9IHt9LFxuICAgICAgcHEgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpLFxuICAgICAgdiwgdkVudHJ5O1xuXG4gIHZhciB1cGRhdGVOZWlnaGJvcnMgPSBmdW5jdGlvbihlZGdlKSB7XG4gICAgdmFyIHcgPSBlZGdlLnYgIT09IHYgPyBlZGdlLnYgOiBlZGdlLncsXG4gICAgICAgIHdFbnRyeSA9IHJlc3VsdHNbd10sXG4gICAgICAgIHdlaWdodCA9IHdlaWdodEZuKGVkZ2UpLFxuICAgICAgICBkaXN0YW5jZSA9IHZFbnRyeS5kaXN0YW5jZSArIHdlaWdodDtcblxuICAgIGlmICh3ZWlnaHQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaWprc3RyYSBkb2VzIG5vdCBhbGxvdyBuZWdhdGl2ZSBlZGdlIHdlaWdodHMuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIkJhZCBlZGdlOiBcIiArIGVkZ2UgKyBcIiBXZWlnaHQ6IFwiICsgd2VpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAoZGlzdGFuY2UgPCB3RW50cnkuZGlzdGFuY2UpIHtcbiAgICAgIHdFbnRyeS5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgd0VudHJ5LnByZWRlY2Vzc29yID0gdjtcbiAgICAgIHBxLmRlY3JlYXNlKHcsIGRpc3RhbmNlKTtcbiAgICB9XG4gIH07XG5cbiAgZy5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgIHZhciBkaXN0YW5jZSA9IHYgPT09IHNvdXJjZSA/IDAgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgcmVzdWx0c1t2XSA9IHsgZGlzdGFuY2U6IGRpc3RhbmNlIH07XG4gICAgcHEuYWRkKHYsIGRpc3RhbmNlKTtcbiAgfSk7XG5cbiAgd2hpbGUgKHBxLnNpemUoKSA+IDApIHtcbiAgICB2ID0gcHEucmVtb3ZlTWluKCk7XG4gICAgdkVudHJ5ID0gcmVzdWx0c1t2XTtcbiAgICBpZiAodkVudHJ5LmRpc3RhbmNlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGVkZ2VGbih2KS5mb3JFYWNoKHVwZGF0ZU5laWdoYm9ycyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKSxcbiAgICB0YXJqYW4gPSByZXF1aXJlKFwiLi90YXJqYW5cIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEN5Y2xlcztcblxuZnVuY3Rpb24gZmluZEN5Y2xlcyhnKSB7XG4gIHJldHVybiBfLmZpbHRlcih0YXJqYW4oZyksIGZ1bmN0aW9uKGNtcHQpIHtcbiAgICByZXR1cm4gY21wdC5sZW5ndGggPiAxIHx8IChjbXB0Lmxlbmd0aCA9PT0gMSAmJiBnLmhhc0VkZ2UoY21wdFswXSwgY21wdFswXSkpO1xuICB9KTtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmbG95ZFdhcnNoYWxsO1xuXG52YXIgREVGQVVMVF9XRUlHSFRfRlVOQyA9IF8uY29uc3RhbnQoMSk7XG5cbmZ1bmN0aW9uIGZsb3lkV2Fyc2hhbGwoZywgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICByZXR1cm4gcnVuRmxveWRXYXJzaGFsbChnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHRGbiB8fCBERUZBVUxUX1dFSUdIVF9GVU5DLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlRm4gfHwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5vdXRFZGdlcyh2KTsgfSk7XG59XG5cbmZ1bmN0aW9uIHJ1bkZsb3lkV2Fyc2hhbGwoZywgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICB2YXIgcmVzdWx0cyA9IHt9LFxuICAgICAgbm9kZXMgPSBnLm5vZGVzKCk7XG5cbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgcmVzdWx0c1t2XSA9IHt9O1xuICAgIHJlc3VsdHNbdl1bdl0gPSB7IGRpc3RhbmNlOiAwIH07XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbih3KSB7XG4gICAgICBpZiAodiAhPT0gdykge1xuICAgICAgICByZXN1bHRzW3ZdW3ddID0geyBkaXN0YW5jZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH07XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWRnZUZuKHYpLmZvckVhY2goZnVuY3Rpb24oZWRnZSkge1xuICAgICAgdmFyIHcgPSBlZGdlLnYgPT09IHYgPyBlZGdlLncgOiBlZGdlLnYsXG4gICAgICAgICAgZCA9IHdlaWdodEZuKGVkZ2UpO1xuICAgICAgcmVzdWx0c1t2XVt3XSA9IHsgZGlzdGFuY2U6IGQsIHByZWRlY2Vzc29yOiB2IH07XG4gICAgfSk7XG4gIH0pO1xuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHZhciByb3dLID0gcmVzdWx0c1trXTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciByb3dJID0gcmVzdWx0c1tpXTtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oaikge1xuICAgICAgICB2YXIgaWsgPSByb3dJW2tdO1xuICAgICAgICB2YXIga2ogPSByb3dLW2pdO1xuICAgICAgICB2YXIgaWogPSByb3dJW2pdO1xuICAgICAgICB2YXIgYWx0RGlzdGFuY2UgPSBpay5kaXN0YW5jZSArIGtqLmRpc3RhbmNlO1xuICAgICAgICBpZiAoYWx0RGlzdGFuY2UgPCBpai5kaXN0YW5jZSkge1xuICAgICAgICAgIGlqLmRpc3RhbmNlID0gYWx0RGlzdGFuY2U7XG4gICAgICAgICAgaWoucHJlZGVjZXNzb3IgPSBrai5wcmVkZWNlc3NvcjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHRzO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbXBvbmVudHM6IHJlcXVpcmUoXCIuL2NvbXBvbmVudHNcIiksXG4gIGRpamtzdHJhOiByZXF1aXJlKFwiLi9kaWprc3RyYVwiKSxcbiAgZGlqa3N0cmFBbGw6IHJlcXVpcmUoXCIuL2RpamtzdHJhLWFsbFwiKSxcbiAgZmluZEN5Y2xlczogcmVxdWlyZShcIi4vZmluZC1jeWNsZXNcIiksXG4gIGZsb3lkV2Fyc2hhbGw6IHJlcXVpcmUoXCIuL2Zsb3lkLXdhcnNoYWxsXCIpLFxuICBpc0FjeWNsaWM6IHJlcXVpcmUoXCIuL2lzLWFjeWNsaWNcIiksXG4gIHBvc3RvcmRlcjogcmVxdWlyZShcIi4vcG9zdG9yZGVyXCIpLFxuICBwcmVvcmRlcjogcmVxdWlyZShcIi4vcHJlb3JkZXJcIiksXG4gIHByaW06IHJlcXVpcmUoXCIuL3ByaW1cIiksXG4gIHRhcmphbjogcmVxdWlyZShcIi4vdGFyamFuXCIpLFxuICB0b3Bzb3J0OiByZXF1aXJlKFwiLi90b3Bzb3J0XCIpXG59O1xuIiwidmFyIHRvcHNvcnQgPSByZXF1aXJlKFwiLi90b3Bzb3J0XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQWN5Y2xpYztcblxuZnVuY3Rpb24gaXNBY3ljbGljKGcpIHtcbiAgdHJ5IHtcbiAgICB0b3Bzb3J0KGcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiB0b3Bzb3J0LkN5Y2xlRXhjZXB0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJ2YXIgZGZzID0gcmVxdWlyZShcIi4vZGZzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvc3RvcmRlcjtcblxuZnVuY3Rpb24gcG9zdG9yZGVyKGcsIHZzKSB7XG4gIHJldHVybiBkZnMoZywgdnMsIFwicG9zdFwiKTtcbn1cbiIsInZhciBkZnMgPSByZXF1aXJlKFwiLi9kZnNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJlb3JkZXI7XG5cbmZ1bmN0aW9uIHByZW9yZGVyKGcsIHZzKSB7XG4gIHJldHVybiBkZnMoZywgdnMsIFwicHJlXCIpO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpLFxuICAgIEdyYXBoID0gcmVxdWlyZShcIi4uL2dyYXBoXCIpLFxuICAgIFByaW9yaXR5UXVldWUgPSByZXF1aXJlKFwiLi4vZGF0YS9wcmlvcml0eS1xdWV1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwcmltO1xuXG5mdW5jdGlvbiBwcmltKGcsIHdlaWdodEZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBHcmFwaCgpLFxuICAgICAgcGFyZW50cyA9IHt9LFxuICAgICAgcHEgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpLFxuICAgICAgdjtcblxuICBmdW5jdGlvbiB1cGRhdGVOZWlnaGJvcnMoZWRnZSkge1xuICAgIHZhciB3ID0gZWRnZS52ID09PSB2ID8gZWRnZS53IDogZWRnZS52LFxuICAgICAgICBwcmkgPSBwcS5wcmlvcml0eSh3KTtcbiAgICBpZiAocHJpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBlZGdlV2VpZ2h0ID0gd2VpZ2h0RnVuYyhlZGdlKTtcbiAgICAgIGlmIChlZGdlV2VpZ2h0IDwgcHJpKSB7XG4gICAgICAgIHBhcmVudHNbd10gPSB2O1xuICAgICAgICBwcS5kZWNyZWFzZSh3LCBlZGdlV2VpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZy5ub2RlQ291bnQoKSA9PT0gMCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBfLmVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcHEuYWRkKHYsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgcmVzdWx0LnNldE5vZGUodik7XG4gIH0pO1xuXG4gIC8vIFN0YXJ0IGZyb20gYW4gYXJiaXRyYXJ5IG5vZGVcbiAgcHEuZGVjcmVhc2UoZy5ub2RlcygpWzBdLCAwKTtcblxuICB2YXIgaW5pdCA9IGZhbHNlO1xuICB3aGlsZSAocHEuc2l6ZSgpID4gMCkge1xuICAgIHYgPSBwcS5yZW1vdmVNaW4oKTtcbiAgICBpZiAoXy5oYXMocGFyZW50cywgdikpIHtcbiAgICAgIHJlc3VsdC5zZXRFZGdlKHYsIHBhcmVudHNbdl0pO1xuICAgIH0gZWxzZSBpZiAoaW5pdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZ3JhcGggaXMgbm90IGNvbm5lY3RlZDogXCIgKyBnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdCA9IHRydWU7XG4gICAgfVxuXG4gICAgZy5ub2RlRWRnZXModikuZm9yRWFjaCh1cGRhdGVOZWlnaGJvcnMpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0YXJqYW47XG5cbmZ1bmN0aW9uIHRhcmphbihnKSB7XG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBzdGFjayA9IFtdLFxuICAgICAgdmlzaXRlZCA9IHt9LCAvLyBub2RlIGlkIC0+IHsgb25TdGFjaywgbG93bGluaywgaW5kZXggfVxuICAgICAgcmVzdWx0cyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgdmFyIGVudHJ5ID0gdmlzaXRlZFt2XSA9IHtcbiAgICAgIG9uU3RhY2s6IHRydWUsXG4gICAgICBsb3dsaW5rOiBpbmRleCxcbiAgICAgIGluZGV4OiBpbmRleCsrXG4gICAgfTtcbiAgICBzdGFjay5wdXNoKHYpO1xuXG4gICAgZy5zdWNjZXNzb3JzKHYpLmZvckVhY2goZnVuY3Rpb24odykge1xuICAgICAgaWYgKCFfLmhhcyh2aXNpdGVkLCB3KSkge1xuICAgICAgICBkZnModyk7XG4gICAgICAgIGVudHJ5Lmxvd2xpbmsgPSBNYXRoLm1pbihlbnRyeS5sb3dsaW5rLCB2aXNpdGVkW3ddLmxvd2xpbmspO1xuICAgICAgfSBlbHNlIGlmICh2aXNpdGVkW3ddLm9uU3RhY2spIHtcbiAgICAgICAgZW50cnkubG93bGluayA9IE1hdGgubWluKGVudHJ5Lmxvd2xpbmssIHZpc2l0ZWRbd10uaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGVudHJ5Lmxvd2xpbmsgPT09IGVudHJ5LmluZGV4KSB7XG4gICAgICB2YXIgY21wdCA9IFtdLFxuICAgICAgICAgIHc7XG4gICAgICBkbyB7XG4gICAgICAgIHcgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmlzaXRlZFt3XS5vblN0YWNrID0gZmFsc2U7XG4gICAgICAgIGNtcHQucHVzaCh3KTtcbiAgICAgIH0gd2hpbGUgKHYgIT09IHcpO1xuICAgICAgcmVzdWx0cy5wdXNoKGNtcHQpO1xuICAgIH1cbiAgfVxuXG4gIGcubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoIV8uaGFzKHZpc2l0ZWQsIHYpKSB7XG4gICAgICBkZnModik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0b3Bzb3J0O1xudG9wc29ydC5DeWNsZUV4Y2VwdGlvbiA9IEN5Y2xlRXhjZXB0aW9uO1xuXG5mdW5jdGlvbiB0b3Bzb3J0KGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fSxcbiAgICAgIHN0YWNrID0ge30sXG4gICAgICByZXN1bHRzID0gW107XG5cbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgIGlmIChfLmhhcyhzdGFjaywgbm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBDeWNsZUV4Y2VwdGlvbigpO1xuICAgIH1cblxuICAgIGlmICghXy5oYXModmlzaXRlZCwgbm9kZSkpIHtcbiAgICAgIHN0YWNrW25vZGVdID0gdHJ1ZTtcbiAgICAgIHZpc2l0ZWRbbm9kZV0gPSB0cnVlO1xuICAgICAgXy5lYWNoKGcucHJlZGVjZXNzb3JzKG5vZGUpLCB2aXNpdCk7XG4gICAgICBkZWxldGUgc3RhY2tbbm9kZV07XG4gICAgICByZXN1bHRzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgXy5lYWNoKGcuc2lua3MoKSwgdmlzaXQpO1xuXG4gIGlmIChfLnNpemUodmlzaXRlZCkgIT09IGcubm9kZUNvdW50KCkpIHtcbiAgICB0aHJvdyBuZXcgQ3ljbGVFeGNlcHRpb24oKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBDeWNsZUV4Y2VwdGlvbigpIHt9XG5DeWNsZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTsgLy8gbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFcnJvciB0byBwYXNzIHRlc3RpbmciLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJpb3JpdHlRdWV1ZTtcblxuLyoqXG4gKiBBIG1pbi1wcmlvcml0eSBxdWV1ZSBkYXRhIHN0cnVjdHVyZS4gVGhpcyBhbGdvcml0aG0gaXMgZGVyaXZlZCBmcm9tIENvcm1lbixcbiAqIGV0IGFsLiwgXCJJbnRyb2R1Y3Rpb24gdG8gQWxnb3JpdGhtc1wiLiBUaGUgYmFzaWMgaWRlYSBvZiBhIG1pbi1wcmlvcml0eVxuICogcXVldWUgaXMgdGhhdCB5b3UgY2FuIGVmZmljaWVudGx5IChpbiBPKDEpIHRpbWUpIGdldCB0aGUgc21hbGxlc3Qga2V5IGluXG4gKiB0aGUgcXVldWUuIEFkZGluZyBhbmQgcmVtb3ZpbmcgZWxlbWVudHMgdGFrZXMgTyhsb2cgbikgdGltZS4gQSBrZXkgY2FuXG4gKiBoYXZlIGl0cyBwcmlvcml0eSBkZWNyZWFzZWQgaW4gTyhsb2cgbikgdGltZS5cbiAqL1xuZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZSgpIHtcbiAgdGhpcy5fYXJyID0gW107XG4gIHRoaXMuX2tleUluZGljZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHF1ZXVlLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXJyLmxlbmd0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUga2V5cyB0aGF0IGFyZSBpbiB0aGUgcXVldWUuIFRha2VzIGBPKG4pYCB0aW1lLlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hcnIubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHgua2V5OyB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgKiprZXkqKiBpcyBpbiB0aGUgcXVldWUgYW5kIGBmYWxzZWAgaWYgbm90LlxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihrZXkpIHtcbiAgcmV0dXJuIF8uaGFzKHRoaXMuX2tleUluZGljZXMsIGtleSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHByaW9yaXR5IGZvciAqKmtleSoqLiBJZiAqKmtleSoqIGlzIG5vdCBwcmVzZW50IGluIHRoZSBxdWV1ZVxuICogdGhlbiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAuIFRha2VzIGBPKDEpYCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXlcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucHJpb3JpdHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fa2V5SW5kaWNlc1trZXldO1xuICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJbaW5kZXhdLnByaW9yaXR5O1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtleSBmb3IgdGhlIG1pbmltdW0gZWxlbWVudCBpbiB0aGlzIHF1ZXVlLiBJZiB0aGUgcXVldWUgaXNcbiAqIGVtcHR5IHRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIEVycm9yLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnNpemUoKSA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlF1ZXVlIHVuZGVyZmxvd1wiKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyWzBdLmtleTtcbn07XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBrZXkgaW50byB0aGUgcHJpb3JpdHkgcXVldWUuIElmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMgaW5cbiAqIHRoZSBxdWV1ZSB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYDsgb3RoZXJ3aXNlIGl0IHdpbGwgcmV0dXJuIGB0cnVlYC5cbiAqIFRha2VzIGBPKG4pYCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXkgdGhlIGtleSB0byBhZGRcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eSB0aGUgaW5pdGlhbCBwcmlvcml0eSBmb3IgdGhlIGtleVxuICovXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihrZXksIHByaW9yaXR5KSB7XG4gIHZhciBrZXlJbmRpY2VzID0gdGhpcy5fa2V5SW5kaWNlcztcbiAga2V5ID0gU3RyaW5nKGtleSk7XG4gIGlmICghXy5oYXMoa2V5SW5kaWNlcywga2V5KSkge1xuICAgIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gICAgdmFyIGluZGV4ID0gYXJyLmxlbmd0aDtcbiAgICBrZXlJbmRpY2VzW2tleV0gPSBpbmRleDtcbiAgICBhcnIucHVzaCh7a2V5OiBrZXksIHByaW9yaXR5OiBwcmlvcml0eX0pO1xuICAgIHRoaXMuX2RlY3JlYXNlKGluZGV4KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW5kIHJldHVybnMgdGhlIHNtYWxsZXN0IGtleSBpbiB0aGUgcXVldWUuIFRha2VzIGBPKGxvZyBuKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucmVtb3ZlTWluID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N3YXAoMCwgdGhpcy5fYXJyLmxlbmd0aCAtIDEpO1xuICB2YXIgbWluID0gdGhpcy5fYXJyLnBvcCgpO1xuICBkZWxldGUgdGhpcy5fa2V5SW5kaWNlc1ttaW4ua2V5XTtcbiAgdGhpcy5faGVhcGlmeSgwKTtcbiAgcmV0dXJuIG1pbi5rZXk7XG59O1xuXG4vKipcbiAqIERlY3JlYXNlcyB0aGUgcHJpb3JpdHkgZm9yICoqa2V5KiogdG8gKipwcmlvcml0eSoqLiBJZiB0aGUgbmV3IHByaW9yaXR5IGlzXG4gKiBncmVhdGVyIHRoYW4gdGhlIHByZXZpb3VzIHByaW9yaXR5LCB0aGlzIGZ1bmN0aW9uIHdpbGwgdGhyb3cgYW4gRXJyb3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGtleSB0aGUga2V5IGZvciB3aGljaCB0byByYWlzZSBwcmlvcml0eVxuICogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5IHRoZSBuZXcgcHJpb3JpdHkgZm9yIHRoZSBrZXlcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZGVjcmVhc2UgPSBmdW5jdGlvbihrZXksIHByaW9yaXR5KSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX2tleUluZGljZXNba2V5XTtcbiAgaWYgKHByaW9yaXR5ID4gdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5ldyBwcmlvcml0eSBpcyBncmVhdGVyIHRoYW4gY3VycmVudCBwcmlvcml0eS4gXCIgK1xuICAgICAgICBcIktleTogXCIgKyBrZXkgKyBcIiBPbGQ6IFwiICsgdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSArIFwiIE5ldzogXCIgKyBwcmlvcml0eSk7XG4gIH1cbiAgdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eSA9IHByaW9yaXR5O1xuICB0aGlzLl9kZWNyZWFzZShpbmRleCk7XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5faGVhcGlmeSA9IGZ1bmN0aW9uKGkpIHtcbiAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgdmFyIGwgPSAyICogaSxcbiAgICAgIHIgPSBsICsgMSxcbiAgICAgIGxhcmdlc3QgPSBpO1xuICBpZiAobCA8IGFyci5sZW5ndGgpIHtcbiAgICBsYXJnZXN0ID0gYXJyW2xdLnByaW9yaXR5IDwgYXJyW2xhcmdlc3RdLnByaW9yaXR5ID8gbCA6IGxhcmdlc3Q7XG4gICAgaWYgKHIgPCBhcnIubGVuZ3RoKSB7XG4gICAgICBsYXJnZXN0ID0gYXJyW3JdLnByaW9yaXR5IDwgYXJyW2xhcmdlc3RdLnByaW9yaXR5ID8gciA6IGxhcmdlc3Q7XG4gICAgfVxuICAgIGlmIChsYXJnZXN0ICE9PSBpKSB7XG4gICAgICB0aGlzLl9zd2FwKGksIGxhcmdlc3QpO1xuICAgICAgdGhpcy5faGVhcGlmeShsYXJnZXN0KTtcbiAgICB9XG4gIH1cbn07XG5cblByaW9yaXR5UXVldWUucHJvdG90eXBlLl9kZWNyZWFzZSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gIHZhciBwcmlvcml0eSA9IGFycltpbmRleF0ucHJpb3JpdHk7XG4gIHZhciBwYXJlbnQ7XG4gIHdoaWxlIChpbmRleCAhPT0gMCkge1xuICAgIHBhcmVudCA9IGluZGV4ID4+IDE7XG4gICAgaWYgKGFycltwYXJlbnRdLnByaW9yaXR5IDwgcHJpb3JpdHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl9zd2FwKGluZGV4LCBwYXJlbnQpO1xuICAgIGluZGV4ID0gcGFyZW50O1xuICB9XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5fc3dhcCA9IGZ1bmN0aW9uKGksIGopIHtcbiAgdmFyIGFyciA9IHRoaXMuX2FycjtcbiAgdmFyIGtleUluZGljZXMgPSB0aGlzLl9rZXlJbmRpY2VzO1xuICB2YXIgb3JpZ0FyckkgPSBhcnJbaV07XG4gIHZhciBvcmlnQXJySiA9IGFycltqXTtcbiAgYXJyW2ldID0gb3JpZ0Fycko7XG4gIGFycltqXSA9IG9yaWdBcnJJO1xuICBrZXlJbmRpY2VzW29yaWdBcnJKLmtleV0gPSBpO1xuICBrZXlJbmRpY2VzW29yaWdBcnJJLmtleV0gPSBqO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDtcblxudmFyIERFRkFVTFRfRURHRV9OQU1FID0gXCJcXHgwMFwiLFxuICAgIEdSQVBIX05PREUgPSBcIlxceDAwXCIsXG4gICAgRURHRV9LRVlfREVMSU0gPSBcIlxceDAxXCI7XG5cbi8vIEltcGxlbWVudGF0aW9uIG5vdGVzOlxuLy9cbi8vICAqIE5vZGUgaWQgcXVlcnkgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gc3RyaW5nIGlkcyBmb3IgdGhlIG5vZGVzXG4vLyAgKiBFZGdlIGlkIHF1ZXJ5IGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIFwiZWRnZU9ialwiLCBlZGdlIG9iamVjdCwgdGhhdCBpc1xuLy8gICAgY29tcG9zZWQgb2YgZW5vdWdoIGluZm9ybWF0aW9uIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGFuIGVkZ2U6IHt2LCB3LCBuYW1lfS5cbi8vICAqIEludGVybmFsbHkgd2UgdXNlIGFuIFwiZWRnZUlkXCIsIGEgc3RyaW5naWZpZWQgZm9ybSBvZiB0aGUgZWRnZU9iaiwgdG9cbi8vICAgIHJlZmVyZW5jZSBlZGdlcy4gVGhpcyBpcyBiZWNhdXNlIHdlIG5lZWQgYSBwZXJmb3JtYW50IHdheSB0byBsb29rIHRoZXNlXG4vLyAgICBlZGdlcyB1cCBhbmQsIG9iamVjdCBwcm9wZXJ0aWVzLCB3aGljaCBoYXZlIHN0cmluZyBrZXlzLCBhcmUgdGhlIGNsb3Nlc3Rcbi8vICAgIHdlJ3JlIGdvaW5nIHRvIGdldCB0byBhIHBlcmZvcm1hbnQgaGFzaHRhYmxlIGluIEphdmFTY3JpcHQuXG5cbmZ1bmN0aW9uIEdyYXBoKG9wdHMpIHtcbiAgdGhpcy5faXNEaXJlY3RlZCA9IF8uaGFzKG9wdHMsIFwiZGlyZWN0ZWRcIikgPyBvcHRzLmRpcmVjdGVkIDogdHJ1ZTtcbiAgdGhpcy5faXNNdWx0aWdyYXBoID0gXy5oYXMob3B0cywgXCJtdWx0aWdyYXBoXCIpID8gb3B0cy5tdWx0aWdyYXBoIDogZmFsc2U7XG4gIHRoaXMuX2lzQ29tcG91bmQgPSBfLmhhcyhvcHRzLCBcImNvbXBvdW5kXCIpID8gb3B0cy5jb21wb3VuZCA6IGZhbHNlO1xuXG4gIC8vIExhYmVsIGZvciB0aGUgZ3JhcGggaXRzZWxmXG4gIHRoaXMuX2xhYmVsID0gdW5kZWZpbmVkO1xuXG4gIC8vIERlZmF1bHRzIHRvIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IG5vZGVcbiAgdGhpcy5fZGVmYXVsdE5vZGVMYWJlbEZuID0gXy5jb25zdGFudCh1bmRlZmluZWQpO1xuXG4gIC8vIERlZmF1bHRzIHRvIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IGVkZ2VcbiAgdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuID0gXy5jb25zdGFudCh1bmRlZmluZWQpO1xuXG4gIC8vIHYgLT4gbGFiZWxcbiAgdGhpcy5fbm9kZXMgPSB7fTtcblxuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIC8vIHYgLT4gcGFyZW50XG4gICAgdGhpcy5fcGFyZW50ID0ge307XG5cbiAgICAvLyB2IC0+IGNoaWxkcmVuXG4gICAgdGhpcy5fY2hpbGRyZW4gPSB7fTtcbiAgICB0aGlzLl9jaGlsZHJlbltHUkFQSF9OT0RFXSA9IHt9O1xuICB9XG5cbiAgLy8gdiAtPiBlZGdlT2JqXG4gIHRoaXMuX2luID0ge307XG5cbiAgLy8gdSAtPiB2IC0+IE51bWJlclxuICB0aGlzLl9wcmVkcyA9IHt9O1xuXG4gIC8vIHYgLT4gZWRnZU9ialxuICB0aGlzLl9vdXQgPSB7fTtcblxuICAvLyB2IC0+IHcgLT4gTnVtYmVyXG4gIHRoaXMuX3N1Y3MgPSB7fTtcblxuICAvLyBlIC0+IGVkZ2VPYmpcbiAgdGhpcy5fZWRnZU9ianMgPSB7fTtcblxuICAvLyBlIC0+IGxhYmVsXG4gIHRoaXMuX2VkZ2VMYWJlbHMgPSB7fTtcbn1cblxuLyogTnVtYmVyIG9mIG5vZGVzIGluIHRoZSBncmFwaC4gU2hvdWxkIG9ubHkgYmUgY2hhbmdlZCBieSB0aGUgaW1wbGVtZW50YXRpb24uICovXG5HcmFwaC5wcm90b3R5cGUuX25vZGVDb3VudCA9IDA7XG5cbi8qIE51bWJlciBvZiBlZGdlcyBpbiB0aGUgZ3JhcGguIFNob3VsZCBvbmx5IGJlIGNoYW5nZWQgYnkgdGhlIGltcGxlbWVudGF0aW9uLiAqL1xuR3JhcGgucHJvdG90eXBlLl9lZGdlQ291bnQgPSAwO1xuXG5cbi8qID09PSBHcmFwaCBmdW5jdGlvbnMgPT09PT09PT09ICovXG5cbkdyYXBoLnByb3RvdHlwZS5pc0RpcmVjdGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc0RpcmVjdGVkO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmlzTXVsdGlncmFwaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNNdWx0aWdyYXBoO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmlzQ29tcG91bmQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lzQ29tcG91bmQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0R3JhcGggPSBmdW5jdGlvbihsYWJlbCkge1xuICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ncmFwaCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGFiZWw7XG59O1xuXG5cbi8qID09PSBOb2RlIGZ1bmN0aW9ucyA9PT09PT09PT09ICovXG5cbkdyYXBoLnByb3RvdHlwZS5zZXREZWZhdWx0Tm9kZUxhYmVsID0gZnVuY3Rpb24obmV3RGVmYXVsdCkge1xuICBpZiAoIV8uaXNGdW5jdGlvbihuZXdEZWZhdWx0KSkge1xuICAgIG5ld0RlZmF1bHQgPSBfLmNvbnN0YW50KG5ld0RlZmF1bHQpO1xuICB9XG4gIHRoaXMuX2RlZmF1bHROb2RlTGFiZWxGbiA9IG5ld0RlZmF1bHQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZUNvdW50O1xufTtcblxuR3JhcGgucHJvdG90eXBlLm5vZGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfLmtleXModGhpcy5fbm9kZXMpO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNvdXJjZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gXy5maWx0ZXIodGhpcy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIF8uaXNFbXB0eShzZWxmLl9pblt2XSk7XG4gIH0pO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNpbmtzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIF8uZmlsdGVyKHRoaXMubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHJldHVybiBfLmlzRW1wdHkoc2VsZi5fb3V0W3ZdKTtcbiAgfSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0Tm9kZXMgPSBmdW5jdGlvbih2cywgdmFsdWUpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgXy5lYWNoKHZzLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgc2VsZi5zZXROb2RlKHYsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXROb2RlKHYpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldE5vZGUgPSBmdW5jdGlvbih2LCB2YWx1ZSkge1xuICBpZiAoXy5oYXModGhpcy5fbm9kZXMsIHYpKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLl9ub2Rlc1t2XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRoaXMuX25vZGVzW3ZdID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB2YWx1ZSA6IHRoaXMuX2RlZmF1bHROb2RlTGFiZWxGbih2KTtcbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB0aGlzLl9wYXJlbnRbdl0gPSBHUkFQSF9OT0RFO1xuICAgIHRoaXMuX2NoaWxkcmVuW3ZdID0ge307XG4gICAgdGhpcy5fY2hpbGRyZW5bR1JBUEhfTk9ERV1bdl0gPSB0cnVlO1xuICB9XG4gIHRoaXMuX2luW3ZdID0ge307XG4gIHRoaXMuX3ByZWRzW3ZdID0ge307XG4gIHRoaXMuX291dFt2XSA9IHt9O1xuICB0aGlzLl9zdWNzW3ZdID0ge307XG4gICsrdGhpcy5fbm9kZUNvdW50O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gdGhpcy5fbm9kZXNbdl07XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaGFzTm9kZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIF8uaGFzKHRoaXMuX25vZGVzLCB2KTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5yZW1vdmVOb2RlID0gIGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoXy5oYXModGhpcy5fbm9kZXMsIHYpKSB7XG4gICAgdmFyIHJlbW92ZUVkZ2UgPSBmdW5jdGlvbihlKSB7IHNlbGYucmVtb3ZlRWRnZShzZWxmLl9lZGdlT2Jqc1tlXSk7IH07XG4gICAgZGVsZXRlIHRoaXMuX25vZGVzW3ZdO1xuICAgIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgICB0aGlzLl9yZW1vdmVGcm9tUGFyZW50c0NoaWxkTGlzdCh2KTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9wYXJlbnRbdl07XG4gICAgICBfLmVhY2godGhpcy5jaGlsZHJlbih2KSwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgc2VsZi5zZXRQYXJlbnQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bdl07XG4gICAgfVxuICAgIF8uZWFjaChfLmtleXModGhpcy5faW5bdl0pLCByZW1vdmVFZGdlKTtcbiAgICBkZWxldGUgdGhpcy5faW5bdl07XG4gICAgZGVsZXRlIHRoaXMuX3ByZWRzW3ZdO1xuICAgIF8uZWFjaChfLmtleXModGhpcy5fb3V0W3ZdKSwgcmVtb3ZlRWRnZSk7XG4gICAgZGVsZXRlIHRoaXMuX291dFt2XTtcbiAgICBkZWxldGUgdGhpcy5fc3Vjc1t2XTtcbiAgICAtLXRoaXMuX25vZGVDb3VudDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXRQYXJlbnQgPSBmdW5jdGlvbih2LCBwYXJlbnQpIHtcbiAgaWYgKCF0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBwYXJlbnQgaW4gYSBub24tY29tcG91bmQgZ3JhcGhcIik7XG4gIH1cblxuICBpZiAoXy5pc1VuZGVmaW5lZChwYXJlbnQpKSB7XG4gICAgcGFyZW50ID0gR1JBUEhfTk9ERTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb2VyY2UgcGFyZW50IHRvIHN0cmluZ1xuICAgIHBhcmVudCArPSBcIlwiO1xuICAgIGZvciAodmFyIGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgICAgIV8uaXNVbmRlZmluZWQoYW5jZXN0b3IpO1xuICAgICAgICAgYW5jZXN0b3IgPSB0aGlzLnBhcmVudChhbmNlc3RvcikpIHtcbiAgICAgIGlmIChhbmNlc3RvciA9PT0gdikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXR0aW5nIFwiICsgcGFyZW50KyBcIiBhcyBwYXJlbnQgb2YgXCIgKyB2ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIHdvdWxkIGNyZWF0ZSBhIGN5Y2xlXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0Tm9kZShwYXJlbnQpO1xuICB9XG5cbiAgdGhpcy5zZXROb2RlKHYpO1xuICB0aGlzLl9yZW1vdmVGcm9tUGFyZW50c0NoaWxkTGlzdCh2KTtcbiAgdGhpcy5fcGFyZW50W3ZdID0gcGFyZW50O1xuICB0aGlzLl9jaGlsZHJlbltwYXJlbnRdW3ZdID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuX3JlbW92ZUZyb21QYXJlbnRzQ2hpbGRMaXN0ID0gZnVuY3Rpb24odikge1xuICBkZWxldGUgdGhpcy5fY2hpbGRyZW5bdGhpcy5fcGFyZW50W3ZdXVt2XTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbih2KSB7XG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudFt2XTtcbiAgICBpZiAocGFyZW50ICE9PSBHUkFQSF9OT0RFKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLmNoaWxkcmVuID0gZnVuY3Rpb24odikge1xuICBpZiAoXy5pc1VuZGVmaW5lZCh2KSkge1xuICAgIHYgPSBHUkFQSF9OT0RFO1xuICB9XG5cbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlblt2XTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBfLmtleXMoY2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2ID09PSBHUkFQSF9OT0RFKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmhhc05vZGUodikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5wcmVkZWNlc3NvcnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBwcmVkc1YgPSB0aGlzLl9wcmVkc1t2XTtcbiAgaWYgKHByZWRzVikge1xuICAgIHJldHVybiBfLmtleXMocHJlZHNWKTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLnN1Y2Nlc3NvcnMgPSBmdW5jdGlvbih2KSB7XG4gIHZhciBzdWNzViA9IHRoaXMuX3N1Y3Nbdl07XG4gIGlmIChzdWNzVikge1xuICAgIHJldHVybiBfLmtleXMoc3Vjc1YpO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24odikge1xuICB2YXIgcHJlZHMgPSB0aGlzLnByZWRlY2Vzc29ycyh2KTtcbiAgaWYgKHByZWRzKSB7XG4gICAgcmV0dXJuIF8udW5pb24ocHJlZHMsIHRoaXMuc3VjY2Vzc29ycyh2KSk7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5pc0xlYWYgPSBmdW5jdGlvbiAodikge1xuICB2YXIgbmVpZ2hib3JzO1xuICBpZiAodGhpcy5pc0RpcmVjdGVkKCkpIHtcbiAgICBuZWlnaGJvcnMgPSB0aGlzLnN1Y2Nlc3NvcnModik7XG4gIH0gZWxzZSB7XG4gICAgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnModik7XG4gIH1cbiAgcmV0dXJuIG5laWdoYm9ycy5sZW5ndGggPT09IDA7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZmlsdGVyTm9kZXMgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgdmFyIGNvcHkgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7XG4gICAgZGlyZWN0ZWQ6IHRoaXMuX2lzRGlyZWN0ZWQsXG4gICAgbXVsdGlncmFwaDogdGhpcy5faXNNdWx0aWdyYXBoLFxuICAgIGNvbXBvdW5kOiB0aGlzLl9pc0NvbXBvdW5kXG4gIH0pO1xuXG4gIGNvcHkuc2V0R3JhcGgodGhpcy5ncmFwaCgpKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIF8uZWFjaCh0aGlzLl9ub2RlcywgZnVuY3Rpb24odmFsdWUsIHYpIHtcbiAgICBpZiAoZmlsdGVyKHYpKSB7XG4gICAgICBjb3B5LnNldE5vZGUodiwgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgXy5lYWNoKHRoaXMuX2VkZ2VPYmpzLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGNvcHkuaGFzTm9kZShlLnYpICYmIGNvcHkuaGFzTm9kZShlLncpKSB7XG4gICAgICBjb3B5LnNldEVkZ2UoZSwgc2VsZi5lZGdlKGUpKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBwYXJlbnRzID0ge307XG4gIGZ1bmN0aW9uIGZpbmRQYXJlbnQodikge1xuICAgIHZhciBwYXJlbnQgPSBzZWxmLnBhcmVudCh2KTtcbiAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQgfHwgY29weS5oYXNOb2RlKHBhcmVudCkpIHtcbiAgICAgIHBhcmVudHNbdl0gPSBwYXJlbnQ7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH0gZWxzZSBpZiAocGFyZW50IGluIHBhcmVudHMpIHtcbiAgICAgIHJldHVybiBwYXJlbnRzW3BhcmVudF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaW5kUGFyZW50KHBhcmVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICBfLmVhY2goY29weS5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgICBjb3B5LnNldFBhcmVudCh2LCBmaW5kUGFyZW50KHYpKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxuLyogPT09IEVkZ2UgZnVuY3Rpb25zID09PT09PT09PT0gKi9cblxuR3JhcGgucHJvdG90eXBlLnNldERlZmF1bHRFZGdlTGFiZWwgPSBmdW5jdGlvbihuZXdEZWZhdWx0KSB7XG4gIGlmICghXy5pc0Z1bmN0aW9uKG5ld0RlZmF1bHQpKSB7XG4gICAgbmV3RGVmYXVsdCA9IF8uY29uc3RhbnQobmV3RGVmYXVsdCk7XG4gIH1cbiAgdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuID0gbmV3RGVmYXVsdDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZWRnZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlQ291bnQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIF8udmFsdWVzKHRoaXMuX2VkZ2VPYmpzKTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXRQYXRoID0gZnVuY3Rpb24odnMsIHZhbHVlKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gIF8ucmVkdWNlKHZzLCBmdW5jdGlvbih2LCB3KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgc2VsZi5zZXRFZGdlKHYsIHcsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5zZXRFZGdlKHYsIHcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLypcbiAqIHNldEVkZ2UodiwgdywgW3ZhbHVlLCBbbmFtZV1dKVxuICogc2V0RWRnZSh7IHYsIHcsIFtuYW1lXSB9LCBbdmFsdWVdKVxuICovXG5HcmFwaC5wcm90b3R5cGUuc2V0RWRnZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdiwgdywgbmFtZSwgdmFsdWUsXG4gICAgICB2YWx1ZVNwZWNpZmllZCA9IGZhbHNlLFxuICAgICAgYXJnMCA9IGFyZ3VtZW50c1swXTtcblxuICBpZiAodHlwZW9mIGFyZzAgPT09IFwib2JqZWN0XCIgJiYgYXJnMCAhPT0gbnVsbCAmJiBcInZcIiBpbiBhcmcwKSB7XG4gICAgdiA9IGFyZzAudjtcbiAgICB3ID0gYXJnMC53O1xuICAgIG5hbWUgPSBhcmcwLm5hbWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFsdWVTcGVjaWZpZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gYXJnMDtcbiAgICB3ID0gYXJndW1lbnRzWzFdO1xuICAgIG5hbWUgPSBhcmd1bWVudHNbM107XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhbHVlU3BlY2lmaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2ID0gXCJcIiArIHY7XG4gIHcgPSBcIlwiICsgdztcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgbmFtZSA9IFwiXCIgKyBuYW1lO1xuICB9XG5cbiAgdmFyIGUgPSBlZGdlQXJnc1RvSWQodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSk7XG4gIGlmIChfLmhhcyh0aGlzLl9lZGdlTGFiZWxzLCBlKSkge1xuICAgIGlmICh2YWx1ZVNwZWNpZmllZCkge1xuICAgICAgdGhpcy5fZWRnZUxhYmVsc1tlXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmICghXy5pc1VuZGVmaW5lZChuYW1lKSAmJiAhdGhpcy5faXNNdWx0aWdyYXBoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBhIG5hbWVkIGVkZ2Ugd2hlbiBpc011bHRpZ3JhcGggPSBmYWxzZVwiKTtcbiAgfVxuXG4gIC8vIEl0IGRpZG4ndCBleGlzdCwgc28gd2UgbmVlZCB0byBjcmVhdGUgaXQuXG4gIC8vIEZpcnN0IGVuc3VyZSB0aGUgbm9kZXMgZXhpc3QuXG4gIHRoaXMuc2V0Tm9kZSh2KTtcbiAgdGhpcy5zZXROb2RlKHcpO1xuXG4gIHRoaXMuX2VkZ2VMYWJlbHNbZV0gPSB2YWx1ZVNwZWNpZmllZCA/IHZhbHVlIDogdGhpcy5fZGVmYXVsdEVkZ2VMYWJlbEZuKHYsIHcsIG5hbWUpO1xuXG4gIHZhciBlZGdlT2JqID0gZWRnZUFyZ3NUb09iaih0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKTtcbiAgLy8gRW5zdXJlIHdlIGFkZCB1bmRpcmVjdGVkIGVkZ2VzIGluIGEgY29uc2lzdGVudCB3YXkuXG4gIHYgPSBlZGdlT2JqLnY7XG4gIHcgPSBlZGdlT2JqLnc7XG5cbiAgT2JqZWN0LmZyZWV6ZShlZGdlT2JqKTtcbiAgdGhpcy5fZWRnZU9ianNbZV0gPSBlZGdlT2JqO1xuICBpbmNyZW1lbnRPckluaXRFbnRyeSh0aGlzLl9wcmVkc1t3XSwgdik7XG4gIGluY3JlbWVudE9ySW5pdEVudHJ5KHRoaXMuX3N1Y3Nbdl0sIHcpO1xuICB0aGlzLl9pblt3XVtlXSA9IGVkZ2VPYmo7XG4gIHRoaXMuX291dFt2XVtlXSA9IGVkZ2VPYmo7XG4gIHRoaXMuX2VkZ2VDb3VudCsrO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5lZGdlID0gZnVuY3Rpb24odiwgdywgbmFtZSkge1xuICB2YXIgZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgICAgICA/IGVkZ2VPYmpUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIGFyZ3VtZW50c1swXSlcbiAgICAgICAgICAgIDogZWRnZUFyZ3NUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpKTtcbiAgcmV0dXJuIHRoaXMuX2VkZ2VMYWJlbHNbZV07XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaGFzRWRnZSA9IGZ1bmN0aW9uKHYsIHcsIG5hbWUpIHtcbiAgdmFyIGUgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgPyBlZGdlT2JqVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCBhcmd1bWVudHNbMF0pXG4gICAgICAgICAgICA6IGVkZ2VBcmdzVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKSk7XG4gIHJldHVybiBfLmhhcyh0aGlzLl9lZGdlTGFiZWxzLCBlKTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5yZW1vdmVFZGdlID0gZnVuY3Rpb24odiwgdywgbmFtZSkge1xuICB2YXIgZSA9IChhcmd1bWVudHMubGVuZ3RoID09PSAxXG4gICAgICAgICAgICA/IGVkZ2VPYmpUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIGFyZ3VtZW50c1swXSlcbiAgICAgICAgICAgIDogZWRnZUFyZ3NUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpKSxcbiAgICAgIGVkZ2UgPSB0aGlzLl9lZGdlT2Jqc1tlXTtcbiAgaWYgKGVkZ2UpIHtcbiAgICB2ID0gZWRnZS52O1xuICAgIHcgPSBlZGdlLnc7XG4gICAgZGVsZXRlIHRoaXMuX2VkZ2VMYWJlbHNbZV07XG4gICAgZGVsZXRlIHRoaXMuX2VkZ2VPYmpzW2VdO1xuICAgIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkodGhpcy5fcHJlZHNbd10sIHYpO1xuICAgIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkodGhpcy5fc3Vjc1t2XSwgdyk7XG4gICAgZGVsZXRlIHRoaXMuX2luW3ddW2VdO1xuICAgIGRlbGV0ZSB0aGlzLl9vdXRbdl1bZV07XG4gICAgdGhpcy5fZWRnZUNvdW50LS07XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaW5FZGdlcyA9IGZ1bmN0aW9uKHYsIHUpIHtcbiAgdmFyIGluViA9IHRoaXMuX2luW3ZdO1xuICBpZiAoaW5WKSB7XG4gICAgdmFyIGVkZ2VzID0gXy52YWx1ZXMoaW5WKTtcbiAgICBpZiAoIXUpIHtcbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgcmV0dXJuIF8uZmlsdGVyKGVkZ2VzLCBmdW5jdGlvbihlZGdlKSB7IHJldHVybiBlZGdlLnYgPT09IHU7IH0pO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUub3V0RWRnZXMgPSBmdW5jdGlvbih2LCB3KSB7XG4gIHZhciBvdXRWID0gdGhpcy5fb3V0W3ZdO1xuICBpZiAob3V0Vikge1xuICAgIHZhciBlZGdlcyA9IF8udmFsdWVzKG91dFYpO1xuICAgIGlmICghdykge1xuICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gXy5maWx0ZXIoZWRnZXMsIGZ1bmN0aW9uKGVkZ2UpIHsgcmV0dXJuIGVkZ2UudyA9PT0gdzsgfSk7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlRWRnZXMgPSBmdW5jdGlvbih2LCB3KSB7XG4gIHZhciBpbkVkZ2VzID0gdGhpcy5pbkVkZ2VzKHYsIHcpO1xuICBpZiAoaW5FZGdlcykge1xuICAgIHJldHVybiBpbkVkZ2VzLmNvbmNhdCh0aGlzLm91dEVkZ2VzKHYsIHcpKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaW5jcmVtZW50T3JJbml0RW50cnkobWFwLCBrKSB7XG4gIGlmIChtYXBba10pIHtcbiAgICBtYXBba10rKztcbiAgfSBlbHNlIHtcbiAgICBtYXBba10gPSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY3JlbWVudE9yUmVtb3ZlRW50cnkobWFwLCBrKSB7XG4gIGlmICghLS1tYXBba10pIHsgZGVsZXRlIG1hcFtrXTsgfVxufVxuXG5mdW5jdGlvbiBlZGdlQXJnc1RvSWQoaXNEaXJlY3RlZCwgdl8sIHdfLCBuYW1lKSB7XG4gIHZhciB2ID0gXCJcIiArIHZfO1xuICB2YXIgdyA9IFwiXCIgKyB3XztcbiAgaWYgKCFpc0RpcmVjdGVkICYmIHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICByZXR1cm4gdiArIEVER0VfS0VZX0RFTElNICsgdyArIEVER0VfS0VZX0RFTElNICtcbiAgICAgICAgICAgICAoXy5pc1VuZGVmaW5lZChuYW1lKSA/IERFRkFVTFRfRURHRV9OQU1FIDogbmFtZSk7XG59XG5cbmZ1bmN0aW9uIGVkZ2VBcmdzVG9PYmooaXNEaXJlY3RlZCwgdl8sIHdfLCBuYW1lKSB7XG4gIHZhciB2ID0gXCJcIiArIHZfO1xuICB2YXIgdyA9IFwiXCIgKyB3XztcbiAgaWYgKCFpc0RpcmVjdGVkICYmIHYgPiB3KSB7XG4gICAgdmFyIHRtcCA9IHY7XG4gICAgdiA9IHc7XG4gICAgdyA9IHRtcDtcbiAgfVxuICB2YXIgZWRnZU9iaiA9ICB7IHY6IHYsIHc6IHcgfTtcbiAgaWYgKG5hbWUpIHtcbiAgICBlZGdlT2JqLm5hbWUgPSBuYW1lO1xuICB9XG4gIHJldHVybiBlZGdlT2JqO1xufVxuXG5mdW5jdGlvbiBlZGdlT2JqVG9JZChpc0RpcmVjdGVkLCBlZGdlT2JqKSB7XG4gIHJldHVybiBlZGdlQXJnc1RvSWQoaXNEaXJlY3RlZCwgZWRnZU9iai52LCBlZGdlT2JqLncsIGVkZ2VPYmoubmFtZSk7XG59XG4iLCIvLyBJbmNsdWRlcyBvbmx5IHRoZSBcImNvcmVcIiBvZiBncmFwaGxpYlxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEdyYXBoOiByZXF1aXJlKFwiLi9ncmFwaFwiKSxcbiAgdmVyc2lvbjogcmVxdWlyZShcIi4vdmVyc2lvblwiKVxufTtcbiIsInZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpLFxuICAgIEdyYXBoID0gcmVxdWlyZShcIi4vZ3JhcGhcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3cml0ZTogd3JpdGUsXG4gIHJlYWQ6IHJlYWRcbn07XG5cbmZ1bmN0aW9uIHdyaXRlKGcpIHtcbiAgdmFyIGpzb24gPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgZGlyZWN0ZWQ6IGcuaXNEaXJlY3RlZCgpLFxuICAgICAgbXVsdGlncmFwaDogZy5pc011bHRpZ3JhcGgoKSxcbiAgICAgIGNvbXBvdW5kOiBnLmlzQ29tcG91bmQoKVxuICAgIH0sXG4gICAgbm9kZXM6IHdyaXRlTm9kZXMoZyksXG4gICAgZWRnZXM6IHdyaXRlRWRnZXMoZylcbiAgfTtcbiAgaWYgKCFfLmlzVW5kZWZpbmVkKGcuZ3JhcGgoKSkpIHtcbiAgICBqc29uLnZhbHVlID0gXy5jbG9uZShnLmdyYXBoKCkpO1xuICB9XG4gIHJldHVybiBqc29uO1xufVxuXG5mdW5jdGlvbiB3cml0ZU5vZGVzKGcpIHtcbiAgcmV0dXJuIF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlVmFsdWUgPSBnLm5vZGUodiksXG4gICAgICAgIHBhcmVudCA9IGcucGFyZW50KHYpLFxuICAgICAgICBub2RlID0geyB2OiB2IH07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKG5vZGVWYWx1ZSkpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBub2RlVmFsdWU7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJlbnQpKSB7XG4gICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cml0ZUVkZ2VzKGcpIHtcbiAgcmV0dXJuIF8ubWFwKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlVmFsdWUgPSBnLmVkZ2UoZSksXG4gICAgICAgIGVkZ2UgPSB7IHY6IGUudiwgdzogZS53IH07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGUubmFtZSkpIHtcbiAgICAgIGVkZ2UubmFtZSA9IGUubmFtZTtcbiAgICB9XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGVkZ2VWYWx1ZSkpIHtcbiAgICAgIGVkZ2UudmFsdWUgPSBlZGdlVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBlZGdlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVhZChqc29uKSB7XG4gIHZhciBnID0gbmV3IEdyYXBoKGpzb24ub3B0aW9ucykuc2V0R3JhcGgoanNvbi52YWx1ZSk7XG4gIF8uZWFjaChqc29uLm5vZGVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIGcuc2V0Tm9kZShlbnRyeS52LCBlbnRyeS52YWx1ZSk7XG4gICAgaWYgKGVudHJ5LnBhcmVudCkge1xuICAgICAgZy5zZXRQYXJlbnQoZW50cnkudiwgZW50cnkucGFyZW50KTtcbiAgICB9XG4gIH0pO1xuICBfLmVhY2goanNvbi5lZGdlcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICBnLnNldEVkZ2UoeyB2OiBlbnRyeS52LCB3OiBlbnRyeS53LCBuYW1lOiBlbnRyeS5uYW1lIH0sIGVudHJ5LnZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBnO1xufVxuIiwiLyogZ2xvYmFsIHdpbmRvdyAqL1xuXG52YXIgbG9kYXNoO1xuXG5pZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICB0cnkge1xuICAgIGxvZGFzaCA9IHtcbiAgICAgIGNsb25lOiByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpLFxuICAgICAgY29uc3RhbnQ6IHJlcXVpcmUoXCJsb2Rhc2gvY29uc3RhbnRcIiksXG4gICAgICBlYWNoOiByZXF1aXJlKFwibG9kYXNoL2VhY2hcIiksXG4gICAgICBmaWx0ZXI6IHJlcXVpcmUoXCJsb2Rhc2gvZmlsdGVyXCIpLFxuICAgICAgaGFzOiAgcmVxdWlyZShcImxvZGFzaC9oYXNcIiksXG4gICAgICBpc0FycmF5OiByZXF1aXJlKFwibG9kYXNoL2lzQXJyYXlcIiksXG4gICAgICBpc0VtcHR5OiByZXF1aXJlKFwibG9kYXNoL2lzRW1wdHlcIiksXG4gICAgICBpc0Z1bmN0aW9uOiByZXF1aXJlKFwibG9kYXNoL2lzRnVuY3Rpb25cIiksXG4gICAgICBpc1VuZGVmaW5lZDogcmVxdWlyZShcImxvZGFzaC9pc1VuZGVmaW5lZFwiKSxcbiAgICAgIGtleXM6IHJlcXVpcmUoXCJsb2Rhc2gva2V5c1wiKSxcbiAgICAgIG1hcDogcmVxdWlyZShcImxvZGFzaC9tYXBcIiksXG4gICAgICByZWR1Y2U6IHJlcXVpcmUoXCJsb2Rhc2gvcmVkdWNlXCIpLFxuICAgICAgc2l6ZTogcmVxdWlyZShcImxvZGFzaC9zaXplXCIpLFxuICAgICAgdHJhbnNmb3JtOiByZXF1aXJlKFwibG9kYXNoL3RyYW5zZm9ybVwiKSxcbiAgICAgIHVuaW9uOiByZXF1aXJlKFwibG9kYXNoL3VuaW9uXCIpLFxuICAgICAgdmFsdWVzOiByZXF1aXJlKFwibG9kYXNoL3ZhbHVlc1wiKVxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbmlmICghbG9kYXNoKSB7XG4gIGxvZGFzaCA9IHdpbmRvdy5fO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZGFzaDtcbiIsIm1vZHVsZS5leHBvcnRzID0gJzIuMS43JztcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVZpZXc7XG4iLCJ2YXIgaGFzaENsZWFyID0gcmVxdWlyZSgnLi9faGFzaENsZWFyJyksXG4gICAgaGFzaERlbGV0ZSA9IHJlcXVpcmUoJy4vX2hhc2hEZWxldGUnKSxcbiAgICBoYXNoR2V0ID0gcmVxdWlyZSgnLi9faGFzaEdldCcpLFxuICAgIGhhc2hIYXMgPSByZXF1aXJlKCcuL19oYXNoSGFzJyksXG4gICAgaGFzaFNldCA9IHJlcXVpcmUoJy4vX2hhc2hTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaDtcbiIsInZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUNsZWFyJyksXG4gICAgbGlzdENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlRGVsZXRlJyksXG4gICAgbGlzdENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlR2V0JyksXG4gICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlSGFzJyksXG4gICAgbGlzdENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbGlzdENhY2hlU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBMaXN0Q2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwO1xuIiwidmFyIG1hcENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19tYXBDYWNoZUNsZWFyJyksXG4gICAgbWFwQ2FjaGVEZWxldGUgPSByZXF1aXJlKCcuL19tYXBDYWNoZURlbGV0ZScpLFxuICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVHZXQnKSxcbiAgICBtYXBDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX21hcENhY2hlSGFzJyksXG4gICAgbWFwQ2FjaGVTZXQgPSByZXF1aXJlKCcuL19tYXBDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXBDYWNoZTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0O1xuIiwidmFyIE1hcENhY2hlID0gcmVxdWlyZSgnLi9fTWFwQ2FjaGUnKSxcbiAgICBzZXRDYWNoZUFkZCA9IHJlcXVpcmUoJy4vX3NldENhY2hlQWRkJyksXG4gICAgc2V0Q2FjaGVIYXMgPSByZXF1aXJlKCcuL19zZXRDYWNoZUhhcycpO1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbm1vZHVsZS5leHBvcnRzID0gU2V0Q2FjaGU7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgc3RhY2tDbGVhciA9IHJlcXVpcmUoJy4vX3N0YWNrQ2xlYXInKSxcbiAgICBzdGFja0RlbGV0ZSA9IHJlcXVpcmUoJy4vX3N0YWNrRGVsZXRlJyksXG4gICAgc3RhY2tHZXQgPSByZXF1aXJlKCcuL19zdGFja0dldCcpLFxuICAgIHN0YWNrSGFzID0gcmVxdWlyZSgnLi9fc3RhY2tIYXMnKSxcbiAgICBzdGFja1NldCA9IHJlcXVpcmUoJy4vX3N0YWNrU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW1ib2w7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5O1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vha01hcDtcbiIsIi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcHBseTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUVhY2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlGaWx0ZXI7XG4iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuIiwidmFyIGJhc2VUaW1lcyA9IHJlcXVpcmUoJy4vX2Jhc2VUaW1lcycpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0J1ZmZlciA9IHJlcXVpcmUoJy4vaXNCdWZmZXInKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUxpa2VLZXlzO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheU1hcDtcbiIsIi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVB1c2g7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlSZWR1Y2U7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5U29tZTtcbiIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHknKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGFuIEFTQ0lJIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG52YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc2NpaVNpemU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNNYXAgPSByZXF1aXJlKCcuL2lzTWFwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTZXQgPSByZXF1aXJlKCcuL2lzU2V0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgQ0xPTkVfRkxBVF9GTEFHID0gMixcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcbiIsInZhciBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmlsdGVyO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZpbmRJbmRleDtcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBpc0ZsYXR0ZW5hYmxlID0gcmVxdWlyZSgnLi9faXNGbGF0dGVuYWJsZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmxhdHRlbjtcbiIsInZhciBjcmVhdGVCYXNlRm9yID0gcmVxdWlyZSgnLi9fY3JlYXRlQmFzZUZvcicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvcjtcbiIsInZhciBiYXNlRm9yID0gcmVxdWlyZSgnLi9fYmFzZUZvcicpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGb3JPd247XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSGFzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhc0luO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUlzTmFOID0gcmVxdWlyZSgnLi9fYmFzZUlzTmFOJyksXG4gICAgc3RyaWN0SW5kZXhPZiA9IHJlcXVpcmUoJy4vX3N0cmljdEluZGV4T2YnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleClcbiAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSW5kZXhPZjtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGJhc2VJc0VxdWFsRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc0VxdWFsRGVlcCcpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsO1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgZXF1YWxCeVRhZyA9IHJlcXVpcmUoJy4vX2VxdWFsQnlUYWcnKSxcbiAgICBlcXVhbE9iamVjdHMgPSByZXF1aXJlKCcuL19lcXVhbE9iamVjdHMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzRXF1YWxEZWVwO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hcDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXRjaDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTmFOO1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc01hc2tlZCA9IHJlcXVpcmUoJy4vX2lzTWFza2VkJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hdGl2ZTtcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNTZXQ7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzVHlwZWRBcnJheTtcbiIsInZhciBiYXNlTWF0Y2hlcyA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzJyksXG4gICAgYmFzZU1hdGNoZXNQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VNYXRjaGVzUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgcHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUl0ZXJhdGVlO1xuIiwidmFyIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5cycpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXM7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXNJbiA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXNJbicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzSW47XG4iLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXA7XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHk7XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVByb3BlcnR5RGVlcDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICogIGBjb2xsZWN0aW9uYCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBhY2N1bXVsYXRvciA9IGluaXRBY2N1bVxuICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVkdWNlO1xuIiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCBzdGFydCwgaWRlbnRpdHkpLCBmdW5jICsgJycpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VSZXN0O1xuIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuYXJ5O1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlc1dpdGgnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyksXG4gICAgY3JlYXRlU2V0ID0gcmVxdWlyZSgnLi9fY3JlYXRlU2V0JyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmlxQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuaXEoYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICBzZWVuID0gcmVzdWx0O1xuXG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICB9XG4gIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgdmFyIHNldCA9IGl0ZXJhdGVlID8gbnVsbCA6IGNyZWF0ZVNldChhcnJheSk7XG4gICAgaWYgKHNldCkge1xuICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICB9XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIHNlZW4gPSBuZXcgU2V0Q2FjaGU7XG4gIH1cbiAgZWxzZSB7XG4gICAgc2VlbiA9IGl0ZXJhdGVlID8gW10gOiByZXN1bHQ7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICB3aGlsZSAoc2VlbkluZGV4LS0pIHtcbiAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyhzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5pcTtcbiIsInZhciBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VWYWx1ZXM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYWNoZUhhcztcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGBpZGVudGl0eWAgaWYgaXQncyBub3QgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0RnVuY3Rpb247XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgYmFzZUVhY2hgIG9yIGBiYXNlRWFjaFJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBhIGNvbGxlY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VFYWNoKGVhY2hGdW5jLCBmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgfVxuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBlYWNoRnVuYyhjb2xsZWN0aW9uLCBpdGVyYXRlZSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VFYWNoO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmFzZUZvcjtcbiIsInZhciBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBub29wID0gcmVxdWlyZSgnLi9ub29wJyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICovXG52YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTZXQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxBcnJheXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBlcXVhbEFycmF5cyA9IHJlcXVpcmUoJy4vX2VxdWFsQXJyYXlzJyksXG4gICAgbWFwVG9BcnJheSA9IHJlcXVpcmUoJy4vX21hcFRvQXJyYXknKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxdWFsQnlUYWc7XG4iLCJ2YXIgZ2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxPYmplY3RzO1xuIiwiLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmcmVlR2xvYmFsO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzO1xuIiwidmFyIGJhc2VHZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUdldEFsbEtleXMnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXNJbjtcbiIsInZhciBpc0tleWFibGUgPSByZXF1aXJlKCcuL19pc0tleWFibGUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcERhdGE7XG4iLCJ2YXIgaXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9faXNTdHJpY3RDb21wYXJhYmxlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXRjaERhdGE7XG4iLCJ2YXIgYmFzZUlzTmF0aXZlID0gcmVxdWlyZSgnLi9fYmFzZUlzTmF0aXZlJyksXG4gICAgZ2V0VmFsdWUgPSByZXF1aXJlKCcuL19nZXRWYWx1ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQcm90b3R5cGU7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzO1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzSW47XG4iLCJ2YXIgRGF0YVZpZXcgPSByZXF1aXJlKCcuL19EYXRhVmlldycpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpLFxuICAgIFByb21pc2UgPSByZXF1aXJlKCcuL19Qcm9taXNlJyksXG4gICAgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgV2Vha01hcCA9IHJlcXVpcmUoJy4vX1dlYWtNYXAnKSxcbiAgICBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUYWc7XG4iLCIvKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWYWx1ZTtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNQYXRoO1xuIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xudmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHtcbiAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzVW5pY29kZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaENsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoRGVsZXRlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEdldDtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hIYXM7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hTZXQ7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyksXG4gICAgY2xvbmVEYXRhVmlldyA9IHJlcXVpcmUoJy4vX2Nsb25lRGF0YVZpZXcnKSxcbiAgICBjbG9uZVJlZ0V4cCA9IHJlcXVpcmUoJy4vX2Nsb25lUmVnRXhwJyksXG4gICAgY2xvbmVTeW1ib2wgPSByZXF1aXJlKCcuL19jbG9uZVN5bWJvbCcpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVCeVRhZztcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRmxhdHRlbmFibGU7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJbmRleDtcbiIsInZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleTtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0tleWFibGU7XG4iLCJ2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmUoJy4vX2NvcmVKc0RhdGEnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc01hc2tlZDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1Byb3RvdHlwZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaWN0Q29tcGFyYWJsZTtcbiIsIi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVDbGVhcjtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZURlbGV0ZTtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0Q2FjaGVHZXQ7XG4iLCJ2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZSgnLi9fYXNzb2NJbmRleE9mJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUhhcztcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZVNldDtcbiIsInZhciBIYXNoID0gcmVxdWlyZSgnLi9fSGFzaCcpLFxuICAgIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIE1hcCA9IHJlcXVpcmUoJy4vX01hcCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVDbGVhcjtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZURlbGV0ZTtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVHZXQ7XG4iLCJ2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hcERhdGEnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUhhcztcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwQ2FjaGVTZXQ7XG4iLCIvKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFRvQXJyYXk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hlc1N0cmljdENvbXBhcmFibGU7XG4iLCJ2YXIgbWVtb2l6ZSA9IHJlcXVpcmUoJy4vbWVtb2l6ZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZUNhcHBlZDtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVDcmVhdGU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuYXRpdmVLZXlzSW47XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBub2RlVXRpbDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlckFyZztcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgZnJlZUdsb2JhbCA9IHJlcXVpcmUoJy4vX2ZyZWVHbG9iYWwnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJvb3Q7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuIiwidmFyIGFzY2lpU2l6ZSA9IHJlcXVpcmUoJy4vX2FzY2lpU2l6ZScpLFxuICAgIGhhc1VuaWNvZGUgPSByZXF1aXJlKCcuL19oYXNVbmljb2RlJyksXG4gICAgdW5pY29kZVNpemUgPSByZXF1aXJlKCcuL191bmljb2RlU2l6ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdTaXplO1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xudmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgcnNDb21ib01hcmtzUmFuZ2UgPSAnXFxcXHUwMzAwLVxcXFx1MDM2ZicsXG4gICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlLFxuICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xudmFyIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgcnNOb25Bc3RyYWwgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgcmVnZXhlcy4gKi9cbnZhciByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlICsgJ10/JyxcbiAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggW3N0cmluZyBzeW1ib2xzXShodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlKS4gKi9cbnZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG9mIGEgVW5pY29kZSBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVNpemUoc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSByZVVuaWNvZGUubGFzdEluZGV4ID0gMDtcbiAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICArK3Jlc3VsdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaWNvZGVTaXplO1xuIiwidmFyIGJhc2VDbG9uZSA9IHJlcXVpcmUoJy4vX2Jhc2VDbG9uZScpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZm9yRWFjaCcpO1xuIiwiLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXE7XG4iLCJ2YXIgYXJyYXlGaWx0ZXIgPSByZXF1aXJlKCcuL19hcnJheUZpbHRlcicpLFxuICAgIGJhc2VGaWx0ZXIgPSByZXF1aXJlKCcuL19iYXNlRmlsdGVyJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgYWxsIGVsZW1lbnRzXG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnJlbW92ZWAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICogQHNlZSBfLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5maWx0ZXIodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUZpbHRlciA6IGJhc2VGaWx0ZXI7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iLCJ2YXIgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGNhc3RGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2Nhc3RGdW5jdGlvbicpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gKiBwcm9wZXJ0eSBhcmUgaXRlcmF0ZWQgbGlrZSBhcnJheXMuIFRvIGF2b2lkIHRoaXMgYmVoYXZpb3IgdXNlIGBfLmZvckluYFxuICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZWFjaFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gKlxuICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgY2FzdEZ1bmN0aW9uKGl0ZXJhdGVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0O1xuIiwidmFyIGJhc2VIYXMgPSByZXF1aXJlKCcuL19iYXNlSGFzJyksXG4gICAgaGFzUGF0aCA9IHJlcXVpcmUoJy4vX2hhc1BhdGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiB7ICdiJzogMiB9IH07XG4gKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXMob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXMob3RoZXIsICdhJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXMob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzO1xuIiwidmFyIGJhc2VIYXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VIYXNJbicpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNJbjtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG4iLCJ2YXIgYmFzZUlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9fYmFzZUlzQXJndW1lbnRzJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwidmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc0xlbmd0aCA9IHJlcXVpcmUoJy4vaXNMZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2U7XG4iLCJ2YXIgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICpcbiAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICogcHJvcGVydGllcy5cbiAqXG4gKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFbXB0eShudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkodHJ1ZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICB9XG4gIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFbXB0eTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVuY3Rpb247XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNMZW5ndGg7XG4iLCJ2YXIgYmFzZUlzTWFwID0gcmVxdWlyZSgnLi9fYmFzZUlzTWFwJyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFwO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdExpa2U7XG4iLCJ2YXIgYmFzZUlzU2V0ID0gcmVxdWlyZSgnLi9fYmFzZUlzU2V0JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2V0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNVbmRlZmluZWQ7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBMb2Rhc2ggPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG47KGZ1bmN0aW9uKCkge1xuXG4gIC8qKiBVc2VkIGFzIGEgc2FmZSByZWZlcmVuY2UgZm9yIGB1bmRlZmluZWRgIGluIHByZS1FUzUgZW52aXJvbm1lbnRzLiAqL1xuICB2YXIgdW5kZWZpbmVkO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci4gKi9cbiAgdmFyIFZFUlNJT04gPSAnNC4xNy4xMSc7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG4gIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4gIC8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbiAgdmFyIENPUkVfRVJST1JfVEVYVCA9ICdVbnN1cHBvcnRlZCBjb3JlLWpzIHVzZS4gVHJ5IGh0dHBzOi8vbnBtcy5pby9zZWFyY2g/cT1wb255ZmlsbC4nLFxuICAgICAgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbiAgdmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbiAgdmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbiAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbiAgdmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICB2YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsXG4gICAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuICAvKiogVXNlZCBhcyBkZWZhdWx0IG9wdGlvbnMgZm9yIGBfLnRydW5jYXRlYC4gKi9cbiAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsXG4gICAgICBERUZBVUxUX1RSVU5DX09NSVNTSU9OID0gJy4uLic7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xuICB2YXIgSE9UX0NPVU5UID0gODAwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbiAgdmFyIExBWllfRklMVEVSX0ZMQUcgPSAxLFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDIsXG4gICAgICBMQVpZX1dISUxFX0ZMQUcgPSAzO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICAgIE5BTiA9IDAgLyAwO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG4gIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcbiAgICAgIE1BWF9BUlJBWV9JTkRFWCA9IE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgSEFMRl9NQVhfQVJSQVlfTEVOR1RIID0gTUFYX0FSUkFZX0xFTkdUSCA+Pj4gMTtcblxuICAvKiogVXNlZCB0byBhc3NvY2lhdGUgd3JhcCBtZXRob2RzIHdpdGggdGhlaXIgYml0IGZsYWdzLiAqL1xuICB2YXIgd3JhcEZsYWdzID0gW1xuICAgIFsnYXJ5JywgV1JBUF9BUllfRkxBR10sXG4gICAgWydiaW5kJywgV1JBUF9CSU5EX0ZMQUddLFxuICAgIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gICAgWydjdXJyeScsIFdSQVBfQ1VSUllfRkxBR10sXG4gICAgWydjdXJyeVJpZ2h0JywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXG4gICAgWydwYXJ0aWFsJywgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICAgIFsncGFydGlhbFJpZ2h0JywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICAgIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXG4gIF07XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJyxcbiAgICAgIHdlYWtTZXRUYWcgPSAnW29iamVjdCBXZWFrU2V0XSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOSk7L2csXG4gICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFyID0gUmVnRXhwKHJlUmVnRXhwQ2hhci5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG4gIHZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZyxcbiAgICAgIHJlVHJpbVN0YXJ0ID0gL15cXHMrLyxcbiAgICAgIHJlVHJpbUVuZCA9IC9cXHMrJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd3JhcCBkZXRhaWwgY29tbWVudHMuICovXG4gIHZhciByZVdyYXBDb21tZW50ID0gL1xceyg/OlxcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggLitcXF0gXFwqXFwvKT9cXG4/LyxcbiAgICAgIHJlV3JhcERldGFpbHMgPSAvXFx7XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAoLispXFxdIFxcKi8sXG4gICAgICByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggd29yZHMgY29tcG9zZWQgb2YgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMuICovXG4gIHZhciByZUFzY2lpV29yZCA9IC9bXlxceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceDdmXSsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbiAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoXG4gICAqIFtFUyB0ZW1wbGF0ZSBkZWxpbWl0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10ZW1wbGF0ZS1saXRlcmFsLWxleGljYWwtY29tcG9uZW50cykuXG4gICAqL1xuICB2YXIgcmVFc1RlbXBsYXRlID0gL1xcJFxceyhbXlxcXFx9XSooPzpcXFxcLlteXFxcXH1dKikqKVxcfS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbiAgdmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbiAgdmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cbiAgdmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xuICB2YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFx1ZmUyMC1cXFxcdWZlMmYnLFxuICAgICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICAgIHJzRGluZ2JhdFJhbmdlID0gJ1xcXFx1MjcwMC1cXFxcdTI3YmYnLFxuICAgICAgcnNMb3dlclJhbmdlID0gJ2EtelxcXFx4ZGYtXFxcXHhmNlxcXFx4ZjgtXFxcXHhmZicsXG4gICAgICByc01hdGhPcFJhbmdlID0gJ1xcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjcnLFxuICAgICAgcnNOb25DaGFyUmFuZ2UgPSAnXFxcXHgwMC1cXFxceDJmXFxcXHgzYS1cXFxceDQwXFxcXHg1Yi1cXFxceDYwXFxcXHg3Yi1cXFxceGJmJyxcbiAgICAgIHJzUHVuY3R1YXRpb25SYW5nZSA9ICdcXFxcdTIwMDAtXFxcXHUyMDZmJyxcbiAgICAgIHJzU3BhY2VSYW5nZSA9ICcgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMCcsXG4gICAgICByc1VwcGVyUmFuZ2UgPSAnQS1aXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGRlJyxcbiAgICAgIHJzVmFyUmFuZ2UgPSAnXFxcXHVmZTBlXFxcXHVmZTBmJyxcbiAgICAgIHJzQnJlYWtSYW5nZSA9IHJzTWF0aE9wUmFuZ2UgKyByc05vbkNoYXJSYW5nZSArIHJzUHVuY3R1YXRpb25SYW5nZSArIHJzU3BhY2VSYW5nZTtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG4gIHZhciByc0Fwb3MgPSBcIlsnXFx1MjAxOV1cIixcbiAgICAgIHJzQXN0cmFsID0gJ1snICsgcnNBc3RyYWxSYW5nZSArICddJyxcbiAgICAgIHJzQnJlYWsgPSAnWycgKyByc0JyZWFrUmFuZ2UgKyAnXScsXG4gICAgICByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nLFxuICAgICAgcnNEaWdpdHMgPSAnXFxcXGQrJyxcbiAgICAgIHJzRGluZ2JhdCA9ICdbJyArIHJzRGluZ2JhdFJhbmdlICsgJ10nLFxuICAgICAgcnNMb3dlciA9ICdbJyArIHJzTG93ZXJSYW5nZSArICddJyxcbiAgICAgIHJzTWlzYyA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgcnNCcmVha1JhbmdlICsgcnNEaWdpdHMgKyByc0RpbmdiYXRSYW5nZSArIHJzTG93ZXJSYW5nZSArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzRml0eiA9ICdcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc1JlZ2lvbmFsID0gJyg/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn0nLFxuICAgICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgICAgcnNVcHBlciA9ICdbJyArIHJzVXBwZXJSYW5nZSArICddJyxcbiAgICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG4gIHZhciByc01pc2NMb3dlciA9ICcoPzonICsgcnNMb3dlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzTWlzY1VwcGVyID0gJyg/OicgKyByc1VwcGVyICsgJ3wnICsgcnNNaXNjICsgJyknLFxuICAgICAgcnNPcHRDb250ckxvd2VyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86ZHxsbHxtfHJlfHN8dHx2ZSkpPycsXG4gICAgICByc09wdENvbnRyVXBwZXIgPSAnKD86JyArIHJzQXBvcyArICcoPzpEfExMfE18UkV8U3xUfFZFKSk/JyxcbiAgICAgIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgICByc09wdEpvaW4gPSAnKD86JyArIHJzWldKICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonLFxuICAgICAgcnNPcmRMb3dlciA9ICdcXFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXFxcZHRoKSg/PVxcXFxifFtBLVpfXSknLFxuICAgICAgcnNPcmRVcHBlciA9ICdcXFxcZCooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXFxcZFRIKSg/PVxcXFxifFthLXpfXSknLFxuICAgICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgICAgcnNFbW9qaSA9ICcoPzonICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNTZXEsXG4gICAgICByc1N5bWJvbCA9ICcoPzonICsgW3JzTm9uQXN0cmFsICsgcnNDb21ibyArICc/JywgcnNDb21ibywgcnNSZWdpb25hbCwgcnNTdXJyUGFpciwgcnNBc3RyYWxdLmpvaW4oJ3wnKSArICcpJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhcG9zdHJvcGhlcy4gKi9cbiAgdmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsICdnJyk7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcbiAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrcyBmb3Igc3ltYm9sc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzX2Zvcl9TeW1ib2xzKS5cbiAgICovXG4gIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG4gIHZhciByZVVuaWNvZGUgPSBSZWdFeHAocnNGaXR6ICsgJyg/PScgKyByc0ZpdHogKyAnKXwnICsgcnNTeW1ib2wgKyByc1NlcSwgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBjb21wbGV4IG9yIGNvbXBvdW5kIHdvcmRzLiAqL1xuICB2YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gICAgcnNVcHBlciArICc/JyArIHJzTG93ZXIgKyAnKycgKyByc09wdENvbnRyTG93ZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyLCAnJCddLmpvaW4oJ3wnKSArICcpJyxcbiAgICByc01pc2NVcHBlciArICcrJyArIHJzT3B0Q29udHJVcHBlciArICcoPz0nICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNVcHBlciArICc/JyArIHJzTWlzY0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyLFxuICAgIHJzVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIsXG4gICAgcnNPcmRVcHBlcixcbiAgICByc09yZExvd2VyLFxuICAgIHJzRGlnaXRzLFxuICAgIHJzRW1vamlcbiAgXS5qb2luKCd8JyksICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IHN0cmluZ3Mgd2l0aCBbemVyby13aWR0aCBqb2luZXJzIG9yIGNvZGUgcG9pbnRzIGZyb20gdGhlIGFzdHJhbCBwbGFuZXNdKGh0dHA6Ly9lZXYuZWUvYmxvZy8yMDE1LzA5LzEyL2RhcmstY29ybmVycy1vZi11bmljb2RlLykuICovXG4gIHZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHRoYXQgbmVlZCBhIG1vcmUgcm9idXN0IHJlZ2V4cCB0byBtYXRjaCB3b3Jkcy4gKi9cbiAgdmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcblxuICAvKiogVXNlZCB0byBhc3NpZ24gZGVmYXVsdCBgY29udGV4dGAgb2JqZWN0IHByb3BlcnRpZXMuICovXG4gIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgJ0FycmF5JywgJ0J1ZmZlcicsICdEYXRhVmlldycsICdEYXRlJywgJ0Vycm9yJywgJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLFxuICAgICdGdW5jdGlvbicsICdJbnQ4QXJyYXknLCAnSW50MTZBcnJheScsICdJbnQzMkFycmF5JywgJ01hcCcsICdNYXRoJywgJ09iamVjdCcsXG4gICAgJ1Byb21pc2UnLCAnUmVnRXhwJywgJ1NldCcsICdTdHJpbmcnLCAnU3ltYm9sJywgJ1R5cGVFcnJvcicsICdVaW50OEFycmF5JyxcbiAgICAnVWludDhDbGFtcGVkQXJyYXknLCAnVWludDE2QXJyYXknLCAnVWludDMyQXJyYXknLCAnV2Vha01hcCcsXG4gICAgJ18nLCAnY2xlYXJUaW1lb3V0JywgJ2lzRmluaXRlJywgJ3BhcnNlSW50JywgJ3NldFRpbWVvdXQnXG4gIF07XG5cbiAgLyoqIFVzZWQgdG8gbWFrZSB0ZW1wbGF0ZSBzb3VyY2VVUkxzIGVhc2llciB0byBpZGVudGlmeS4gKi9cbiAgdmFyIHRlbXBsYXRlQ291bnRlciA9IC0xO1xuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbiAgdmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG4gIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gIHR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xuICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICBjbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICBjbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuICBjbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gbWFwIExhdGluIFVuaWNvZGUgbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzLiAqL1xuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xuICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAnXFx4YzAnOiAnQScsICAnXFx4YzEnOiAnQScsICdcXHhjMic6ICdBJywgJ1xceGMzJzogJ0EnLCAnXFx4YzQnOiAnQScsICdcXHhjNSc6ICdBJyxcbiAgICAnXFx4ZTAnOiAnYScsICAnXFx4ZTEnOiAnYScsICdcXHhlMic6ICdhJywgJ1xceGUzJzogJ2EnLCAnXFx4ZTQnOiAnYScsICdcXHhlNSc6ICdhJyxcbiAgICAnXFx4YzcnOiAnQycsICAnXFx4ZTcnOiAnYycsXG4gICAgJ1xceGQwJzogJ0QnLCAgJ1xceGYwJzogJ2QnLFxuICAgICdcXHhjOCc6ICdFJywgICdcXHhjOSc6ICdFJywgJ1xceGNhJzogJ0UnLCAnXFx4Y2InOiAnRScsXG4gICAgJ1xceGU4JzogJ2UnLCAgJ1xceGU5JzogJ2UnLCAnXFx4ZWEnOiAnZScsICdcXHhlYic6ICdlJyxcbiAgICAnXFx4Y2MnOiAnSScsICAnXFx4Y2QnOiAnSScsICdcXHhjZSc6ICdJJywgJ1xceGNmJzogJ0knLFxuICAgICdcXHhlYyc6ICdpJywgICdcXHhlZCc6ICdpJywgJ1xceGVlJzogJ2knLCAnXFx4ZWYnOiAnaScsXG4gICAgJ1xceGQxJzogJ04nLCAgJ1xceGYxJzogJ24nLFxuICAgICdcXHhkMic6ICdPJywgICdcXHhkMyc6ICdPJywgJ1xceGQ0JzogJ08nLCAnXFx4ZDUnOiAnTycsICdcXHhkNic6ICdPJywgJ1xceGQ4JzogJ08nLFxuICAgICdcXHhmMic6ICdvJywgICdcXHhmMyc6ICdvJywgJ1xceGY0JzogJ28nLCAnXFx4ZjUnOiAnbycsICdcXHhmNic6ICdvJywgJ1xceGY4JzogJ28nLFxuICAgICdcXHhkOSc6ICdVJywgICdcXHhkYSc6ICdVJywgJ1xceGRiJzogJ1UnLCAnXFx4ZGMnOiAnVScsXG4gICAgJ1xceGY5JzogJ3UnLCAgJ1xceGZhJzogJ3UnLCAnXFx4ZmInOiAndScsICdcXHhmYyc6ICd1JyxcbiAgICAnXFx4ZGQnOiAnWScsICAnXFx4ZmQnOiAneScsICdcXHhmZic6ICd5JyxcbiAgICAnXFx4YzYnOiAnQWUnLCAnXFx4ZTYnOiAnYWUnLFxuICAgICdcXHhkZSc6ICdUaCcsICdcXHhmZSc6ICd0aCcsXG4gICAgJ1xceGRmJzogJ3NzJyxcbiAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICdcXHUwMTAwJzogJ0EnLCAgJ1xcdTAxMDInOiAnQScsICdcXHUwMTA0JzogJ0EnLFxuICAgICdcXHUwMTAxJzogJ2EnLCAgJ1xcdTAxMDMnOiAnYScsICdcXHUwMTA1JzogJ2EnLFxuICAgICdcXHUwMTA2JzogJ0MnLCAgJ1xcdTAxMDgnOiAnQycsICdcXHUwMTBhJzogJ0MnLCAnXFx1MDEwYyc6ICdDJyxcbiAgICAnXFx1MDEwNyc6ICdjJywgICdcXHUwMTA5JzogJ2MnLCAnXFx1MDEwYic6ICdjJywgJ1xcdTAxMGQnOiAnYycsXG4gICAgJ1xcdTAxMGUnOiAnRCcsICAnXFx1MDExMCc6ICdEJywgJ1xcdTAxMGYnOiAnZCcsICdcXHUwMTExJzogJ2QnLFxuICAgICdcXHUwMTEyJzogJ0UnLCAgJ1xcdTAxMTQnOiAnRScsICdcXHUwMTE2JzogJ0UnLCAnXFx1MDExOCc6ICdFJywgJ1xcdTAxMWEnOiAnRScsXG4gICAgJ1xcdTAxMTMnOiAnZScsICAnXFx1MDExNSc6ICdlJywgJ1xcdTAxMTcnOiAnZScsICdcXHUwMTE5JzogJ2UnLCAnXFx1MDExYic6ICdlJyxcbiAgICAnXFx1MDExYyc6ICdHJywgICdcXHUwMTFlJzogJ0cnLCAnXFx1MDEyMCc6ICdHJywgJ1xcdTAxMjInOiAnRycsXG4gICAgJ1xcdTAxMWQnOiAnZycsICAnXFx1MDExZic6ICdnJywgJ1xcdTAxMjEnOiAnZycsICdcXHUwMTIzJzogJ2cnLFxuICAgICdcXHUwMTI0JzogJ0gnLCAgJ1xcdTAxMjYnOiAnSCcsICdcXHUwMTI1JzogJ2gnLCAnXFx1MDEyNyc6ICdoJyxcbiAgICAnXFx1MDEyOCc6ICdJJywgICdcXHUwMTJhJzogJ0knLCAnXFx1MDEyYyc6ICdJJywgJ1xcdTAxMmUnOiAnSScsICdcXHUwMTMwJzogJ0knLFxuICAgICdcXHUwMTI5JzogJ2knLCAgJ1xcdTAxMmInOiAnaScsICdcXHUwMTJkJzogJ2knLCAnXFx1MDEyZic6ICdpJywgJ1xcdTAxMzEnOiAnaScsXG4gICAgJ1xcdTAxMzQnOiAnSicsICAnXFx1MDEzNSc6ICdqJyxcbiAgICAnXFx1MDEzNic6ICdLJywgICdcXHUwMTM3JzogJ2snLCAnXFx1MDEzOCc6ICdrJyxcbiAgICAnXFx1MDEzOSc6ICdMJywgICdcXHUwMTNiJzogJ0wnLCAnXFx1MDEzZCc6ICdMJywgJ1xcdTAxM2YnOiAnTCcsICdcXHUwMTQxJzogJ0wnLFxuICAgICdcXHUwMTNhJzogJ2wnLCAgJ1xcdTAxM2MnOiAnbCcsICdcXHUwMTNlJzogJ2wnLCAnXFx1MDE0MCc6ICdsJywgJ1xcdTAxNDInOiAnbCcsXG4gICAgJ1xcdTAxNDMnOiAnTicsICAnXFx1MDE0NSc6ICdOJywgJ1xcdTAxNDcnOiAnTicsICdcXHUwMTRhJzogJ04nLFxuICAgICdcXHUwMTQ0JzogJ24nLCAgJ1xcdTAxNDYnOiAnbicsICdcXHUwMTQ4JzogJ24nLCAnXFx1MDE0Yic6ICduJyxcbiAgICAnXFx1MDE0Yyc6ICdPJywgICdcXHUwMTRlJzogJ08nLCAnXFx1MDE1MCc6ICdPJyxcbiAgICAnXFx1MDE0ZCc6ICdvJywgICdcXHUwMTRmJzogJ28nLCAnXFx1MDE1MSc6ICdvJyxcbiAgICAnXFx1MDE1NCc6ICdSJywgICdcXHUwMTU2JzogJ1InLCAnXFx1MDE1OCc6ICdSJyxcbiAgICAnXFx1MDE1NSc6ICdyJywgICdcXHUwMTU3JzogJ3InLCAnXFx1MDE1OSc6ICdyJyxcbiAgICAnXFx1MDE1YSc6ICdTJywgICdcXHUwMTVjJzogJ1MnLCAnXFx1MDE1ZSc6ICdTJywgJ1xcdTAxNjAnOiAnUycsXG4gICAgJ1xcdTAxNWInOiAncycsICAnXFx1MDE1ZCc6ICdzJywgJ1xcdTAxNWYnOiAncycsICdcXHUwMTYxJzogJ3MnLFxuICAgICdcXHUwMTYyJzogJ1QnLCAgJ1xcdTAxNjQnOiAnVCcsICdcXHUwMTY2JzogJ1QnLFxuICAgICdcXHUwMTYzJzogJ3QnLCAgJ1xcdTAxNjUnOiAndCcsICdcXHUwMTY3JzogJ3QnLFxuICAgICdcXHUwMTY4JzogJ1UnLCAgJ1xcdTAxNmEnOiAnVScsICdcXHUwMTZjJzogJ1UnLCAnXFx1MDE2ZSc6ICdVJywgJ1xcdTAxNzAnOiAnVScsICdcXHUwMTcyJzogJ1UnLFxuICAgICdcXHUwMTY5JzogJ3UnLCAgJ1xcdTAxNmInOiAndScsICdcXHUwMTZkJzogJ3UnLCAnXFx1MDE2Zic6ICd1JywgJ1xcdTAxNzEnOiAndScsICdcXHUwMTczJzogJ3UnLFxuICAgICdcXHUwMTc0JzogJ1cnLCAgJ1xcdTAxNzUnOiAndycsXG4gICAgJ1xcdTAxNzYnOiAnWScsICAnXFx1MDE3Nyc6ICd5JywgJ1xcdTAxNzgnOiAnWScsXG4gICAgJ1xcdTAxNzknOiAnWicsICAnXFx1MDE3Yic6ICdaJywgJ1xcdTAxN2QnOiAnWicsXG4gICAgJ1xcdTAxN2EnOiAneicsICAnXFx1MDE3Yyc6ICd6JywgJ1xcdTAxN2UnOiAneicsXG4gICAgJ1xcdTAxMzInOiAnSUonLCAnXFx1MDEzMyc6ICdpaicsXG4gICAgJ1xcdTAxNTInOiAnT2UnLCAnXFx1MDE1Myc6ICdvZScsXG4gICAgJ1xcdTAxNDknOiBcIiduXCIsICdcXHUwMTdmJzogJ3MnXG4gIH07XG5cbiAgLyoqIFVzZWQgdG8gbWFwIGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy4gKi9cbiAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBIVE1MIGVudGl0aWVzIHRvIGNoYXJhY3RlcnMuICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJiMzOTsnOiBcIidcIlxuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGVzY2FwZSBjaGFyYWN0ZXJzIGZvciBpbmNsdXNpb24gaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLiAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICAvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuICB2YXIgZnJlZVBhcnNlRmxvYXQgPSBwYXJzZUZsb2F0LFxuICAgICAgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG4gIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xuICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xuICB2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xuICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4gIC8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG4gIHZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xuICB2YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuICAvKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbiAgdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgICBpZiAodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0oKSk7XG5cbiAgLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbiAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlcixcbiAgICAgIG5vZGVJc0RhdGUgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc0RhdGUsXG4gICAgICBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcCxcbiAgICAgIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLFxuICAgICAgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQsXG4gICAgICBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gICAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlQWdncmVnYXRvcmAgZm9yIGFycmF5cy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlBZ2dyZWdhdG9yKGFycmF5LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RWFjaFJpZ2h0KGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5ldmVyeWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICAgKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZVJpZ2h0YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgbGFzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZVJpZ2h0KGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVstLWxlbmd0aF07XG4gICAgfVxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAqIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgdmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIGFuIEFTQ0lJIGBzdHJpbmdgIGludG8gYW4gYXJyYXkgb2YgaXRzIHdvcmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHdvcmRzIG9mIGBzdHJpbmdgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlQXNjaWlXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZmluZEtleWAgYW5kIGBfLmZpbmRMYXN0S2V5YCxcbiAgICogd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYFxuICAgKiB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFjaEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGl0ZXJhdGUgb3ZlciBgY29sbGVjdGlvbmAuXG4gICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmb3VuZCBlbGVtZW50IG9yIGl0cyBrZXksIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgICA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgZnJvbUluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGJhc2VJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGEgY29tcGFyYXRvci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlSW5kZXhPZldpdGgoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGNvbXBhcmF0b3IoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZWFuYCBhbmQgYF8ubWVhbkJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlTWVhbihhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbmd0aCA/IChiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkgLyBsZW5ndGgpIDogTkFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5T2ZgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVkdWNlYCBhbmQgYF8ucmVkdWNlUmlnaHRgLCB3aXRob3V0IHN1cHBvcnRcbiAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYGNvbGxlY3Rpb25gIHVzaW5nIGBlYWNoRnVuY2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbml0QWNjdW0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3Qgb3IgbGFzdCBlbGVtZW50IG9mXG4gICAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBlYWNoRnVuYykge1xuICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgICAgPyAoaW5pdEFjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICA6IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gICAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAgICogdmFsdWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIGFuZCBgXy5zdW1CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU3VtKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSk7XG4gICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gY3VycmVudCA6IChyZXN1bHQgKyBjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gICAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9QYWlyc2AgYW5kIGBfLnRvUGFpcnNJbmAgd2hpY2ggY3JlYXRlcyBhbiBhcnJheVxuICAgKiBvZiBrZXktdmFsdWUgcGFpcnMgZm9yIGBvYmplY3RgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzIG9mIGBwcm9wc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVG9QYWlycyhvYmplY3QsIHByb3BzKSB7XG4gICAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBba2V5LCBvYmplY3Rba2V5XV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICogb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvdW50SG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgKytyZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYGl0ZXJhdG9yYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yIFRoZSBpdGVyYXRvciB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgIHZhciBkYXRhLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAodmFsdWUgPT09IHBsYWNlaG9sZGVyIHx8IHZhbHVlID09PSBQTEFDRUhPTERFUikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5sYXN0SW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggKyAxO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDEuMS4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdmb28nOiBfLmNvbnN0YW50KCdmb28nKSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdiYXInOiBsb2Rhc2guY29uc3RhbnQoJ2JhcicpIH0pO1xuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYmFyKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanMuXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL1xuICB2YXIgcnVuSW5Db250ZXh0ID0gKGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGNvbnRleHQgPT0gbnVsbCA/IHJvb3QgOiBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKTtcblxuICAgIC8qKiBCdWlsdC1pbiBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG4gICAgdmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyBjb250ZXh0LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgU3ltYm9sID0gY29udGV4dC5TeW1ib2wsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLFxuICAgICAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICAgICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1JdGVyYXRvciA9IFN5bWJvbCA/IFN5bWJvbC5pdGVyYXRvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgICAgICBmdW5jKHt9LCAnJywge30pO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSgpKTtcblxuICAgIC8qKiBNb2NrZWQgYnVpbHQtaW5zLiAqL1xuICAgIHZhciBjdHhDbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCAhPT0gcm9vdC5jbGVhclRpbWVvdXQgJiYgY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGN0eE5vdyA9IERhdGUgJiYgRGF0ZS5ub3cgIT09IHJvb3QuRGF0ZS5ub3cgJiYgRGF0ZS5ub3csXG4gICAgICAgIGN0eFNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQgIT09IHJvb3Quc2V0VGltZW91dCAmJiBjb250ZXh0LnNldFRpbWVvdXQ7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IERhdGUubm93LFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgICAgICBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgIHZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShjb250ZXh0LCAnRGF0YVZpZXcnKSxcbiAgICAgICAgTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdNYXAnKSxcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxuICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gICAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBpbXBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAgICAgKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAgICAgKiBvciBtYXkgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHNlcXVlbmNlXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gICAgICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gICAgICpcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gICAgICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAgICAgKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICAgICAqIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgYXJyYXlzIGFuZCBjYW4gZ3JlYXRseSByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gICAgICogb25lIGFyZ3VtZW50LiBUaGUgaGV1cmlzdGljIGZvciB3aGV0aGVyIGEgc2VjdGlvbiBxdWFsaWZpZXMgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYF8jdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gbG9kYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGhhdmUgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHNoaWZ0YCwgYHNvcnRgLCBgc3BsaWNlYCwgYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gICAgICogYHJlcGxhY2VgIGFuZCBgc3BsaXRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBhdGAsIGBjb21wYWN0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLCBgZmluZGAsXG4gICAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXG4gICAgICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAgICAgKiBgYmVmb3JlYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNhc3RBcnJheWAsIGBjaGFpbmAsIGBjaHVua2AsXG4gICAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXG4gICAgICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gICAgICogYGRpZmZlcmVuY2VgLCBgZGlmZmVyZW5jZUJ5YCwgYGRpZmZlcmVuY2VXaXRoYCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCxcbiAgICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcbiAgICAgKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gICAgICogYGZsYXR0ZW5EZXB0aGAsIGBmbGlwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZyb21QYWlyc2AsIGBmdW5jdGlvbnNgLFxuICAgICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcbiAgICAgKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAgICAgKiBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWF0Y2hlc1Byb3BlcnR5YCxcbiAgICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXG4gICAgICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gICAgICogYG92ZXJFdmVyeWAsIGBvdmVyU29tZWAsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwYXJ0aXRpb25gLCBgcGlja2AsXG4gICAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxuICAgICAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gICAgICogYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2FtcGxlU2l6ZWAsIGBzZXRgLCBgc2V0V2l0aGAsIGBzaHVmZmxlYCxcbiAgICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICAgICAqIGB0b1BhaXJzYCwgYHRvUGFpcnNJbmAsIGB0b1BhdGhgLCBgdG9QbGFpbk9iamVjdGAsIGB0cmFuc2Zvcm1gLCBgdW5hcnlgLFxuICAgICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXG4gICAgICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgeG9yQnlgLCBgeG9yV2l0aGAsIGB6aXBgLFxuICAgICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBhcmUgKipub3QqKiBjaGFpbmFibGUgYnkgZGVmYXVsdCBhcmU6XG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxuICAgICAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICAgICAqIGBkZWZhdWx0VG9gLCBgZGl2aWRlYCwgYGVhY2hgLCBgZWFjaFJpZ2h0YCwgYGVuZHNXaXRoYCwgYGVxYCwgYGVzY2FwZWAsXG4gICAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcbiAgICAgKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gICAgICogYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCwgYGdldGAsIGBndGAsIGBndGVgLCBgaGFzYCxcbiAgICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcbiAgICAgKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAgICAgKiBgaXNCb29sZWFuYCwgYGlzQnVmZmVyYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCxcbiAgICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXG4gICAgICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAgICAgKiBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNPYmplY3RMaWtlYCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLFxuICAgICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gICAgICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gICAgICogYGxvd2VyQ2FzZWAsIGBsb3dlckZpcnN0YCwgYGx0YCwgYGx0ZWAsIGBtYXhgLCBgbWF4QnlgLCBgbWVhbmAsIGBtZWFuQnlgLFxuICAgICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcbiAgICAgKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAgICAgKiBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2FtcGxlYCwgYHNoaWZ0YCwgYHNpemVgLFxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gICAgICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICAgICAqIGBzdHViT2JqZWN0YCwgYHN0dWJTdHJpbmdgLCBgc3R1YlRydWVgLCBgc3VidHJhY3RgLCBgc3VtYCwgYHN1bUJ5YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXG4gICAgICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICAgICAqIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGB0cnVuY2F0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGB1cHBlckNhc2VgLFxuICAgICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoc3F1YXJlKTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAwO1xuICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gICAgICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcbiAgICAgIHRoaXMuX192aWV3c19fID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGNvcHlBcnJheSh0aGlzLl9faXRlcmF0ZWVzX18pO1xuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICByZXN1bHQuX192aWV3c19fID0gY29weUFycmF5KHRoaXMuX192aWV3c19fKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuICAgICAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gICAgICBpZiAoIWlzQXJyIHx8ICghaXNSaWdodCAmJiBhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGBMYXp5V3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGJhc2VMb2Rhc2hgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICAgIEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG4gICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgLS10aGlzLnNpemU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgYWRkXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQGFsaWFzIHB1c2hcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gICAgICB9XG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICBTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcbiAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICAgICAgKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVTaXplYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAgICAgKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFnZ3JlZ2F0ZXMgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIG9uIGBhY2N1bXVsYXRvcmAgd2l0aCBrZXlzIHRyYW5zZm9ybWVkXG4gICAgICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICAgICAqIHZhbHVlIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBza2lwID0gb2JqZWN0ID09IG51bGw7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBza2lwID8gdW5kZWZpbmVkIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xhbXBgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gICAgICogdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIERlZXAgY2xvbmVcbiAgICAgKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZDtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICAgICAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICAgICAgPyAoaXNGbGF0ID8gZ2V0QWxsS2V5c0luIDogZ2V0QWxsS2V5cylcbiAgICAgICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgICAgIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICAgICAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmIChwcm9wcykge1xuICAgICAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY29uZm9ybXNUb2Agd2hpY2ggYWNjZXB0cyBgcHJvcHNgIHRvIGNoZWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcykge1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tsZW5ndGhdLFxuICAgICAgICAgICAgcHJlZGljYXRlID0gc291cmNlW2tleV0sXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgIGlmICgodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB8fCAhcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZGVsYXlgIGFuZCBgXy5kZWZlcmAgd2hpY2ggYWNjZXB0cyBgYXJnc2BcbiAgICAgKiB0byBwcm92aWRlIHRvIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICogQHJldHVybnMge251bWJlcnxPYmplY3R9IFJldHVybnMgdGhlIHRpbWVyIGlkIG9yIHRpbWVvdXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHsgZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3MpOyB9LCB3YWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaFJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqL1xuICAgIHZhciBiYXNlRWFjaFJpZ2h0ID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93blJpZ2h0LCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmV2ZXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAgICAgKiBgY29tcGFyYXRvcmAgdG8gZGV0ZXJtaW5lIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAoY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkpXG4gICAgICAgICAgICAgIDogY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZClcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICB2YXIgY29tcHV0ZWQgPSBjdXJyZW50LFxuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWxsYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmaWxsLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGZpbGwgYGFycmF5YCB3aXRoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiBsZW5ndGgpID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICBpZiAoZW5kIDwgMCkge1xuICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgZW5kID0gc3RhcnQgPiBlbmQgPyAwIDogdG9MZW5ndGgoZW5kKTtcbiAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICBhcnJheVtzdGFydCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbHRlcmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgICAgIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gICAgICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlRm9yYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXNcbiAgICAgKiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgdmFyIGJhc2VGb3JSaWdodCA9IGNyZWF0ZUJhc2VGb3IodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duUmlnaHRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvclJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZ1bmN0aW9uc2Agd2hpY2ggY3JlYXRlcyBhbiBhcnJheSBvZlxuICAgICAqIGBvYmplY3RgIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZpbHRlcmVkIGZyb20gYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGZpbHRlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGdW5jdGlvbnMob2JqZWN0LCBwcm9wcykge1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob2JqZWN0W2tleV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAgICAgKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAgICAgKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICAgICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgICAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICAgICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ3RgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID4gb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluUmFuZ2VgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBudW1iZXJgIGlzIGluIHRoZSByYW5nZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIG51bWJlciA+PSBuYXRpdmVNaW4oc3RhcnQsIGVuZCkgJiYgbnVtYmVyIDwgbmF0aXZlTWF4KHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5pbnRlcnNlY3Rpb25gLCB3aXRob3V0IHN1cHBvcnRcbiAgICAgKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgdGhhdCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheXMgVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2Ygc2hhcmVkIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmNsdWRlcyA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXlzWzBdLmxlbmd0aCxcbiAgICAgICAgICBvdGhMZW5ndGggPSBhcnJheXMubGVuZ3RoLFxuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoLFxuICAgICAgICAgIGNhY2hlcyA9IEFycmF5KG90aExlbmd0aCksXG4gICAgICAgICAgbWF4TGVuZ3RoID0gSW5maW5pdHksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tvdGhJbmRleF07XG4gICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZSkge1xuICAgICAgICAgIGFycmF5ID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgICAgICB9XG4gICAgICAgIG1heExlbmd0aCA9IG5hdGl2ZU1pbihhcnJheS5sZW5ndGgsIG1heExlbmd0aCk7XG4gICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUgfHwgKGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkpXG4gICAgICAgICAgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBhcnJheSA9IGFycmF5c1swXTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQubGVuZ3RoIDwgbWF4TGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICAgICAgaWYgKCEoc2VlblxuICAgICAgICAgICAgICA/IGNhY2hlSGFzKHNlZW4sIGNvbXB1dGVkKVxuICAgICAgICAgICAgICA6IGluY2x1ZGVzKHJlc3VsdCwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgb3RoSW5kZXggPSBvdGhMZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKC0tb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgICAgICBpZiAoIShjYWNoZVxuICAgICAgICAgICAgICAgICAgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpXG4gICAgICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52ZXJ0YCBhbmQgYF8uaW52ZXJ0QnlgIHdoaWNoIGludmVydHNcbiAgICAgKiBgb2JqZWN0YCB3aXRoIHZhbHVlcyB0cmFuc2Zvcm1lZCBieSBgaXRlcmF0ZWVgIGFuZCBzZXQgYnkgYHNldHRlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIGl0ZXJhdGVlKHZhbHVlKSwga2V5LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW52b2tlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBtZXRob2QgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhcHBseShmdW5jLCBvYmplY3QsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FycmF5QnVmZmVyYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFycmF5QnVmZmVyVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRGF0ZWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNEYXRlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAgICAgKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAgICAgKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICAgICAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gICAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gICAgICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgICAgICBvYmpJc09iaiA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgICAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNTYW1lVGFnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgICAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICAgICAgKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gICAgICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubHRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDwgb3RoZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1lcmdlYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgbWVyZ2VkIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgICBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBiYXNlTWVyZ2UsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlTWVyZ2VgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAgICAgKiBkZWVwIG1lcmdlcyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIG1lcmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gbWVyZ2VGdW5jIFRoZSBmdW5jdGlvbiB0byBtZXJnZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICB2YXIgb2JqVmFsdWUgPSBzYWZlR2V0KG9iamVjdCwga2V5KSxcbiAgICAgICAgICBzcmNWYWx1ZSA9IHNhZmVHZXQoc291cmNlLCBrZXkpLFxuICAgICAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLFxuICAgICAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgaWYgKGlzQXJyIHx8IGlzQnVmZiB8fCBpc1R5cGVkKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY29weUFycmF5KG9ialZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjbG9uZUJ1ZmZlcihzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzVHlwZWQpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICBpZiAoaXNBcmd1bWVudHMob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghaXNPYmplY3Qob2JqVmFsdWUpIHx8IGlzRnVuY3Rpb24ob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBtZXJnZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubnRoYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VOdGgoYXJyYXksIG4pIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuICs9IG4gPCAwID8gbGVuZ3RoIDogMDtcbiAgICAgIHJldHVybiBpc0luZGV4KG4sIGxlbmd0aCkgPyBhcnJheVtuXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBvcmRlcnMgVGhlIHNvcnQgb3JkZXJzIG9mIGBpdGVyYXRlZXNgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycykge1xuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoID8gaXRlcmF0ZWVzIDogW2lkZW50aXR5XSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgICAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgICAgIHZhbHVlID0gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuXG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEFsbEJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gICAgICogc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4T2YgPSBjb21wYXJhdG9yID8gYmFzZUluZGV4T2ZXaXRoIDogYmFzZUluZGV4T2YsXG4gICAgICAgICAgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIHNlZW4gPSBhcnJheTtcblxuICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzID0gY29weUFycmF5KHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2VlbiA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSAwLFxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZihzZWVuLCBjb21wdXRlZCwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSkgPiAtMSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSBhcnJheSkge1xuICAgICAgICAgICAgc3BsaWNlLmNhbGwoc2VlbiwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3BsaWNlLmNhbGwoYXJyYXksIGZyb21JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wdWxsQXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaW5kaXZpZHVhbFxuICAgICAqIGluZGV4ZXMgb3IgY2FwdHVyaW5nIHRoZSByZW1vdmVkIGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGluZGV4ZXMgVGhlIGluZGV4ZXMgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA/IGluZGV4ZXMubGVuZ3RoIDogMCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXMgPSBpbmRleDtcbiAgICAgICAgICBpZiAoaXNJbmRleChpbmRleCkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VVbnNldChhcnJheSwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICAgICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5nZWAgYW5kIGBfLnJhbmdlUmlnaHRgIHdoaWNoIGRvZXNuJ3RcbiAgICAgKiBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgobmF0aXZlQ2VpbCgoZW5kIC0gc3RhcnQpIC8gKHN0ZXAgfHwgMSkpLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlcGVhdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXBlYXQoc3RyaW5nLCBuKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICBpZiAoIXN0cmluZyB8fCBuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgLy8gTGV2ZXJhZ2UgdGhlIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nIGFsZ29yaXRobSBmb3IgYSBmYXN0ZXIgcmVwZWF0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V4cG9uZW50aWF0aW9uX2J5X3NxdWFyaW5nIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgIHJlc3VsdCArPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgbiA9IG5hdGl2ZUZsb29yKG4gLyAyKTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChuKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zYW1wbGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIGFycmF5U2FtcGxlKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlU2l6ZWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7XG4gICAgICB2YXIgYXJyYXkgPSB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoYXJyYXksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIHBhdGggY3JlYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gICAgICB3aGlsZSAobmVzdGVkICE9IG51bGwgJiYgKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICAgIDogKGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NpZ25WYWx1ZShuZXN0ZWQsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldERhdGFgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc29jaWF0ZSBtZXRhZGF0YSB3aXRoLlxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgbWV0YU1hcC5zZXQoZnVuYywgZGF0YSk7XG4gICAgICByZXR1cm4gZnVuYztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBiYXNlU2V0VG9TdHJpbmcgPSAhZGVmaW5lUHJvcGVydHkgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIHN0cmluZykge1xuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAgICdlbnVtZXJhYmxlJzogZmFsc2UsXG4gICAgICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zbGljZWAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2xpY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiAobGVuZ3RoICsgc3RhcnQpO1xuICAgICAgfVxuICAgICAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6ICgoZW5kIC0gc3RhcnQpID4+PiAwKTtcbiAgICAgIHN0YXJ0ID4+Pj0gMDtcblxuICAgICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvbWVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gIXJlc3VsdDtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4YCB3aGljaFxuICAgICAqIHBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBvZiBgYXJyYXlgIHRvIGRldGVybWluZSB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYFxuICAgICAqIHNob3VsZCBiZSBpbnNlcnRlZCBpbnRvIGBhcnJheWAgaW4gb3JkZXIgdG8gbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXRIaWdoZXN0XSBTcGVjaWZ5IHJldHVybmluZyB0aGUgaGlnaGVzdCBxdWFsaWZpZWQgaW5kZXguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHJldEhpZ2hlc3QpIHtcbiAgICAgIHZhciBsb3cgPSAwLFxuICAgICAgICAgIGhpZ2ggPSBhcnJheSA9PSBudWxsID8gbG93IDogYXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09PSB2YWx1ZSAmJiBoaWdoIDw9IEhBTEZfTUFYX0FSUkFZX0xFTkdUSCkge1xuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDEsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gYXJyYXlbbWlkXTtcblxuICAgICAgICAgIGlmIChjb21wdXRlZCAhPT0gbnVsbCAmJiAhaXNTeW1ib2woY29tcHV0ZWQpICYmXG4gICAgICAgICAgICAgIChyZXRIaWdoZXN0ID8gKGNvbXB1dGVkIDw9IHZhbHVlKSA6IChjb21wdXRlZCA8IHZhbHVlKSkpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaWRlbnRpdHksIHJldEhpZ2hlc3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZEluZGV4QnlgIGFuZCBgXy5zb3J0ZWRMYXN0SW5kZXhCeWBcbiAgICAgKiB3aGljaCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGVcbiAgICAgKiB0aGVpciBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YWx1ZSA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLFxuICAgICAgICAgIHZhbElzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IG5hdGl2ZUZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIG90aElzRGVmaW5lZCA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBjb21wdXRlZCA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChjb21wdXRlZCk7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IHJldEhpZ2hlc3QgfHwgb3RoSXNSZWZsZXhpdmU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBvdGhJc0RlZmluZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc1N5bWJvbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZFVuaXFgIGFuZCBgXy5zb3J0ZWRVbmlxQnlgIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIGlmICghaW5kZXggfHwgIWVxKGNvbXB1dGVkLCBzZWVuKSkge1xuICAgICAgICAgIHZhciBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9OdW1iZXJgIHdoaWNoIGRvZXNuJ3QgZW5zdXJlIGNvcnJlY3RcbiAgICAgKiBjb252ZXJzaW9ucyBvZiBiaW5hcnksIGhleGFkZWNpbWFsLCBvciBvY3RhbCBzdHJpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51cGRhdGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHJldHVybiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdXBkYXRlcihiYXNlR2V0KG9iamVjdCwgcGF0aCkpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZHJvcFdoaWxlYCBhbmQgYF8udGFrZVdoaWxlYFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiZcbiAgICAgICAgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cblxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZXJmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFjdGlvbnMsIGZ1bmN0aW9uKHJlc3VsdCwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHRdLCBhY3Rpb24uYXJncykpO1xuICAgICAgfSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ueG9yYCwgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VVbmlxKGFycmF5c1swXSkgOiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sXG4gICAgICAgICAgICBvdGhJbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK290aEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG90aEluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gYmFzZURpZmZlcmVuY2UocmVzdWx0W2luZGV4XSB8fCBhcnJheSwgYXJyYXlzW290aEluZGV4XSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKHJlc3VsdCwgMSksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uemlwT2JqZWN0YCB3aGljaCBhc3NpZ25zIHZhbHVlcyB1c2luZyBgYXNzaWduRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25GdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVppcE9iamVjdChwcm9wcywgdmFsdWVzLCBhc3NpZ25GdW5jKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgdmFsc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0LCBwcm9wc1tpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgYGJhc2VSZXN0YCBhbGlhcyB3aGljaCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgaWRlbnRpdHlgIGJ5IG1vZHVsZVxuICAgICAqIHJlcGxhY2VtZW50IHBsdWdpbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBjYXN0UmVzdCA9IGJhc2VSZXN0O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gICAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgY2xlYXJUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vY2xlYXJUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBpZCBUaGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3Qgb2YgdGhlIHRpbWVyIHRvIGNsZWFyLlxuICAgICAqL1xuICAgIHZhciBjbGVhclRpbWVvdXQgPSBjdHhDbGVhclRpbWVvdXQgfHwgZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiByb290LmNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICBidWZmZXIuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAgICpcbiAgICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgcmFuZ2VMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcblxuICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYWNjdW11bGF0b3IpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcbiAgICAgICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyZ3MsIGhvbGRlcnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSAtIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihmdW5jcykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZnVuY3MubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcbiAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlcmVxICYmICF3cmFwcGVyICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pICYmXG4gICAgICAgICAgICAgICAgZGF0YVsxXSA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSAmJlxuICAgICAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKVxuICAgICAgICAgICAgICA/IHdyYXBwZXJbZnVuY05hbWVdKClcbiAgICAgICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIucGxhbnQodmFsdWUpLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxlbmd0aCA/IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkXG4gICAgICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyaWVkKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxuICAgICAgICAgICAgICBob2xkZXJzQ291bnQgPSBjb3VudEhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xuICAgICAgICBpZiAoaXNDdXJyaWVkICYmIGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHRoaXNBcmcsXG4gICAgICAgICAgICBhcmdzLCBuZXdIb2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmludmVydEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludmVydGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmVydGVyKHNldHRlciwgdG9JdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgdG9JdGVyYXRlZShpdGVyYXRlZSksIHt9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSB1c2VkIGZvciBgdW5kZWZpbmVkYCBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXRoT3BlcmF0aW9uKG9wZXJhdG9yLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9TdHJpbmcob3RoZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb051bWJlcihvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ub3ZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU92ZXIoYXJyYXlGdW5jKSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICB2YXIgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIGBsZW5ndGhgLiBUaGUgYGNoYXJzYCBzdHJpbmdcbiAgICAgKiBpcyB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VlZHMgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZCA/ICcgJyA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG5cbiAgICAgIHZhciBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzTGVuZ3RoID8gYmFzZVJlcGVhdChjaGFycywgbGVuZ3RoKSA6IGNoYXJzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VSZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwobGVuZ3RoIC8gc3RyaW5nU2l6ZShjaGFycykpKTtcbiAgICAgIHJldHVybiBoYXNVbmljb2RlKGNoYXJzKVxuICAgICAgICA/IGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHJlc3VsdCksIDAsIGxlbmd0aCkuam9pbignJylcbiAgICAgICAgOiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gICAgICogb2YgYHRoaXNBcmdgIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXG4gICAgICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSByZWxhdGlvbmFsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlbGF0aW9uYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24ob3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBvdGhlciA9IHRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgYGZ1bmNgIHdyYXBwZXIuXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNDdXJyeSA9IGJpdG1hc2sgJiBXUkFQX0NVUlJZX0ZMQUcsXG4gICAgICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IHBhcnRpYWxzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XG5cbiAgICAgIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XG5cbiAgICAgIGlmICghKGJpdG1hc2sgJiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgICAgIG5ld0hvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLnJvdW5kYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gMCA6IG5hdGl2ZU1pbih0b0ludGVnZXIocHJlY2lzaW9uKSwgMjkyKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbikge1xuICAgICAgICAgIC8vIFNoaWZ0IHdpdGggZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYXZvaWQgZmxvYXRpbmctcG9pbnQgaXNzdWVzLlxuICAgICAgICAgIC8vIFNlZSBbTUROXShodHRwczovL21kbi5pby9yb3VuZCNFeGFtcGxlcykgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICB2YXIgcGFpciA9ICh0b1N0cmluZyhudW1iZXIpICsgJ2UnKS5zcGxpdCgnZScpLFxuICAgICAgICAgICAgICB2YWx1ZSA9IGZ1bmMocGFpclswXSArICdlJyArICgrcGFpclsxXSArIHByZWNpc2lvbikpO1xuXG4gICAgICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyAnZScpLnNwbGl0KCdlJyk7XG4gICAgICAgICAgcmV0dXJuICsocGFpclswXSArICdlJyArICgrcGFpclsxXSAtIHByZWNpc2lvbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICAgICAqL1xuICAgIHZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gICAgICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYF8udG9QYWlyc2Agb3IgYF8udG9QYWlyc0luYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYWlycyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUb1BhaXJzKGtleXNGdW5jKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciB0YWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcpIHtcbiAgICAgICAgICByZXR1cm4gbWFwVG9BcnJheShvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvUGFpcnMob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LCBrZXlzRnVuYyhvYmplY3QpKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZWl0aGVyIGN1cnJpZXMgb3IgaW52b2tlcyBgZnVuY2Agd2l0aCBvcHRpb25hbFxuICAgICAqIGB0aGlzYCBiaW5kaW5nIGFuZCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBmdW5jIFRoZSBmdW5jdGlvbiBvciBtZXRob2QgbmFtZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICAgICAqICAgIDEgLSBgXy5iaW5kYFxuICAgICAqICAgIDIgLSBgXy5iaW5kS2V5YFxuICAgICAqICAgIDQgLSBgXy5jdXJyeWAgb3IgYF8uY3VycnlSaWdodGAgb2YgYSBib3VuZCBmdW5jdGlvblxuICAgICAqICAgIDggLSBgXy5jdXJyeWBcbiAgICAgKiAgIDE2IC0gYF8uY3VycnlSaWdodGBcbiAgICAgKiAgIDMyIC0gYF8ucGFydGlhbGBcbiAgICAgKiAgIDY0IC0gYF8ucGFydGlhbFJpZ2h0YFxuICAgICAqICAxMjggLSBgXy5yZWFyZ2BcbiAgICAgKiAgMjU2IC0gYF8uYXJ5YFxuICAgICAqICA1MTIgLSBgXy5mbGlwYFxuICAgICAqIEBwYXJhbSB7Kn0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5LCBhcml0eSkge1xuICAgICAgdmFyIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUc7XG4gICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyk7XG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGFyeSA9IGFyeSA9PT0gdW5kZWZpbmVkID8gYXJ5IDogbmF0aXZlTWF4KHRvSW50ZWdlcihhcnkpLCAwKTtcbiAgICAgIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZCA/IGFyaXR5IDogdG9JbnRlZ2VyKGFyaXR5KTtcbiAgICAgIGxlbmd0aCAtPSBob2xkZXJzID8gaG9sZGVycy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAoYml0bWFzayAmIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsc1JpZ2h0ID0gcGFydGlhbHMsXG4gICAgICAgICAgICBob2xkZXJzUmlnaHQgPSBob2xkZXJzO1xuXG4gICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkIDogZ2V0RGF0YShmdW5jKTtcblxuICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgIGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzLCBwYXJ0aWFsc1JpZ2h0LCBob2xkZXJzUmlnaHQsXG4gICAgICAgIGFyZ1BvcywgYXJ5LCBhcml0eVxuICAgICAgXTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgfVxuICAgICAgZnVuYyA9IG5ld0RhdGFbMF07XG4gICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgIHRoaXNBcmcgPSBuZXdEYXRhWzJdO1xuICAgICAgcGFydGlhbHMgPSBuZXdEYXRhWzNdO1xuICAgICAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gICAgICBhcml0eSA9IG5ld0RhdGFbOV0gPSBuZXdEYXRhWzldID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAoaXNCaW5kS2V5ID8gMCA6IGZ1bmMubGVuZ3RoKVxuICAgICAgICA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcblxuICAgICAgaWYgKCFhcml0eSAmJiBiaXRtYXNrICYgKFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRykpIHtcbiAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gICAgICB9XG4gICAgICBpZiAoIWJpdG1hc2sgfHwgYml0bWFzayA9PSBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKTtcbiAgICAgIH0gZWxzZSBpZiAoYml0bWFzayA9PSBXUkFQX0NVUlJZX0ZMQUcgfHwgYml0bWFzayA9PSBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpO1xuICAgICAgfSBlbHNlIGlmICgoYml0bWFzayA9PSBXUkFQX1BBUlRJQUxfRkxBRyB8fCBiaXRtYXNrID09IChXUkFQX0JJTkRfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHKSkgJiYgIWhvbGRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVBhcnRpYWwoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlSHlicmlkLmFwcGx5KHVuZGVmaW5lZCwgbmV3RGF0YSk7XG4gICAgICB9XG4gICAgICB2YXIgc2V0dGVyID0gZGF0YSA/IGJhc2VTZXREYXRhIDogc2V0RGF0YTtcbiAgICAgIHJldHVybiBzZXRXcmFwVG9TdHJpbmcoc2V0dGVyKHJlc3VsdCwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgYF8uZGVmYXVsdHNgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uYXNzaWduSW5gIHVzZSB0byBhc3NpZ24gcHJvcGVydGllc1xuICAgICAqIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzXG4gICAgICogdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tRGVmYXVsdHNBc3NpZ25JbihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgICAgICByZXR1cm4gc3JjVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c0RlZXBgIHRvIGN1c3RvbWl6ZSBpdHMgYF8ubWVyZ2VgIHVzZSB0byBtZXJnZSBzb3VyY2VcbiAgICAgKiBvYmplY3RzIGludG8gZGVzdGluYXRpb24gb2JqZWN0cyB0aGF0IGFyZSBwYXNzZWQgdGhydS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBvYmpWYWx1ZSBUaGUgZGVzdGluYXRpb24gdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgcGFyZW50IG9iamVjdCBvZiBgb2JqVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHBhcmVudCBvYmplY3Qgb2YgYHNyY1ZhbHVlYC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIHNvdXJjZSB2YWx1ZXMgYW5kIHRoZWlyIG1lcmdlZFxuICAgICAqICBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICAgIGlmIChpc09iamVjdChvYmpWYWx1ZSkgJiYgaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG9ialZhbHVlKTtcbiAgICAgICAgYmFzZU1lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwgdW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgIHN0YWNrWydkZWxldGUnXShzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vbWl0YCB0byBjdXN0b21pemUgaXRzIGBfLmNsb25lRGVlcGAgdXNlIHRvIG9ubHkgY2xvbmUgcGxhaW5cbiAgICAgKiBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdW5jbG9uZWQgdmFsdWUgb3IgYHVuZGVmaW5lZGAgdG8gZGVmZXIgY2xvbmluZyB0byBgXy5jbG9uZURlZXBgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gdW5kZWZpbmVkIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICAgICAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gICAgICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAgICAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgaWYgKHNlZW4pIHtcbiAgICAgICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAgICAgKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICAgICAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgY2FzZSBkYXRlVGFnOlxuICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICAgICAgY2FzZSBlcnJvclRhZzpcbiAgICAgICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gICAgICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpdGVyYXRlZVwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBiYXNlSXRlcmF0ZWVgLlxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiB0aGUgY3JlYXRlZCBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGVlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJlc3VsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHVubWFza2VkKSB7XG4gICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gICAgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgICAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICAgICAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgICAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd3JhcHBlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIGRldGFpbHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB2YXIgaXNNYXNrYWJsZSA9IGNvcmVKc0RhdGEgPyBpc0Z1bmN0aW9uIDogc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gICAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kXG4gICAgICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAgICAgKiBhbiBleGNlcHRpb24gZm9yIGEgc2FmZSBjb21iaW5lZCBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YFxuICAgICAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgKFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHIHwgV1JBUF9BUllfRkxBRyk7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcpICYmIChkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FmZUdldChvYmplY3QsIGtleSkge1xuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gICAgICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgIHJldHVybiByb290LnNldFRpbWVvdXQoZnVuYywgd2FpdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGB3cmFwcGVyYCB0byBtaW1pYyB0aGUgc291cmNlIG9mIGByZWZlcmVuY2VgXG4gICAgICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdyYXBUb1N0cmluZyh3cmFwcGVyLCByZWZlcmVuY2UsIGJpdG1hc2spIHtcbiAgICAgIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAgICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBhcnJheS5sZW5ndGggPSBzaXplO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHdyYXBwZXIgYGRldGFpbHNgIGJhc2VkIG9uIGBiaXRtYXNrYCBmbGFncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xuICAgICAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgdmFsdWUgPSAnXy4nICsgcGFpclswXTtcbiAgICAgICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XG4gICAgICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19pbmRleF9fICA9IHdyYXBwZXIuX19pbmRleF9fO1xuICAgICAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGFycmF5YCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmtcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUpLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHNpemUgPCAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gICAgICogYW5kL29yIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIG90aGVyID0gXy5jb25jYXQoYXJyYXksIDIsIFszXSwgW1s0XV0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob3RoZXIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCAtIDEpLFxuICAgICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbEJ5YCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kaWZmZXJlbmNlQnkoW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCBbeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBvcmRlciBhbmRcbiAgICAgKiByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsV2l0aGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VXaXRoKG9iamVjdHMsIFt7ICd4JzogMSwgJ3knOiAyIH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoY29tcGFyYXRvcikpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xuICAgICAqIC8vID0+IFs0LCAnKicsICcqJywgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ3BlYmJsZXMnOyB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMFxuICAgICAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJTkZJTklUWSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVuIGBhcnJheWAgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIFsyLCBbMywgWzRdXSwgNV1dO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZXB0aChhcnJheSwgZGVwdGgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8udG9QYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogZnJvbSBrZXktdmFsdWUgYHBhaXJzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZmlyc3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5oZWFkKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoZWFkKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDAsIC0xKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMl1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZClcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgaWYgKGl0ZXJhdGVlID09PSBsYXN0KG1hcHBlZCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzXG4gICAgICogb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBlbGVtZW50cyBpbiBgYXJyYXlgIGludG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9JywnXSBUaGUgZWxlbWVudCBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgam9pbmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5qb2luKFsnYScsICdiJywgJ2MnXSwgJ34nKTtcbiAgICAgKiAvLyA9PiAnYX5ifmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/ICcnIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgICA/IHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCBhdCBpbmRleCBgbmAgb2YgYGFycmF5YC4gSWYgYG5gIGlzIG5lZ2F0aXZlLCB0aGUgbnRoXG4gICAgICogZWxlbWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAtMik7XG4gICAgICogLy8gPT4gJ2MnO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZU50aChhcnJheSwgdG9JbnRlZ2VyKG4pKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBnaXZlbiB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5yZW1vdmVgXG4gICAgICogdG8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGwoYXJyYXksICdhJywgJ2MnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIHZhciBwdWxsID0gYmFzZVJlc3QocHVsbEFsbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGwoYXJyYXksIFsnYScsICdjJ10pO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbChhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZUJ5YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDMgfSwgeyAneCc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxCeShhcnJheSwgW3sgJ3gnOiAxIH0sIHsgJ3gnOiAzIH1dLCAneCcpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsQnkoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VXaXRoYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAzLCAneSc6IDQgfSwgeyAneCc6IDUsICd5JzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbFdpdGgoYXJyYXksIFt7ICd4JzogMywgJ3knOiA0IH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogNSwgJ3knOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbFdpdGgoYXJyYXksIHZhbHVlcywgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gYGluZGV4ZXNgIGFuZCByZXR1cm5zIGFuXG4gICAgICogYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICogdmFyIHB1bGxlZCA9IF8ucHVsbEF0KGFycmF5LCBbMSwgM10pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHB1bGxlZCk7XG4gICAgICogLy8gPT4gWydiJywgJ2QnXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG5cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGFycmF5TWFwKGluZGV4ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICB9KS5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5wdWxsYFxuICAgICAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIGBhcnJheWAgc28gdGhhdCB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YCBhbmQgaXMgYmFzZWQgb25cbiAgICAgKiBbYEFycmF5I3JldmVyc2VgXShodHRwczovL21kbi5pby9BcnJheS9yZXZlcnNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucmV2ZXJzZShhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV2ZXJzZShhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBhcnJheSA6IG5hdGl2ZVJldmVyc2UuY2FsbChhcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICogW2BBcnJheSNzbGljZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3NsaWNlKSB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleChbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRMYXN0SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmxhc3RJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxKFsxLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXkpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxQnlgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxQnkoWzEuMSwgMS4yLCAyLjMsIDIuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjEsIDIuM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWlsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFpbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuIEVsZW1lbnRzIGFyZVxuICAgICAqIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tIHRoZSBmaXJzdFxuICAgICAqIGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbkJ5KFsyLjFdLCBbMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb21cbiAgICAgKiB0aGUgZmlyc3QgYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXJcbiAgICAgKiBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICAgKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS16aXBcbiAgICAgKiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcbiAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHVuZGVmaW5lZCwgZ3JvdXApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsyLCAxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZVxuICAgICAqIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gICAgICogb2YgdGhlIGdpdmVuIGFycmF5cy4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXJcbiAgICAgKiB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLndpdGhvdXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqL1xuICAgIHZhciB4b3IgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lXG4gICAgICogYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3JCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yLCAzLjRdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnhvckJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ueG9yV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IGJhc2VSZXN0KHVuemlwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gICAgICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcE9iamVjdGAgZXhjZXB0IHRoYXQgaXQgc3VwcG9ydHMgcHJvcGVydHkgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0RGVlcChbJ2EuYlswXS5jJywgJ2EuYlsxXS5kJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiBbeyAnYyc6IDEgfSwgeyAnZCc6IDIgfV0gfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBiYXNlU2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIGdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgaXRlcmF0ZWUgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpdGVyYXRlZSA9IHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nID8gKGFycmF5cy5wb3AoKSwgaXRlcmF0ZWUpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLiBUaGUgcmVzdWx0IG9mIHN1Y2ggc2VxdWVuY2VzIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gX1xuICAgICAqICAgLmNoYWluKHVzZXJzKVxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAqICAgICByZXR1cm4gby51c2VyICsgJyBpcyAnICsgby5hZ2U7XG4gICAgICogICB9KVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvXG4gICAgICogXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlIGluIG9yZGVyIHRvIG1vZGlmeSBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgIC8vIE11dGF0ZSBpbnB1dCBhcnJheS5cbiAgICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwicGFzcyB0aHJ1XCIgdmFsdWVzIHJlcGxhY2luZyBpbnRlcm1lZGlhdGVcbiAgICAgKiByZXN1bHRzIGluIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXygnICBhYmMgICcpXG4gICAgICogIC5jaGFpbigpXG4gICAgICogIC50cmltKClcbiAgICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8uYXRgLlxuICAgICAqXG4gICAgICogQG5hbWUgYXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXyhvYmplY3QpLmF0KFsnYVswXS5iLmMnLCAnYVsxXSddKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciB3cmFwcGVyQXQgPSBmbGF0UmVzdChmdW5jdGlvbihwYXRocykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbihvYmplY3QpIHsgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTsgfTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEgfHwgdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGggfHxcbiAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHx8ICFpc0luZGV4KHN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2Uoc3RhcnQsICtzdGFydCArIChsZW5ndGggPyAxIDogMCkpO1xuICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChsZW5ndGggJiYgIWFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIGFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHdpdGggZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpLmhlYWQoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGggZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycylcbiAgICAgKiAgIC5jaGFpbigpXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLnB1c2goMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLmxhc3QoKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIG9uIGEgd3JhcHBlZCBvYmplY3QgZm9sbG93aW5nIHRoZVxuICAgICAqIFtpdGVyYXRvciBwcm90b2NvbF0oaHR0cHM6Ly9tZG4uaW8vaXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAbmFtZSBuZXh0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV4dCBpdGVyYXRvciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDEgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAyIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiB0cnVlLCAndmFsdWUnOiB1bmRlZmluZWQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJOZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHRvQXJyYXkodGhpcy52YWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBkb25lID0gdGhpcy5fX2luZGV4X18gPj0gdGhpcy5fX3ZhbHVlc19fLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG5cbiAgICAgIHJldHVybiB7ICdkb25lJzogZG9uZSwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSB3cmFwcGVyIHRvIGJlIGl0ZXJhYmxlLlxuICAgICAqXG4gICAgICogQG5hbWUgU3ltYm9sLml0ZXJhdG9yXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZFtTeW1ib2wuaXRlcmF0b3JdKCkgPT09IHdyYXBwZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogQXJyYXkuZnJvbSh3cmFwcGVkKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSkubWFwKHNxdWFyZSk7XG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xuICAgICAqXG4gICAgICogb3RoZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXBwZXJDbG9uZShwYXJlbnQpO1xuICAgICAgICBjbG9uZS5fX2luZGV4X18gPSAwO1xuICAgICAgICBjbG9uZS5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9fd3JhcHBlZF9fO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5yZXZlcnNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgICAnYXJncyc6IFtyZXZlcnNlXSxcbiAgICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUocmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgKytyZXN1bHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICAgICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8ucmVqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAgICAgKi9cbiAgICB2YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWNvbGxlY3Rpb24ubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0KFsxLCAyLCAzLCA0XSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDE7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIHZhciBmaW5kTGFzdCA9IGNyZWF0ZUZpbmQoZmluZExhc3RJbmRleCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmxhdHRlbmVkIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aHJ1IGBpdGVyYXRlZWAgYW5kIGZsYXR0ZW5pbmcgdGhlIG1hcHBlZCByZXN1bHRzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW24sIG5dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcChbMSwgMl0sIGR1cGxpY2F0ZSk7XG4gICAgICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZWVwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwRGVlcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIElORklOSVRZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsYXRNYXBgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIHRoZVxuICAgICAqIG1hcHBlZCByZXN1bHRzIHVwIHRvIGBkZXB0aGAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlcHRoPTFdIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gICAgICogICByZXR1cm4gW1tbbiwgbl1dXTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZsYXRNYXBEZXB0aChbMSwgMl0sIGR1cGxpY2F0ZSwgMik7XG4gICAgICogLy8gPT4gW1sxLCAxXSwgWzIsIDJdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZXB0aChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIGRlcHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIGVsZW1lbnQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICAgICAqIHByb3BlcnR5IGFyZSBpdGVyYXRlZCBsaWtlIGFycmF5cy4gVG8gYXZvaWQgdGhpcyBiZWhhdmlvciB1c2UgYF8uZm9ySW5gXG4gICAgICogb3IgYF8uZm9yT3duYCBmb3Igb2JqZWN0IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBhbGlhcyBlYWNoXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAgICogQHNlZSBfLmZvckVhY2hSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHsgJ2EnOiAxLCAnYic6IDIgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdhJyB0aGVuICdiJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JFYWNoYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBhbGlhcyBlYWNoUmlnaHRcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2hSaWdodChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMmAgdGhlbiBgMWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yRWFjaFJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2hSaWdodCA6IGJhc2VFYWNoUmlnaHQ7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcbiAgICAgKiBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIGBjb2xsZWN0aW9uYC4gVGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGVcbiAgICAgKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmdyb3VwQnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICAgKi9cbiAgICB2YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIFt2YWx1ZV0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gYGNvbGxlY3Rpb25gLiBJZiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcsIGl0J3NcbiAgICAgKiBjaGVja2VkIGZvciBhIHN1YnN0cmluZyBvZiBgdmFsdWVgLCBvdGhlcndpc2VcbiAgICAgKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGlzIHVzZWQgZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzXG4gICAgICogdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoeyAnYSc6IDEsICdiJzogMiB9LCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluY2x1ZGVzKCdhYmNkJywgJ2JjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gICAgICBjb2xsZWN0aW9uID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBjb2xsZWN0aW9uIDogdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgZnJvbUluZGV4ID0gKGZyb21JbmRleCAmJiAhZ3VhcmQpID8gdG9JbnRlZ2VyKGZyb21JbmRleCkgOiAwO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICBpZiAoZnJvbUluZGV4IDwgMCkge1xuICAgICAgICBmcm9tSW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgICAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKVxuICAgICAgICA6ICghIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAsIHJldHVybmluZ1xuICAgICAqIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqIGFyZSBwcm92aWRlZCB0byBlYWNoIGludm9rZWQgbWV0aG9kLiBJZiBgcGF0aGAgaXMgYSBmdW5jdGlvbiwgaXQncyBpbnZva2VkXG4gICAgICogZm9yLCBhbmQgYHRoaXNgIGJvdW5kIHRvLCBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbnxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2Ugb3JcbiAgICAgKiAgdGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBlYWNoIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbnZva2VNYXAoW1s1LCAxLCA3XSwgWzMsIDIsIDFdXSwgJ3NvcnQnKTtcbiAgICAgKiAvLyA9PiBbWzEsIDUsIDddLCBbMSwgMiwgM11dXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbMTIzLCA0NTZdLCBTdHJpbmcucHJvdG90eXBlLnNwbGl0LCAnJyk7XG4gICAgICogLy8gPT4gW1snMScsICcyJywgJzMnXSwgWyc0JywgJzUnLCAnNiddXVxuICAgICAqL1xuICAgIHZhciBpbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBwYXRoLCBhcmdzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSAnZnVuY3Rpb24nLFxuICAgICAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IGlzRnVuYyA/IGFwcGx5KHBhdGgsIHZhbHVlLCBhcmdzKSA6IGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mXG4gICAgICogZWFjaCBrZXkgaXMgdGhlIGxhc3QgZWxlbWVudCByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUga2V5LiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbXG4gICAgICogICB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSxcbiAgICAgKiAgIHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5rZXlCeShhcnJheSwgZnVuY3Rpb24obykge1xuICAgICAqICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoby5jb2RlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdkJzogeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfSB9XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCAnZGlyJyk7XG4gICAgICogLy8gPT4geyAnbGVmdCc6IHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LCAncmlnaHQnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKi9cbiAgICB2YXIga2V5QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCB2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICAgICAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAgICAgKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAgICAgKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gICAgICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAgICAgKiAvLyA9PiBbMTYsIDY0XVxuICAgICAqXG4gICAgICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0QnlgIGV4Y2VwdCB0aGF0IGl0IGFsbG93cyBzcGVjaWZ5aW5nIHRoZSBzb3J0XG4gICAgICogb3JkZXJzIG9mIHRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS4gSWYgYG9yZGVyc2AgaXMgdW5zcGVjaWZpZWQsIGFsbCB2YWx1ZXNcbiAgICAgKiBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvclxuICAgICAqIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXIgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5W118RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3JkZXJzXSBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gU29ydCBieSBgdXNlcmAgaW4gYXNjZW5kaW5nIG9yZGVyIGFuZCBieSBgYWdlYCBpbiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqIF8ub3JkZXJCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddLCBbJ2FzYycsICdkZXNjJ10pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMsIGd1YXJkKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBcnJheShpdGVyYXRlZXMpKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgICAgIH1cbiAgICAgIG9yZGVycyA9IGd1YXJkID8gdW5kZWZpbmVkIDogb3JkZXJzO1xuICAgICAgaWYgKCFpc0FycmF5KG9yZGVycykpIHtcbiAgICAgICAgb3JkZXJzID0gb3JkZXJzID09IG51bGwgPyBbXSA6IFtvcmRlcnNdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHNwbGl0IGludG8gdHdvIGdyb3VwcywgdGhlIGZpcnN0IG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gICAgICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkgZm9yLiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAncGViYmxlcyddLCBbJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucGFydGl0aW9uKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snZnJlZCddLCBbJ2Jhcm5leScsICdwZWJibGVzJ11dXG4gICAgICovXG4gICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gW1tdLCBbXV07IH0pO1xuXG4gICAgLyoqXG4gICAgICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy4gSWYgYGFjY3VtdWxhdG9yYFxuICAgICAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAgICAgKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAgICAgKiAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8ucmVkdWNlYCwgYF8ucmVkdWNlUmlnaHRgLCBhbmQgYF8udHJhbnNmb3JtYC5cbiAgICAgKlxuICAgICAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhc3NpZ25gLCBgZGVmYXVsdHNgLCBgZGVmYXVsdHNEZWVwYCwgYGluY2x1ZGVzYCwgYG1lcmdlYCwgYG9yZGVyQnlgLFxuICAgICAqIGFuZCBgc29ydEJ5YFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAgICAgKiAgIHJldHVybiBzdW0gKyBuO1xuICAgICAqIH0sIDApO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0sIHt9KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnJlZHVjZWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGBjb2xsZWN0aW9uYCBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gW1swLCAxXSwgWzIsIDNdLCBbNCwgNV1dO1xuICAgICAqXG4gICAgICogXy5yZWR1Y2VSaWdodChhcnJheSwgZnVuY3Rpb24oZmxhdHRlbmVkLCBvdGhlcikge1xuICAgICAqICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQob3RoZXIpO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2VSaWdodChjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlUmlnaHQgOiBiYXNlUmVkdWNlLFxuICAgICAgICAgIGluaXRBY2N1bSA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuXG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgNCksIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0sIGJhc2VFYWNoUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAgICAgKiB0aGF0IGBwcmVkaWNhdGVgIGRvZXMgKipub3QqKiByZXR1cm4gdHJ1dGh5IGZvci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8uZmlsdGVyXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJhbmRvbSBlbGVtZW50IGZyb20gYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGUgOiBiYXNlU2FtcGxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBgbmAgcmFuZG9tIGVsZW1lbnRzIGF0IHVuaXF1ZSBrZXlzIGZyb20gYGNvbGxlY3Rpb25gIHVwIHRvIHRoZVxuICAgICAqIHNpemUgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlU2l6ZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFszLCAxXVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgNCk7XG4gICAgICogLy8gPT4gWzIsIDMsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuLCBndWFyZCkge1xuICAgICAgaWYgKChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGVTaXplIDogYmFzZVNhbXBsZVNpemU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICAgICAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAgICAgKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2h1ZmZsZSA6IGJhc2VTaHVmZmxlO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAgICAgKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29sbGVjdGlvbiBzaXplLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNpemUoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnNpemUoeyAnYSc6IDEsICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLnNpemUoJ3BlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiA3XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcoY29sbGVjdGlvbik7XG4gICAgICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5LiBUaGUgcHJlZGljYXRlIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWN0aXZlJzogZmFsc2UgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvbWUodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGVsZW1lbnRzLCBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSByZXN1bHRzIG9mXG4gICAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAgICAgKiBlcXVhbCBlbGVtZW50cy4gVGhlIGl0ZXJhdGVlcyBhcmUgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICAgICAqXG4gICAgICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdLCBbJ2ZyZWQnLCA0OF1dXG4gICAgICovXG4gICAgdmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPiAxICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgICAgICBpdGVyYXRlZXMgPSBbaXRlcmF0ZWVzWzBdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG4gICAgfSk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2VcbiAgICAgKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBEYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICAgICAqIH0sIF8ubm93KCkpO1xuICAgICAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gICAgICovXG4gICAgdmFyIG5vdyA9IGN0eE5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByb290LkRhdGUubm93KCk7XG4gICAgfTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5iZWZvcmVgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzXG4gICAgICogYGZ1bmNgIG9uY2UgaXQncyBjYWxsZWQgYG5gIG9yIG1vcmUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGNhbGxzIGJlZm9yZSBgZnVuY2AgaXMgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgc2F2ZXMgPSBbJ3Byb2ZpbGUnLCAnc2V0dGluZ3MnXTtcbiAgICAgKlxuICAgICAqIHZhciBkb25lID0gXy5hZnRlcihzYXZlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ2RvbmUgc2F2aW5nIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5mb3JFYWNoKHNhdmVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICogICBhc3luY1NhdmUoeyAndHlwZSc6IHR5cGUsICdjb21wbGV0ZSc6IGRvbmUgfSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnZG9uZSBzYXZpbmchJyBhZnRlciB0aGUgdHdvIGFzeW5jIHNhdmVzIGhhdmUgY29tcGxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCwgd2l0aCB1cCB0byBgbmAgYXJndW1lbnRzLFxuICAgICAqIGlnbm9yaW5nIGFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IGNhcC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzgnLCAnMTAnXSwgXy5hcnkocGFyc2VJbnQsIDEpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJ5KGZ1bmMsIG4sIGd1YXJkKSB7XG4gICAgICBuID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBuO1xuICAgICAgbiA9IChmdW5jICYmIG4gPT0gbnVsbCkgPyBmdW5jLmxlbmd0aCA6IG47XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0FSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzXG4gICAgICogb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoaWxlIGl0J3MgY2FsbGVkIGxlc3MgdGhhbiBgbmAgdGltZXMuIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYXQgd2hpY2ggYGZ1bmNgIGlzIG5vIGxvbmdlciBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmJlZm9yZSg1LCBhZGRDb250YWN0VG9MaXN0KSk7XG4gICAgICogLy8gPT4gQWxsb3dzIGFkZGluZyB1cCB0byA0IGNvbnRhY3RzIHRvIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJlZm9yZShuLCBmdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0O1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA+IDApIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPD0gMSkge1xuICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgXG4gICAgICogYW5kIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIG5hdGl2ZSBgRnVuY3Rpb24jYmluZGAsIHRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgb2YgYm91bmQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICAgKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBib3VuZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAndXNlcic6ICdmcmVkJyB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kKGdyZWV0LCBvYmplY3QsIF8sICchJyk7XG4gICAgICogYm91bmQoJ2hpJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgdGhpc0FyZywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBiaXRtYXNrID0gV1JBUF9CSU5EX0ZMQUc7XG4gICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kKSk7XG4gICAgICAgIGJpdG1hc2sgfD0gV1JBUF9QQVJUSUFMX0ZMQUc7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBtZXRob2QgYXQgYG9iamVjdFtrZXldYCB3aXRoIGBwYXJ0aWFsc2BcbiAgICAgKiBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgXy5iaW5kYCBieSBhbGxvd2luZyBib3VuZCBmdW5jdGlvbnMgdG8gcmVmZXJlbmNlXG4gICAgICogbWV0aG9kcyB0aGF0IG1heSBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LiBTZWVcbiAgICAgKiBbUGV0ZXIgTWljaGF1eCdzIGFydGljbGVdKGh0dHA6Ly9wZXRlci5taWNoYXV4LmNhL2FydGljbGVzL2xhenktZnVuY3Rpb24tZGVmaW5pdGlvbi1wYXR0ZXJuKVxuICAgICAqIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBUaGUgYF8uYmluZEtleS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludm9rZSB0aGUgbWV0aG9kIG9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ3VzZXInOiAnZnJlZCcsXG4gICAgICogICAnZ3JlZXQnOiBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBib3VuZCA9IF8uYmluZEtleShvYmplY3QsICdncmVldCcsICdoaScpO1xuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpIGZyZWQhJ1xuICAgICAqXG4gICAgICogb2JqZWN0LmdyZWV0ID0gZnVuY3Rpb24oZ3JlZXRpbmcsIHB1bmN0dWF0aW9uKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAneWEgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBib3VuZCgnIScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gQm91bmQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGl5YSBmcmVkISdcbiAgICAgKi9cbiAgICB2YXIgYmluZEtleSA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwga2V5LCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmRLZXkpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGtleSwgYml0bWFzaywgb2JqZWN0LCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFyZ3VtZW50cyBvZiBgZnVuY2AgYW5kIGVpdGhlciBpbnZva2VzXG4gICAgICogYGZ1bmNgIHJldHVybmluZyBpdHMgcmVzdWx0LCBpZiBhdCBsZWFzdCBgYXJpdHlgIG51bWJlciBvZiBhcmd1bWVudHMgaGF2ZVxuICAgICAqIGJlZW4gcHJvdmlkZWQsIG9yIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHJlbWFpbmluZyBgZnVuY2BcbiAgICAgKiBhcmd1bWVudHMsIGFuZCBzbyBvbi4gVGhlIGFyaXR5IG9mIGBmdW5jYCBtYXkgYmUgc3BlY2lmaWVkIGlmIGBmdW5jLmxlbmd0aGBcbiAgICAgKiBpcyBub3Qgc3VmZmljaWVudC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeS5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljIGJ1aWxkcyxcbiAgICAgKiBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgY3VycmllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5PWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY3VycmllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFiYyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIHZhciBjdXJyaWVkID0gXy5jdXJyeShhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgxKSgyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMikoMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDEpKF8sIDMpKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnkucGxhY2Vob2xkZXI7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY3VycnlgIGV4Y2VwdCB0aGF0IGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byBgZnVuY2BcbiAgICAgKiBpbiB0aGUgbWFubmVyIG9mIGBfLnBhcnRpYWxSaWdodGAgaW5zdGVhZCBvZiBgXy5wYXJ0aWFsYC5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5jdXJyeVJpZ2h0LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5UmlnaHQoYWJjKTtcbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMykoMikoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDIsIDMpKDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyLCAzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIC8vIEN1cnJpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogY3VycmllZCgzKSgxLCBfKSgyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXJyeVJpZ2h0KGZ1bmMsIGFyaXR5LCBndWFyZCkge1xuICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZCA6IGFyaXR5O1xuICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYXJpdHkpO1xuICAgICAgcmVzdWx0LnBsYWNlaG9sZGVyID0gY3VycnlSaWdodC5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gICAgICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gICAgICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICAgICAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICAgICAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICAgICAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gICAgICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAgICAgKiBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAgICAgKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICAgICAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICAgICAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICAgICAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICAgICAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICAgICAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAgICAgKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gICAgICpcbiAgICAgKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsYXN0QXJncyxcbiAgICAgICAgICBsYXN0VGhpcyxcbiAgICAgICAgICBtYXhXYWl0LFxuICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICB0aW1lcklkLFxuICAgICAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICAgICAgcmV0dXJuIG1heGluZ1xuICAgICAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgICAgICA6IHRpbWVXYWl0aW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgICAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgICAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgICAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgICAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICAgICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZlcnMgaW52b2tpbmcgdGhlIGBmdW5jYCB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLiBBbnlcbiAgICAgKiBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgJ2RlZmVycmVkJyk7XG4gICAgICogLy8gPT4gTG9ncyAnZGVmZXJyZWQnIGFmdGVyIG9uZSBtaWxsaXNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIDEsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyBgZnVuY2AgYWZ0ZXIgYHdhaXRgIG1pbGxpc2Vjb25kcy4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZVxuICAgICAqIHByb3ZpZGVkIHRvIGBmdW5jYCB3aGVuIGl0J3MgaW52b2tlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXIgaWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVsYXkoZnVuY3Rpb24odGV4dCkge1xuICAgICAqICAgY29uc29sZS5sb2codGV4dCk7XG4gICAgICogfSwgMTAwMCwgJ2xhdGVyJyk7XG4gICAgICogLy8gPT4gTG9ncyAnbGF0ZXInIGFmdGVyIG9uZSBzZWNvbmQuXG4gICAgICovXG4gICAgdmFyIGRlbGF5ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCB0b051bWJlcih3YWl0KSB8fCAwLCBhcmdzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIHJldmVyc2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZmxpcCBhcmd1bWVudHMgZm9yLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsaXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmbGlwcGVkID0gXy5mbGlwKGZ1bmN0aW9uKCkge1xuICAgICAqICAgcmV0dXJuIF8udG9BcnJheShhcmd1bWVudHMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZmxpcHBlZCgnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+IFsnZCcsICdjJywgJ2InLCAnYSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxpcChmdW5jKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0ZMSVBfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAgICAgKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gICAgICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gICAgICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAgICAgKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAgICAgKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICAgICAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gICAgICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAgICAgKlxuICAgICAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogdmFsdWVzKG90aGVyKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKlxuICAgICAqIG9iamVjdC5hID0gMjtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKlxuICAgICAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICAgICAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiB2YWx1ZXMob2JqZWN0KTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICpcbiAgICAgKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICAgICAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgICAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG4gICAgbWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbmVnYXRlcyB0aGUgcmVzdWx0IG9mIHRoZSBwcmVkaWNhdGUgYGZ1bmNgLiBUaGVcbiAgICAgKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG5lZ2F0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzRXZlbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICAgICAqIC8vID0+IFsxLCAzLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzKTtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSk7XG4gICAgICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBpbnZva2luZyBgZnVuY2Agb25jZS4gUmVwZWF0IGNhbGxzXG4gICAgICogdG8gdGhlIGZ1bmN0aW9uIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGludm9jYXRpb24uIFRoZSBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIGluaXRpYWxpemUoKTtcbiAgICAgKiAvLyA9PiBgY3JlYXRlQXBwbGljYXRpb25gIGlzIGludm9rZWQgb25jZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgICAgcmV0dXJuIGJlZm9yZSgyLCBmdW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudHMgdHJhbnNmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbdHJhbnNmb3Jtcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm1zLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBkb3VibGVkKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyQXJncyhmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4gW3gsIHldO1xuICAgICAqIH0sIFtzcXVhcmUsIGRvdWJsZWRdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoOSwgMyk7XG4gICAgICogLy8gPT4gWzgxLCA2XVxuICAgICAqXG4gICAgICogZnVuYygxMCwgNSk7XG4gICAgICogLy8gPT4gWzEwMCwgMTBdXG4gICAgICovXG4gICAgdmFyIG92ZXJBcmdzID0gY2FzdFJlc3QoZnVuY3Rpb24oZnVuYywgdHJhbnNmb3Jtcykge1xuICAgICAgdHJhbnNmb3JtcyA9ICh0cmFuc2Zvcm1zLmxlbmd0aCA9PSAxICYmIGlzQXJyYXkodHJhbnNmb3Jtc1swXSkpXG4gICAgICAgID8gYXJyYXlNYXAodHJhbnNmb3Jtc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKVxuICAgICAgICA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuXG4gICAgICB2YXIgZnVuY3NMZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBmdW5jc0xlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdLmNhbGwodGhpcywgYXJnc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGVcbiAgICAgKiBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYmluZGAgZXhjZXB0IGl0IGRvZXMgKipub3QqKlxuICAgICAqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBwYXJ0aWFsbHlcbiAgICAgKiBhcHBsaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjIuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGdyZWV0KGdyZWV0aW5nLCBuYW1lKSB7XG4gICAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyBuYW1lO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsKGdyZWV0LCAnaGVsbG8nKTtcbiAgICAgKiBzYXlIZWxsb1RvKCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBQYXJ0aWFsbHkgYXBwbGllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsKGdyZWV0LCBfLCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIocGFydGlhbCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5wYXJ0aWFsYCBleGNlcHQgdGhhdCBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHNcbiAgICAgKiBhcmUgYXBwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5wYXJ0aWFsUmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGdyZWV0RnJlZCA9IF8ucGFydGlhbFJpZ2h0KGdyZWV0LCAnZnJlZCcpO1xuICAgICAqIGdyZWV0RnJlZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBzYXlIZWxsb1RvID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdoZWxsbycsIF8pO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKi9cbiAgICB2YXIgcGFydGlhbFJpZ2h0ID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHLCB1bmRlZmluZWQsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggYXJndW1lbnRzIGFycmFuZ2VkIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBzcGVjaWZpZWQgYGluZGV4ZXNgIHdoZXJlIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgZmlyc3QgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhcmd1bWVudCB2YWx1ZSBhdCB0aGUgc2Vjb25kIGluZGV4IGlzXG4gICAgICogcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVhcnJhbmdlIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHsuLi4obnVtYmVyfG51bWJlcltdKX0gaW5kZXhlcyBUaGUgYXJyYW5nZWQgYXJndW1lbnQgaW5kZXhlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHJlYXJnZWQgPSBfLnJlYXJnKGZ1bmN0aW9uKGEsIGIsIGMpIHtcbiAgICAgKiAgIHJldHVybiBbYSwgYiwgY107XG4gICAgICogfSwgWzIsIDAsIDFdKTtcbiAgICAgKlxuICAgICAqIHJlYXJnZWQoJ2InLCAnYycsICdhJylcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICB2YXIgcmVhcmcgPSBmbGF0UmVzdChmdW5jdGlvbihmdW5jLCBpbmRleGVzKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1JFQVJHX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGluZGV4ZXMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlZCBmdW5jdGlvbiBhbmQgYXJndW1lbnRzIGZyb20gYHN0YXJ0YCBhbmQgYmV5b25kIHByb3ZpZGVkIGFzXG4gICAgICogYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlXG4gICAgICogW3Jlc3QgcGFyYW1ldGVyXShodHRwczovL21kbi5pby9yZXN0X3BhcmFtZXRlcnMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnJlc3QoZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAgICAgKiAgIHJldHVybiB3aGF0ICsgJyAnICsgXy5pbml0aWFsKG5hbWVzKS5qb2luKCcsICcpICtcbiAgICAgKiAgICAgKF8uc2l6ZShuYW1lcykgPiAxID8gJywgJiAnIDogJycpICsgXy5sYXN0KG5hbWVzKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheSgnaGVsbG8nLCAnZnJlZCcsICdiYXJuZXknLCAncGViYmxlcycpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHN0YXJ0ID09PSB1bmRlZmluZWQgPyBzdGFydCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZVxuICAgICAqIGNyZWF0ZSBmdW5jdGlvbiBhbmQgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG11Y2ggbGlrZVxuICAgICAqIFtgRnVuY3Rpb24jYXBwbHlgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbc3ByZWFkIG9wZXJhdG9yXShodHRwczovL21kbi5pby9zcHJlYWRfb3BlcmF0b3IpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gc3ByZWFkIGFyZ3VtZW50cyBvdmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSBzcHJlYWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXkgPSBfLnNwcmVhZChmdW5jdGlvbih3aG8sIHdoYXQpIHtcbiAgICAgKiAgIHJldHVybiB3aG8gKyAnIHNheXMgJyArIHdoYXQ7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBzYXkoWydmcmVkJywgJ2hlbGxvJ10pO1xuICAgICAqIC8vID0+ICdmcmVkIHNheXMgaGVsbG8nXG4gICAgICpcbiAgICAgKiB2YXIgbnVtYmVycyA9IFByb21pc2UuYWxsKFtcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSg0MCksXG4gICAgICogICBQcm9taXNlLnJlc29sdmUoMzYpXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBudW1iZXJzLnRoZW4oXy5zcHJlYWQoZnVuY3Rpb24oeCwgeSkge1xuICAgICAqICAgcmV0dXJuIHggKyB5O1xuICAgICAqIH0pKTtcbiAgICAgKiAvLyA9PiBhIFByb21pc2Ugb2YgNzZcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcHJlYWQoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcmdzW3N0YXJ0XSxcbiAgICAgICAgICAgIG90aGVyQXJncyA9IGNhc3RTbGljZShhcmdzLCAwLCBzdGFydCk7XG5cbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgYXJyYXlQdXNoKG90aGVyQXJncywgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICAgICAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gICAgICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICAgICAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICAgICAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAgICAgKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gICAgICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICAgICAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAgICAgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICAgICAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAgICAgKlxuICAgICAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICAgICAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAgICAgKlxuICAgICAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICAgICAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAgICAgKlxuICAgICAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICAgICAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAgICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB1cCB0byBvbmUgYXJndW1lbnQsIGlnbm9yaW5nIGFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLnVuYXJ5KHBhcnNlSW50KSk7XG4gICAgICogLy8gPT4gWzYsIDgsIDEwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuYXJ5KGZ1bmMpIHtcbiAgICAgIHJldHVybiBhcnkoZnVuYywgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvdmlkZXMgYHZhbHVlYCB0byBgd3JhcHBlcmAgYXMgaXRzIGZpcnN0XG4gICAgICogYXJndW1lbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZnVuY3Rpb24gYXJlIGFwcGVuZGVkXG4gICAgICogdG8gdGhvc2UgcHJvdmlkZWQgdG8gdGhlIGB3cmFwcGVyYC4gVGhlIHdyYXBwZXIgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2BcbiAgICAgKiBiaW5kaW5nIG9mIHRoZSBjcmVhdGVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbd3JhcHBlcj1pZGVudGl0eV0gVGhlIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBwID0gXy53cmFwKF8uZXNjYXBlLCBmdW5jdGlvbihmdW5jLCB0ZXh0KSB7XG4gICAgICogICByZXR1cm4gJzxwPicgKyBmdW5jKHRleHQpICsgJzwvcD4nO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogcCgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnPHA+ZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzPC9wPidcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gcGFydGlhbChjYXN0RnVuY3Rpb24od3JhcHBlciksIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIGFzIGFuIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KDEpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxIH1dXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW251bGxdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IFt1bmRlZmluZWRdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSgpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICogY29uc29sZS5sb2coXy5jYXN0QXJyYXkoYXJyYXkpID09PSBhcnJheSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheSgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICAgICAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gICAgICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICAgICAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICAgICAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gICAgICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICAgICAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGNsb25lZCB2YWx1ZS4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICogY2xvbmluZyBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGhcbiAgICAgKiB1cCB0byBmb3VyIGFyZ3VtZW50czsgKHZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lRGVlcFdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAgICAgKlxuICAgICAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gICAgICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZVdpdGhgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVXaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIodmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZWwgPSBfLmNsb25lRGVlcFdpdGgoZG9jdW1lbnQuYm9keSwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhlbCA9PT0gZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5ub2RlTmFtZSk7XG4gICAgICogLy8gPT4gJ0JPRFknXG4gICAgICogY29uc29sZS5sb2coZWwuY2hpbGROb2Rlcy5sZW5ndGgpO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEZWVwV2l0aCh2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG9iamVjdGAgY29uZm9ybXMgdG8gYHNvdXJjZWAgYnkgaW52b2tpbmcgdGhlIHByZWRpY2F0ZVxuICAgICAqIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5jb25mb3Jtc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTQuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmNvbmZvcm1zVG8ob2JqZWN0LCB7ICdiJzogZnVuY3Rpb24obikgeyByZXR1cm4gbiA+IDI7IH0gfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlID09IG51bGwgfHwgYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIGtleXMoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lcShOYU4sIE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5sdFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0KDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uZ3QoMSwgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmd0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlID49IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheSgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlCdWZmZXJgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXlCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUJ1ZmZlcihuZXcgQXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQXJyYXlCdWZmZXIgPSBub2RlSXNBcnJheUJ1ZmZlciA/IGJhc2VVbmFyeShub2RlSXNBcnJheUJ1ZmZlcikgOiBiYXNlSXNBcnJheUJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAgICAgKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gICAgICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICAgICAqIGlzIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGJvb2xlYW4gcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKGZhbHNlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQm9vbGVhbihudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fFxuICAgICAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBib29sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRGF0ZWAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKG5ldyBEYXRlKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRGF0ZSgnTW9uIEFwcmlsIDIzIDIwMTInKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc0RhdGUgPSBub2RlSXNEYXRlID8gYmFzZVVuYXJ5KG5vZGVJc0RhdGUpIDogYmFzZUlzRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIERPTSBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbGVtZW50KCc8Ym9keT4nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDEgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGVtcHR5IG9iamVjdCwgY29sbGVjdGlvbiwgbWFwLCBvciBzZXQuXG4gICAgICpcbiAgICAgKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gICAgICogalF1ZXJ5LWxpa2UgY29sbGVjdGlvbnMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYGxlbmd0aGAgb2YgYDBgLlxuICAgICAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHRydWUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eSgxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgICAgfVxuICAgICAgaWYgKGlzUHJvdG90eXBlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAgICAgKiBlcXVpdmFsZW50LlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICAgICAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAgICAgKiBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWQgYXJyYXlzLiBgT2JqZWN0YCBvYmplY3RzIGFyZSBjb21wYXJlZFxuICAgICAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICAgICAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIG9iamVjdCA9PT0gb3RoZXI7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0VxdWFsYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggdXAgdG9cbiAgICAgKiBzaXggYXJndW1lbnRzOiAob2JqVmFsdWUsIG90aFZhbHVlIFssIGluZGV4fGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2tdKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKG90aFZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2hlbGxvJywgJ2dvb2RieWUnXTtcbiAgICAgKiB2YXIgb3RoZXIgPSBbJ2hpJywgJ2dvb2RieWUnXTtcbiAgICAgKlxuICAgICAqIF8uaXNFcXVhbFdpdGgoYXJyYXksIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcXVhbFdpdGgodmFsdWUsIG90aGVyLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIodmFsdWUsIG90aGVyKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgdW5kZWZpbmVkLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGBFcnJvcmAsIGBFdmFsRXJyb3JgLCBgUmFuZ2VFcnJvcmAsIGBSZWZlcmVuY2VFcnJvcmAsXG4gICAgICogYFN5bnRheEVycm9yYCwgYFR5cGVFcnJvcmAsIG9yIGBVUklFcnJvcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBlcnJvciBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKG5ldyBFcnJvcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Vycm9yKEVycm9yKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXJyb3IodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZS5tZXNzYWdlID09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZS5uYW1lID09ICdzdHJpbmcnICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgcHJpbWl0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzRmluaXRlYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzRmluaXRlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaW5pdGUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAgICAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0ludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmIHZhbHVlID09IHRvSW50ZWdlcih2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0xlbmd0aCgnMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICAgICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICAgICAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAgICAgKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICAgICAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2Uoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gYG9iamVjdGAgYW5kIGBzb3VyY2VgIHRvXG4gICAgICogZGV0ZXJtaW5lIGlmIGBvYmplY3RgIGNvbnRhaW5zIGVxdWl2YWxlbnQgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8gYF8ubWF0Y2hlc2Agd2hlbiBgc291cmNlYCBpc1xuICAgICAqIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogUGFydGlhbCBjb21wYXJpc29ucyB3aWxsIG1hdGNoIGVtcHR5IGFycmF5IGFuZCBlbXB0eSBvYmplY3QgYHNvdXJjZWBcbiAgICAgKiB2YWx1ZXMgYWdhaW5zdCBhbnkgYXJyYXkgb3Igb2JqZWN0IHZhbHVlLCByZXNwZWN0aXZlbHkuIFNlZSBgXy5pc0VxdWFsYFxuICAgICAqIGZvciBhIGxpc3Qgb2Ygc3VwcG9ydGVkIHZhbHVlIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMiB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2gob2JqZWN0LCB7ICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2gob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNNYXRjaGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIGNvbXBhcmUgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgY29tcGFyaXNvbnNcbiAgICAgKiBhcmUgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZCB3aXRoIGZpdmVcbiAgICAgKiBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGluZGV4fGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGlzR3JlZXRpbmcodmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAvXmgoPzppfGVsbG8pJC8udGVzdCh2YWx1ZSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChpc0dyZWV0aW5nKG9ialZhbHVlKSAmJiBpc0dyZWV0aW5nKHNyY1ZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnZ3JlZXRpbmcnOiAnaGVsbG8nIH07XG4gICAgICogdmFyIHNvdXJjZSA9IHsgJ2dyZWV0aW5nJzogJ2hpJyB9O1xuICAgICAqXG4gICAgICogXy5pc01hdGNoV2l0aChvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIGdldE1hdGNoRGF0YShzb3VyY2UpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgTmFOYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzTmFOYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzTmFOKSBhbmQgaXMgbm90IHRoZSBzYW1lIGFzXG4gICAgICogZ2xvYmFsIFtgaXNOYU5gXShodHRwczovL21kbi5pby9pc05hTikgd2hpY2ggcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogYHVuZGVmaW5lZGAgYW5kIG90aGVyIG5vbi1udW1iZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKE5hTik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTihuZXcgTnVtYmVyKE5hTikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hTih1bmRlZmluZWQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcbiAgICAgIC8vIEFuIGBOYU5gIHByaW1pdGl2ZSBpcyB0aGUgb25seSB2YWx1ZSB0aGF0IGlzIG5vdCBlcXVhbCB0byBpdHNlbGYuXG4gICAgICAvLyBQZXJmb3JtIHRoZSBgdG9TdHJpbmdUYWdgIGNoZWNrIGZpcnN0IHRvIGF2b2lkIGVycm9ycyB3aXRoIHNvbWVcbiAgICAgIC8vIEFjdGl2ZVggb2JqZWN0cyBpbiBJRS5cbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJpc3RpbmUgbmF0aXZlIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGNhbid0IHJlbGlhYmx5IGRldGVjdCBuYXRpdmUgZnVuY3Rpb25zIGluIHRoZSBwcmVzZW5jZVxuICAgICAqIG9mIHRoZSBjb3JlLWpzIHBhY2thZ2UgYmVjYXVzZSBjb3JlLWpzIGNpcmN1bXZlbnRzIHRoaXMga2luZCBvZiBkZXRlY3Rpb24uXG4gICAgICogRGVzcGl0ZSBtdWx0aXBsZSByZXF1ZXN0cywgdGhlIGNvcmUtanMgbWFpbnRhaW5lciBoYXMgbWFkZSBpdCBjbGVhcjogYW55XG4gICAgICogYXR0ZW1wdCB0byBmaXggdGhlIGRldGVjdGlvbiB3aWxsIGJlIG9ic3RydWN0ZWQuIEFzIGEgcmVzdWx0LCB3ZSdyZSBsZWZ0XG4gICAgICogd2l0aCBsaXR0bGUgY2hvaWNlIGJ1dCB0byB0aHJvdyBhbiBlcnJvci4gVW5mb3J0dW5hdGVseSwgdGhpcyBhbHNvIGFmZmVjdHNcbiAgICAgKiBwYWNrYWdlcywgbGlrZSBbYmFiZWwtcG9seWZpbGxdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2JhYmVsLXBvbHlmaWxsKSxcbiAgICAgKiB3aGljaCByZWx5IG9uIGNvcmUtanMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOYXRpdmUoXyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKGlzTWFza2FibGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihDT1JFX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgbnVsbGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bGwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bGwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbnVsbGlzaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwodm9pZCAwKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmlsKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBOdW1iZXJgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVG8gZXhjbHVkZSBgSW5maW5pdHlgLCBgLUluZmluaXR5YCwgYW5kIGBOYU5gLCB3aGljaCBhcmVcbiAgICAgKiBjbGFzc2lmaWVkIGFzIG51bWJlcnMsIHVzZSB0aGUgYF8uaXNGaW5pdGVgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcigzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IG51bWJlclRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIHRoYXQgaXMsIGFuIG9iamVjdCBjcmVhdGVkIGJ5IHRoZVxuICAgICAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjguMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QobmV3IEZvbyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoeyAneCc6IDAsICd5JzogMCB9KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzUGxhaW5PYmplY3QoT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgICAgIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gICAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJlxuICAgICAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoL2FiYy8pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNSZWdFeHAoJy9hYmMvJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc2FmZSBpbnRlZ2VyLiBBbiBpbnRlZ2VyIGlzIHNhZmUgaWYgaXQncyBhbiBJRUVFLTc1NFxuICAgICAqIGRvdWJsZSBwcmVjaXNpb24gbnVtYmVyIHdoaWNoIGlzbid0IHRoZSByZXN1bHQgb2YgYSByb3VuZGVkIHVuc2FmZSBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNTYWZlSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc1NhZmVJbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTYWZlSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA+PSAtTUFYX1NBRkVfSU5URUdFUiAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3RyaW5nKDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcbiAgICAgICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYHVuZGVmaW5lZGAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNVbmRlZmluZWQobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBtYXAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IFdlYWtNYXApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrTWFwKG5ldyBNYXApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHdlYWtNYXBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBXZWFrU2V0YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgd2VhayBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFdlYWtTZXQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNXZWFrU2V0KG5ldyBTZXQpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNXZWFrU2V0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSB3ZWFrU2V0VGFnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8uZ3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdCgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmx0KDMsIDEpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGx0ID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihiYXNlTHQpO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgICAgKiAgYG90aGVyYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndGVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sdGUoMSwgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5sdGUoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHRlID0gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8PSBvdGhlcjtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9BcnJheSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ11cbiAgICAgKlxuICAgICAqIF8udG9BcnJheSgxKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KG51bGwpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmluZyh2YWx1ZSkgPyBzdHJpbmdUb0FycmF5KHZhbHVlKSA6IGNvcHlBcnJheSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3ltSXRlcmF0b3IgJiYgdmFsdWVbc3ltSXRlcmF0b3JdKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclRvQXJyYXkodmFsdWVbc3ltSXRlcmF0b3JdKCkpO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgZnVuYyA9IHRhZyA9PSBtYXBUYWcgPyBtYXBUb0FycmF5IDogKHRhZyA9PSBzZXRUYWcgPyBzZXRUb0FycmF5IDogdmFsdWVzKTtcblxuICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTIuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKDMuMik7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDVlLTMyNFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoJzMuMicpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgICAgIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIgc3VpdGFibGUgZm9yIHVzZSBhcyB0aGUgbGVuZ3RoIG9mIGFuXG4gICAgICogYXJyYXktbGlrZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA0Mjk0OTY3Mjk1XG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9MZW5ndGgodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAwLCBNQVhfQVJSQVlfTEVOR1RIKSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiBJbmZpbml0eVxuICAgICAqXG4gICAgICogXy50b051bWJlcignMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICAgICAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgICAgIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgICAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICAgICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHBsYWluIG9iamVjdCBmbGF0dGVuaW5nIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZ1xuICAgICAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBwbGFpbiBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIG5ldyBGb28pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgXy50b1BsYWluT2JqZWN0KG5ldyBGb28pKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHZhbHVlLCBrZXlzSW4odmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc2FmZSBpbnRlZ2VyLiBBIHNhZmUgaW50ZWdlciBjYW4gYmUgY29tcGFyZWQgYW5kXG4gICAgICogcmVwcmVzZW50ZWQgY29ycmVjdGx5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiA5MDA3MTk5MjU0NzQwOTkxXG4gICAgICpcbiAgICAgKiBfLnRvU2FmZUludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NhZmVJbnRlZ2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICAgIDogKHZhbHVlID09PSAwID8gdmFsdWUgOiAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICAgICAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcobnVsbCk7XG4gICAgICogLy8gPT4gJydcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoLTApO1xuICAgICAqIC8vID0+ICctMCdcbiAgICAgKlxuICAgICAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiAnMSwyLDMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbkluXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMCB9LCBuZXcgRm9vLCBuZXcgQmFyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBvd24gYW5kXG4gICAgICogaW5oZXJpdGVkIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZXh0ZW5kXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBCYXIoKSB7XG4gICAgICogICB0aGlzLmMgPSAzO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYiA9IDI7XG4gICAgICogQmFyLnByb3RvdHlwZS5kID0gNDtcbiAgICAgKlxuICAgICAqIF8uYXNzaWduSW4oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzLCAnZCc6IDQgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgYXNzaWduZWQgdmFsdWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLCBhc3NpZ25tZW50IGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgXG4gICAgICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFdpdGhcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQob2JqVmFsdWUpID8gc3JjVmFsdWUgOiBvYmpWYWx1ZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZGVmYXVsdHMgPSBfLnBhcnRpYWxSaWdodChfLmFzc2lnbkluV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW5XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25XaXRoLCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIHZhciBhc3NpZ25XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byBgcGF0aHNgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHBpY2tlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH0sIDRdIH07XG4gICAgICpcbiAgICAgKiBfLmF0KG9iamVjdCwgWydhWzBdLmIuYycsICdhWzFdJ10pO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciBhdCA9IGZsYXRSZXN0KGJhc2VBdCk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGBwcm90b3R5cGVgIG9iamVjdC4gSWYgYVxuICAgICAqIGBwcm9wZXJ0aWVzYCBvYmplY3QgaXMgZ2l2ZW4sIGl0cyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllc1xuICAgICAqIGFyZSBhc3NpZ25lZCB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIFRoZSBwcm9wZXJ0aWVzIHRvIGFzc2lnbiB0byB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIFNoYXBlKCkge1xuICAgICAqICAgdGhpcy54ID0gMDtcbiAgICAgKiAgIHRoaXMueSA9IDA7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgICAqICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBDaXJjbGUucHJvdG90eXBlID0gXy5jcmVhdGUoU2hhcGUucHJvdG90eXBlLCB7XG4gICAgICogICAnY29uc3RydWN0b3InOiBDaXJjbGVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlO1xuICAgICAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzID09IG51bGwgPyByZXN1bHQgOiBiYXNlQXNzaWduKHJlc3VsdCwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICAgICAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxuICAgICAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICAgIHZhciBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgdmFyIHByb3BzID0ga2V5c0luKHNvdXJjZSk7XG4gICAgICAgIHZhciBwcm9wc0luZGV4ID0gLTE7XG4gICAgICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoKytwcm9wc0luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAoZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRlZmF1bHRzYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBhc3NpZ25zXG4gICAgICogZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5kZWZhdWx0c1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRzRGVlcCh7ICdhJzogeyAnYic6IDIgfSB9LCB7ICdhJzogeyAnYic6IDEsICdjJzogMyB9IH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdiJzogMiwgJ2MnOiAzIH0gfVxuICAgICAqL1xuICAgIHZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICBhcmdzLnB1c2godW5kZWZpbmVkLCBjdXN0b21EZWZhdWx0c01lcmdlKTtcbiAgICAgIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGtleSBvZiB0aGUgZmlyc3RcbiAgICAgKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjEuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZEtleSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gICAgICogLy8gPT4gJ2Jhcm5leScgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93bik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kS2V5YCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYSBjb2xsZWN0aW9uIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFJldHVybnMgdGhlIGtleSBvZiB0aGUgbWF0Y2hlZCBlbGVtZW50LFxuICAgICAqICBlbHNlIGB1bmRlZmluZWRgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSB7XG4gICAgICogICAnYmFybmV5JzogIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgJ2ZyZWQnOiAgICB7ICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+IHJldHVybnMgJ3BlYmJsZXMnIGFzc3VtaW5nIGBfLmZpbmRLZXlgIHJldHVybnMgJ2Jhcm5leSdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgeyAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+ICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEtleSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+ICdwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gYmFzZUZpbmRLZXkob2JqZWN0LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBiYXNlRm9yT3duUmlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhblxuICAgICAqIG9iamVjdCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGtleSwgb2JqZWN0KS4gSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0XG4gICAgICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvckluKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScsICdiJywgdGhlbiAnYycgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvcihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckluYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JJblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJblJpZ2h0KG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYycsICdiJywgdGhlbiAnYScgYXNzdW1pbmcgYF8uZm9ySW5gIGxvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsXG4gICAgICAgID8gb2JqZWN0XG4gICAgICAgIDogYmFzZUZvclJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLCBrZXlzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IGFuZFxuICAgICAqIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb25cbiAgICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9yT3duUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duKG5ldyBGb28sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGtleSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93bihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JPd25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgcHJvcGVydGllcyBvZlxuICAgICAqIGBvYmplY3RgIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JPd25SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2InIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvck93bmAgbG9ncyAnYScgdGhlbiAnYicuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gICAgICogb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zSW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZnVuY3Rpb24gcHJvcGVydHkgbmFtZXMgZnJvbSBvd24gYW5kIGluaGVyaXRlZFxuICAgICAqIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGZ1bmN0aW9uIG5hbWVzLlxuICAgICAqIEBzZWUgXy5mdW5jdGlvbnNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gXy5jb25zdGFudCgnYScpO1xuICAgICAqICAgdGhpcy5iID0gXy5jb25zdGFudCgnYicpO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IF8uY29uc3RhbnQoJ2MnKTtcbiAgICAgKlxuICAgICAqIF8uZnVuY3Rpb25zSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICAgICAqIHZhciBvdGhlciA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzKG90aGVyLCAnYScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGludmVydGVkIGtleXMgYW5kIHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKiBJZiBgb2JqZWN0YCBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzLCBzdWJzZXF1ZW50IHZhbHVlcyBvdmVyd3JpdGVcbiAgICAgKiBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmludmVydChvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiAnYycsICcyJzogJ2InIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFt2YWx1ZV0gPSBrZXk7XG4gICAgfSwgY29uc3RhbnQoaWRlbnRpdHkpKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW52ZXJ0YCBleGNlcHQgdGhhdCB0aGUgaW52ZXJ0ZWQgb2JqZWN0IGlzIGdlbmVyYXRlZFxuICAgICAqIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgYG9iamVjdGAgdGhydSBgaXRlcmF0ZWVgLiBUaGVcbiAgICAgKiBjb3JyZXNwb25kaW5nIGludmVydGVkIHZhbHVlIG9mIGVhY2ggaW52ZXJ0ZWQga2V5IGlzIGFuIGFycmF5IG9mIGtleXNcbiAgICAgKiByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGUgaW52ZXJ0ZWQgdmFsdWUuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGludmVydC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnRCeShvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuICdncm91cCcgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdncm91cDEnOiBbJ2EnLCAnYyddLCAnZ3JvdXAyJzogWydiJ10gfVxuICAgICAqL1xuICAgIHZhciBpbnZlcnRCeSA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHRbdmFsdWVdLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFt2YWx1ZV0gPSBba2V5XTtcbiAgICAgIH1cbiAgICB9LCBnZXRJdGVyYXRlZSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIHRoZSBtZXRob2QgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSB0aGUgbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogWzEsIDIsIDMsIDRdIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8uaW52b2tlKG9iamVjdCwgJ2FbMF0uYi5jLnNsaWNlJywgMSwgMyk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgdmFyIGludm9rZSA9IGJhc2VSZXN0KGJhc2VJbnZva2UpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICAgICAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAgICAgKiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8ua2V5cygnaGknKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMSddXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmtleXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWFwVmFsdWVzYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgKiBzYW1lIHZhbHVlcyBhcyBgb2JqZWN0YCBhbmQga2V5cyBnZW5lcmF0ZWQgYnkgcnVubmluZyBlYWNoIG93biBlbnVtZXJhYmxlXG4gICAgICogc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIG9iamVjdC5cbiAgICAgKiBAc2VlIF8ubWFwVmFsdWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwS2V5cyh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIHJldHVybiBrZXkgKyB2YWx1ZTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiB7ICdhMSc6IDEsICdiMic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcEtleXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyBgb2JqZWN0YCBhbmQgdmFsdWVzIGdlbmVyYXRlZFxuICAgICAqIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAgdGhydVxuICAgICAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICAgICAqICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcEtleXNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2ZyZWQnOiAgICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwVmFsdWVzKHVzZXJzLCAnYWdlJyk7XG4gICAgICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcFZhbHVlcyhvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKTtcblxuICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uYXNzaWduYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBtZXJnZXMgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIGludG8gdGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gICAgICogc2tpcHBlZCBpZiBhIGRlc3RpbmF0aW9uIHZhbHVlIGV4aXN0cy4gQXJyYXkgYW5kIHBsYWluIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICogYXJlIG1lcmdlZCByZWN1cnNpdmVseS4gT3RoZXIgb2JqZWN0cyBhbmQgdmFsdWUgdHlwZXMgYXJlIG92ZXJyaWRkZW4gYnlcbiAgICAgKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAgICAgKiBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC41LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgb3RoZXIgPSB7XG4gICAgICogICAnYSc6IFt7ICdjJzogMyB9LCB7ICdlJzogNSB9XVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IDIsICdjJzogMyB9LCB7ICdkJzogNCwgJ2UnOiA1IH1dIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2UgPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpIHtcbiAgICAgIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tZXJnZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2hcbiAgICAgKiBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG1lcmdlZCB2YWx1ZXMgb2YgdGhlIGRlc3RpbmF0aW9uIGFuZCBzb3VyY2VcbiAgICAgKiBwcm9wZXJ0aWVzLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCwgbWVyZ2luZyBpcyBoYW5kbGVkIGJ5IHRoZVxuICAgICAqIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCBzaXggYXJndW1lbnRzOlxuICAgICAqIChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgKiAgICAgcmV0dXJuIG9ialZhbHVlLmNvbmNhdChzcmNWYWx1ZSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbMV0sICdiJzogWzJdIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYSc6IFszXSwgJ2InOiBbNF0gfTtcbiAgICAgKlxuICAgICAqIF8ubWVyZ2VXaXRoKG9iamVjdCwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbMSwgM10sICdiJzogWzIsIDRdIH1cbiAgICAgKi9cbiAgICB2YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5waWNrYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlXG4gICAgICogb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBwYXRocyBvZiBgb2JqZWN0YCB0aGF0IGFyZSBub3Qgb21pdHRlZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBjb25zaWRlcmFibHkgc2xvd2VyIHRoYW4gYF8ucGlja2AuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBvbWl0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5vbWl0KG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgdmFyIG9taXQgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgICAgIHBhdGhzID0gYXJyYXlNYXAocGF0aHMsIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9KTtcbiAgICAgIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0KTtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmVzdWx0ID0gYmFzZUNsb25lKHJlc3VsdCwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfRkxBVF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21PbWl0Q2xvbmUpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBiYXNlVW5zZXQocmVzdWx0LCBwYXRoc1tsZW5ndGhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja0J5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2ZcbiAgICAgKiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0aGF0XG4gICAgICogYHByZWRpY2F0ZWAgZG9lc24ndCByZXR1cm4gdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdHdvXG4gICAgICogYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdEJ5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYic6ICcyJyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gcGlja0J5KG9iamVjdCwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgcGlja2VkIGBvYmplY3RgIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB7fSA6IGJhc2VQaWNrKG9iamVjdCwgcGF0aHMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGBvYmplY3RgIHByb3BlcnRpZXMgYHByZWRpY2F0ZWAgcmV0dXJuc1xuICAgICAqIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6ICh2YWx1ZSwga2V5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICAgICAqXG4gICAgICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICByZXR1cm4gW3Byb3BdO1xuICAgICAgfSk7XG4gICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUpO1xuICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwcm9wcywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZSh2YWx1ZSwgcGF0aFswXSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmdldGAgZXhjZXB0IHRoYXQgaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFcbiAgICAgKiBmdW5jdGlvbiBpdCdzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgaXRzIHBhcmVudCBvYmplY3QgYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjMSc6IDMsICdjMic6IF8uY29uc3RhbnQoNCkgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMxJyk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMyJyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yZXN1bHQob2JqZWN0LCAnYVswXS5iLmMzJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsIF8uY29uc3RhbnQoJ2RlZmF1bHQnKSk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzdWx0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGUgbG9vcCBpcyBlbnRlcmVkIHdoZW4gcGF0aCBpcyBlbXB0eS5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIG9iamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXhdKV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiBhIHBvcnRpb24gb2YgYHBhdGhgIGRvZXNuJ3QgZXhpc3QsXG4gICAgICogaXQncyBjcmVhdGVkLiBBcnJheXMgYXJlIGNyZWF0ZWQgZm9yIG1pc3NpbmcgaW5kZXggcHJvcGVydGllcyB3aGlsZSBvYmplY3RzXG4gICAgICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcbiAgICAgKiBgcGF0aGAgY3JlYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjcuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLnNldChvYmplY3QsICdhWzBdLmIuYycsIDQpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LnhbMF0ueS56KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBwcm9kdWNlIHRoZSBvYmplY3RzIG9mIGBwYXRoYC4gIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgXG4gICAgICogcGF0aCBjcmVhdGlvbiBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6IChuc1ZhbHVlLCBrZXksIG5zT2JqZWN0KS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8uc2V0V2l0aChvYmplY3QsICdbMF1bMV0nLCAnYScsIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0V2l0aChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkLXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YFxuICAgICAqIHdoaWNoIGNhbiBiZSBjb25zdW1lZCBieSBgXy5mcm9tUGFpcnNgLiBJZiBgb2JqZWN0YCBpcyBhIG1hcCBvciBzZXQsIGl0c1xuICAgICAqIGVudHJpZXMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGVudHJpZXNcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl1dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlyc1xuICAgICAqIGZvciBgb2JqZWN0YCB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXBcbiAgICAgKiBvciBzZXQsIGl0cyBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzSW5cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy50b1BhaXJzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgdmFyIHRvUGFpcnNJbiA9IGNyZWF0ZVRvUGFpcnMoa2V5c0luKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAgICAgKiBgYWNjdW11bGF0b3JgIG9iamVjdCB3aGljaCBpcyB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgZWFjaCBvZiBpdHMgb3duXG4gICAgICogZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyB0aHJ1IGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uXG4gICAgICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBJZiBgYWNjdW11bGF0b3JgIGlzIG5vdFxuICAgICAqIHByb3ZpZGVkLCBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBgW1tQcm90b3R5cGVdXWAgd2lsbCBiZSB1c2VkLiBUaGVcbiAgICAgKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gICAgICogICByZXN1bHQucHVzaChuICo9IG4pO1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA5XVxuICAgICAqXG4gICAgICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiB9LCB7fSk7XG4gICAgICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgICAgIGlzQXJyTGlrZSA9IGlzQXJyIHx8IGlzQnVmZmVyKG9iamVjdCkgfHwgaXNUeXBlZEFycmF5KG9iamVjdCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDQpO1xuICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoaXNBcnJMaWtlKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBwcm9wZXJ0eSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1bnNldC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiA3IH0gfV0gfTtcbiAgICAgKiBfLnVuc2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqXG4gICAgICogXy51bnNldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICAgICAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB0cnVlIDogYmFzZVVuc2V0KG9iamVjdCwgcGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zZXRgIGV4Y2VwdCB0aGF0IGFjY2VwdHMgYHVwZGF0ZXJgIHRvIHByb2R1Y2UgdGhlXG4gICAgICogdmFsdWUgdG8gc2V0LiBVc2UgYF8udXBkYXRlV2l0aGAgdG8gY3VzdG9taXplIGBwYXRoYCBjcmVhdGlvbi4gVGhlIGB1cGRhdGVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAnYVswXS5iLmMnLCBmdW5jdGlvbihuKSB7IHJldHVybiBuICogbjsgfSk7XG4gICAgICogY29uc29sZS5sb2cob2JqZWN0LmFbMF0uYi5jKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICpcbiAgICAgKiBfLnVwZGF0ZShvYmplY3QsICd4WzBdLnkueicsIGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPyBuICsgMSA6IDA7IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlcikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udXBkYXRlYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjYuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHt9O1xuICAgICAqXG4gICAgICogXy51cGRhdGVXaXRoKG9iamVjdCwgJ1swXVsxXScsIF8uY29uc3RhbnQoJ2EnKSwgT2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcwJzogeyAnMSc6ICdhJyB9IH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVXaXRoKG9iamVjdCwgcGF0aCwgdXBkYXRlciwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIGNhc3RGdW5jdGlvbih1cGRhdGVyKSwgY3VzdG9taXplcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqXG4gICAgICogXy52YWx1ZXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWydoJywgJ2knXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHlcbiAgICAgKiB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENsYW1wcyBgbnVtYmVyYCB3aXRoaW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gY2xhbXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb3dlcl0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY2xhbXBlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoLTEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gLTVcbiAgICAgKlxuICAgICAqIF8uY2xhbXAoMTAsIC01LCA1KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXAobnVtYmVyLCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXBwZXIgPSB0b051bWJlcih1cHBlcik7XG4gICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICAgICAgfVxuICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbG93ZXIgPSB0b051bWJlcihsb3dlcik7XG4gICAgICAgIGxvd2VyID0gbG93ZXIgPT09IGxvd2VyID8gbG93ZXIgOiAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VDbGFtcCh0b051bWJlcihudW1iZXIpLCBsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgbmAgaXMgYmV0d2VlbiBgc3RhcnRgIGFuZCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICAgICAqIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsIGl0J3Mgc2V0IHRvIGBzdGFydGAgd2l0aCBgc3RhcnRgIHRoZW4gc2V0IHRvIGAwYC5cbiAgICAgKiBJZiBgc3RhcnRgIGlzIGdyZWF0ZXIgdGhhbiBgZW5kYCB0aGUgcGFyYW1zIGFyZSBzd2FwcGVkIHRvIHN1cHBvcnRcbiAgICAgKiBuZWdhdGl2ZSByYW5nZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ucmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMywgMiwgNCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDQsIDgpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDIsIDIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoMS4yLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNS4yLCA0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKC0zLCAtMiwgLTYpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gc3RhcnQ7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IHRvRmluaXRlKGVuZCk7XG4gICAgICB9XG4gICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgcmV0dXJuIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYSByYW5kb20gbnVtYmVyIGJldHdlZW4gdGhlIGluY2x1c2l2ZSBgbG93ZXJgIGFuZCBgdXBwZXJgIGJvdW5kcy5cbiAgICAgKiBJZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwcm92aWRlZCBhIG51bWJlciBiZXR3ZWVuIGAwYCBhbmQgdGhlIGdpdmVuIG51bWJlclxuICAgICAqIGlzIHJldHVybmVkLiBJZiBgZmxvYXRpbmdgIGlzIGB0cnVlYCwgb3IgZWl0aGVyIGBsb3dlcmAgb3IgYHVwcGVyYCBhcmVcbiAgICAgKiBmbG9hdHMsIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGlzIHJldHVybmVkIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAgICAgKiBmbG9hdGluZy1wb2ludCB2YWx1ZXMgd2hpY2ggY2FuIHByb2R1Y2UgdW5leHBlY3RlZCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXI9MF0gVGhlIGxvd2VyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdXBwZXI9MV0gVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zsb2F0aW5nXSBTcGVjaWZ5IHJldHVybmluZyBhIGZsb2F0aW5nLXBvaW50IG51bWJlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgwLCA1KTtcbiAgICAgKiAvLyA9PiBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSk7XG4gICAgICogLy8gPT4gYWxzbyBhbiBpbnRlZ2VyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oNSwgdHJ1ZSk7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCA1XG4gICAgICpcbiAgICAgKiBfLnJhbmRvbSgxLjIsIDUuMik7XG4gICAgICogLy8gPT4gYSBmbG9hdGluZy1wb2ludCBudW1iZXIgYmV0d2VlbiAxLjIgYW5kIDUuMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XG4gICAgICBpZiAoZmxvYXRpbmcgJiYgdHlwZW9mIGZsb2F0aW5nICE9ICdib29sZWFuJyAmJiBpc0l0ZXJhdGVlQ2FsbChsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSkge1xuICAgICAgICB1cHBlciA9IGZsb2F0aW5nID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cHBlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xuICAgICAgICAgIHVwcGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBmbG9hdGluZyA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPT09IHVuZGVmaW5lZCAmJiB1cHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgdXBwZXIgPSAxO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGxvd2VyID0gdG9GaW5pdGUobG93ZXIpO1xuICAgICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHVwcGVyID0gbG93ZXI7XG4gICAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwcGVyID0gdG9GaW5pdGUodXBwZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobG93ZXIgPiB1cHBlcikge1xuICAgICAgICB2YXIgdGVtcCA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVwcGVyO1xuICAgICAgICB1cHBlciA9IHRlbXA7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmcgfHwgbG93ZXIgJSAxIHx8IHVwcGVyICUgMSkge1xuICAgICAgICB2YXIgcmFuZCA9IG5hdGl2ZVJhbmRvbSgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlTWluKGxvd2VyICsgKHJhbmQgKiAodXBwZXIgLSBsb3dlciArIGZyZWVQYXJzZUZsb2F0KCcxZS0nICsgKChyYW5kICsgJycpLmxlbmd0aCAtIDEpKSkpLCB1cHBlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIFtjYW1lbCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYW1lbENhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FtZWwgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICpcbiAgICAgKiBfLmNhbWVsQ2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKi9cbiAgICB2YXIgY2FtZWxDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZSBhbmQgdGhlIHJlbWFpbmluZ1xuICAgICAqIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY2FwaXRhbGl6ZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY2FwaXRhbGl6ZSgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gdXBwZXJGaXJzdCh0b1N0cmluZyhzdHJpbmcpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlYnVycnMgYHN0cmluZ2AgYnkgY29udmVydGluZ1xuICAgICAqIFtMYXRpbi0xIFN1cHBsZW1lbnRdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluLTFfU3VwcGxlbWVudF8oVW5pY29kZV9ibG9jaykjQ2hhcmFjdGVyX3RhYmxlKVxuICAgICAqIGFuZCBbTGF0aW4gRXh0ZW5kZWQtQV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGF0aW5fRXh0ZW5kZWQtQSlcbiAgICAgKiBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMgYW5kIHJlbW92aW5nXG4gICAgICogW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBkZWJ1cnIuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZGVidXJyZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRlYnVycignZMOpasOgIHZ1Jyk7XG4gICAgICogLy8gPT4gJ2RlamEgdnUnXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVidXJyKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiBzdHJpbmcgJiYgc3RyaW5nLnJlcGxhY2UocmVMYXRpbiwgZGVidXJyTGV0dGVyKS5yZXBsYWNlKHJlQ29tYm9NYXJrLCAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGVuZHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj1zdHJpbmcubGVuZ3RoXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgc3RyaW5nYCBlbmRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2MnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVuZHNXaXRoKCdhYmMnLCAnYicsIDIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcblxuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBsZW5ndGhcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uO1xuICAgICAgcG9zaXRpb24gLT0gdGFyZ2V0Lmxlbmd0aDtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA+PSAwICYmIHN0cmluZy5zbGljZShwb3NpdGlvbiwgZW5kKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGNoYXJhY3RlcnMgXCImXCIsIFwiPFwiLCBcIj5cIiwgJ1wiJywgYW5kIFwiJ1wiIGluIGBzdHJpbmdgIHRvIHRoZWlyXG4gICAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIGNoYXJhY3RlcnMgYXJlIGVzY2FwZWQuIFRvIGVzY2FwZSBhZGRpdGlvbmFsXG4gICAgICogY2hhcmFjdGVycyB1c2UgYSB0aGlyZC1wYXJ0eSBsaWJyYXJ5IGxpa2UgW19oZV9dKGh0dHBzOi8vbXRocy5iZS9oZSkuXG4gICAgICpcbiAgICAgKiBUaG91Z2ggdGhlIFwiPlwiIGNoYXJhY3RlciBpcyBlc2NhcGVkIGZvciBzeW1tZXRyeSwgY2hhcmFjdGVycyBsaWtlXG4gICAgICogXCI+XCIgYW5kIFwiL1wiIGRvbid0IG5lZWQgZXNjYXBpbmcgaW4gSFRNTCBhbmQgaGF2ZSBubyBzcGVjaWFsIG1lYW5pbmdcbiAgICAgKiB1bmxlc3MgdGhleSdyZSBwYXJ0IG9mIGEgdGFnIG9yIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gU2VlXG4gICAgICogW01hdGhpYXMgQnluZW5zJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzKVxuICAgICAqICh1bmRlciBcInNlbWktcmVsYXRlZCBmdW4gZmFjdFwiKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogV2hlbiB3b3JraW5nIHdpdGggSFRNTCB5b3Ugc2hvdWxkIGFsd2F5c1xuICAgICAqIFtxdW90ZSBhdHRyaWJ1dGUgdmFsdWVzXShodHRwOi8vd29ua28uY29tL3Bvc3QvaHRtbC1lc2NhcGluZykgdG8gcmVkdWNlXG4gICAgICogWFNTIHZlY3RvcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmVzY2FwZSgnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmYW1wOyBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1VuZXNjYXBlZEh0bWwudGVzdChzdHJpbmcpKVxuICAgICAgICA/IHN0cmluZy5yZXBsYWNlKHJlVW5lc2NhcGVkSHRtbCwgZXNjYXBlSHRtbENoYXIpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAgICAgKiBcIj9cIiwgXCIoXCIsIFwiKVwiLCBcIltcIiwgXCJdXCIsIFwie1wiLCBcIn1cIiwgYW5kIFwifFwiIGluIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGVSZWdFeHAoJ1tsb2Rhc2hdKGh0dHBzOi8vbG9kYXNoLmNvbS8pJyk7XG4gICAgICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNSZWdFeHBDaGFyLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtrZWJhYiBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTcGVjaWFsX2Nhc2Vfc3R5bGVzKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGtlYmFiIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5rZWJhYkNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28tYmFyJ1xuICAgICAqL1xuICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnLScgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbG93ZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKlxuICAgICAqIF8ubG93ZXJDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb28gYmFyJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIGxvd2VyIGNhc2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIF8ubG93ZXJGaXJzdCgnRlJFRCcpO1xuICAgICAqIC8vID0+ICdmUkVEJ1xuICAgICAqL1xuICAgIHZhciBsb3dlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b0xvd2VyQ2FzZScpO1xuXG4gICAgLyoqXG4gICAgICogUGFkcyBgc3RyaW5nYCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZXMgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuXG4gICAgICogUGFkZGluZyBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBjYW4ndCBiZSBldmVubHkgZGl2aWRlZCBieSBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgOCk7XG4gICAgICogLy8gPT4gJyAgYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgsICdfLScpO1xuICAgICAqIC8vID0+ICdfLWFiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICBpZiAoIWxlbmd0aCB8fCBzdHJMZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVGbG9vcihtaWQpLCBjaGFycykgK1xuICAgICAgICBzdHJpbmcgK1xuICAgICAgICBjcmVhdGVQYWRkaW5nKG5hdGl2ZUNlaWwobWlkKSwgY2hhcnMpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIHJpZ2h0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYpO1xuICAgICAqIC8vID0+ICdhYmMgICAnXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ2FiY18tXydcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZEVuZChzdHJpbmcsIGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICByZXR1cm4gKGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGgpXG4gICAgICAgID8gKHN0cmluZyArIGNyZWF0ZVBhZGRpbmcobGVuZ3RoIC0gc3RyTGVuZ3RoLCBjaGFycykpXG4gICAgICAgIDogc3RyaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgc2lkZSBpZiBpdCdzIHNob3J0ZXIgdGhhbiBgbGVuZ3RoYC4gUGFkZGluZ1xuICAgICAqIGNoYXJhY3RlcnMgYXJlIHRydW5jYXRlZCBpZiB0aGV5IGV4Y2VlZCBgbGVuZ3RoYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBwYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MF0gVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnICAgYWJjJ1xuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNiwgJ18tJyk7XG4gICAgICogLy8gPT4gJ18tX2FiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDMpO1xuICAgICAqIC8vID0+ICdhYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFkU3RhcnQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpICsgc3RyaW5nKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBpbnRlZ2VyIG9mIHRoZSBzcGVjaWZpZWQgcmFkaXguIElmIGByYWRpeGAgaXNcbiAgICAgKiBgdW5kZWZpbmVkYCBvciBgMGAsIGEgYHJhZGl4YCBvZiBgMTBgIGlzIHVzZWQgdW5sZXNzIGB2YWx1ZWAgaXMgYVxuICAgICAqIGhleGFkZWNpbWFsLCBpbiB3aGljaCBjYXNlIGEgYHJhZGl4YCBvZiBgMTZgIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgYWxpZ25zIHdpdGggdGhlXG4gICAgICogW0VTNSBpbXBsZW1lbnRhdGlvbl0oaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTUuMS4yLjIpIG9mIGBwYXJzZUludGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyYWRpeD0xMF0gVGhlIHJhZGl4IHRvIGludGVycHJldCBgdmFsdWVgIGJ5LlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFyc2VJbnQoJzA4Jyk7XG4gICAgICogLy8gPT4gOFxuICAgICAqXG4gICAgICogXy5tYXAoWyc2JywgJzA4JywgJzEwJ10sIF8ucGFyc2VJbnQpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuICAgICAgaWYgKGd1YXJkIHx8IHJhZGl4ID09IG51bGwpIHtcbiAgICAgICAgcmFkaXggPSAwO1xuICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICByYWRpeCA9ICtyYWRpeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludCh0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKSwgcmFkaXggfHwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0cyB0aGUgZ2l2ZW4gc3RyaW5nIGBuYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byByZXBlYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmcuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByZXBlYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCcqJywgMyk7XG4gICAgICogLy8gPT4gJyoqKidcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAyKTtcbiAgICAgKiAvLyA9PiAnYWJjYWJjJ1xuICAgICAqXG4gICAgICogXy5yZXBlYXQoJ2FiYycsIDApO1xuICAgICAqIC8vID0+ICcnXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwZWF0KHN0cmluZywgbiwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG4sIGd1YXJkKSA6IG4gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSZXBlYXQodG9TdHJpbmcoc3RyaW5nKSwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgbWF0Y2hlcyBmb3IgYHBhdHRlcm5gIGluIGBzdHJpbmdgIHdpdGggYHJlcGxhY2VtZW50YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3JlcGxhY2VgXShodHRwczovL21kbi5pby9TdHJpbmcvcmVwbGFjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byByZXBsYWNlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSByZXBsYWNlbWVudCBUaGUgbWF0Y2ggcmVwbGFjZW1lbnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgbW9kaWZpZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGxhY2UoJ0hpIEZyZWQnLCAnRnJlZCcsICdCYXJuZXknKTtcbiAgICAgKiAvLyA9PiAnSGkgQmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UoKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhhcmdzWzBdKTtcblxuICAgICAgcmV0dXJuIGFyZ3MubGVuZ3RoIDwgMyA/IHN0cmluZyA6IHN0cmluZy5yZXBsYWNlKGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvXG4gICAgICogW3NuYWtlIGNhc2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NuYWtlX2Nhc2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc25ha2UgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNuYWtlQ2FzZSgnRm9vIEJhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJy0tRk9PLUJBUi0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb19iYXInXG4gICAgICovXG4gICAgdmFyIHNuYWtlQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICdfJyA6ICcnKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBieSBgc2VwYXJhdG9yYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgU3RyaW5nI3NwbGl0YF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3NwbGl0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBzcGxpdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHNlcGFyYXRvciBUaGUgc2VwYXJhdG9yIHBhdHRlcm4gdG8gc3BsaXQgYnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gVGhlIGxlbmd0aCB0byB0cnVuY2F0ZSByZXN1bHRzIHRvLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc3RyaW5nIHNlZ21lbnRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNwbGl0KCdhLWItYycsICctJywgMik7XG4gICAgICogLy8gPT4gWydhJywgJ2InXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgaWYgKGxpbWl0ICYmIHR5cGVvZiBsaW1pdCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpKSB7XG4gICAgICAgIHNlcGFyYXRvciA9IGxpbWl0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX0FSUkFZX0xFTkdUSCA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoXG4gICAgICAgICAgICB0eXBlb2Ygc2VwYXJhdG9yID09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAoc2VwYXJhdG9yICE9IG51bGwgJiYgIWlzUmVnRXhwKHNlcGFyYXRvcikpXG4gICAgICAgICAgKSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKCFzZXBhcmF0b3IgJiYgaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHN0cmluZyksIDAsIGxpbWl0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdChzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzdGFydCBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MZXR0ZXJfY2FzZSNTdHlsaXN0aWNfb3Jfc3BlY2lhbGlzZWRfdXNhZ2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RhcnQgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnRm9vIEJhcidcbiAgICAgKlxuICAgICAqIF8uc3RhcnRDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqL1xuICAgIHZhciBzdGFydENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnICcgOiAnJykgKyB1cHBlckZpcnN0KHdvcmQpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0YXJnZXRdIFRoZSBzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bvc2l0aW9uPTBdIFRoZSBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgdGFyZ2V0LCBwb3NpdGlvbikge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbFxuICAgICAgICA/IDBcbiAgICAgICAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgc3RyaW5nLmxlbmd0aCk7XG5cbiAgICAgIHRhcmdldCA9IGJhc2VUb1N0cmluZyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgY2FuIGludGVycG9sYXRlIGRhdGEgcHJvcGVydGllc1xuICAgICAqIGluIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJzLCBIVE1MLWVzY2FwZSBpbnRlcnBvbGF0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluXG4gICAgICogXCJlc2NhcGVcIiBkZWxpbWl0ZXJzLCBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0IGluIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXJzLiBEYXRhXG4gICAgICogcHJvcGVydGllcyBtYXkgYmUgYWNjZXNzZWQgYXMgZnJlZSB2YXJpYWJsZXMgaW4gdGhlIHRlbXBsYXRlLiBJZiBhIHNldHRpbmdcbiAgICAgKiBvYmplY3QgaXMgZ2l2ZW4sIGl0IHRha2VzIHByZWNlZGVuY2Ugb3ZlciBgXy50ZW1wbGF0ZVNldHRpbmdzYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplc1xuICAgICAqIFtzb3VyY2VVUkxzXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9kZXZlbG9wZXJ0b29scy9zb3VyY2VtYXBzLyN0b2Mtc291cmNldXJsKVxuICAgICAqIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBzZWVcbiAgICAgKiBbbG9kYXNoJ3MgY3VzdG9tIGJ1aWxkcyBkb2N1bWVudGF0aW9uXShodHRwczovL2xvZGFzaC5jb20vY3VzdG9tLWJ1aWxkcykuXG4gICAgICpcbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDaHJvbWUgZXh0ZW5zaW9uIHNhbmRib3hlcyBzZWVcbiAgICAgKiBbQ2hyb21lJ3MgZXh0ZW5zaW9ucyBkb2N1bWVudGF0aW9uXShodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvc2FuZGJveGluZ0V2YWwpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgdGVtcGxhdGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5lc2NhcGU9Xy50ZW1wbGF0ZVNldHRpbmdzLmVzY2FwZV1cbiAgICAgKiAgVGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmV2YWx1YXRlPV8udGVtcGxhdGVTZXR0aW5ncy5ldmFsdWF0ZV1cbiAgICAgKiAgVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmltcG9ydHM9Xy50ZW1wbGF0ZVNldHRpbmdzLmltcG9ydHNdXG4gICAgICogIEFuIG9iamVjdCB0byBpbXBvcnQgaW50byB0aGUgdGVtcGxhdGUgYXMgZnJlZSB2YXJpYWJsZXMuXG4gICAgICogQHBhcmFtIHtSZWdFeHB9IFtvcHRpb25zLmludGVycG9sYXRlPV8udGVtcGxhdGVTZXR0aW5ncy5pbnRlcnBvbGF0ZV1cbiAgICAgKiAgVGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnNvdXJjZVVSTD0nbG9kYXNoLnRlbXBsYXRlU291cmNlc1tuXSddXG4gICAgICogIFRoZSBzb3VyY2VVUkwgb2YgdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YXJpYWJsZT0nb2JqJ11cbiAgICAgKiAgVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNvbXBpbGVkIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIgdG8gY3JlYXRlIGEgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdmcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEhUTUwgXCJlc2NhcGVcIiBkZWxpbWl0ZXIgdG8gZXNjYXBlIGRhdGEgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAgICogLy8gPT4gJzxiPiZsdDtzY3JpcHQmZ3Q7PC9iPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgXCJldmFsdWF0ZVwiIGRlbGltaXRlciB0byBleGVjdXRlIEphdmFTY3JpcHQgYW5kIGdlbmVyYXRlIEhUTUwuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgXy5mb3JFYWNoKHVzZXJzLCBmdW5jdGlvbih1c2VyKSB7ICU+PGxpPjwlLSB1c2VyICU+PC9saT48JSB9KTsgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgaW50ZXJuYWwgYHByaW50YCBmdW5jdGlvbiBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8JSBwcmludChcImhlbGxvIFwiICsgdXNlcik7ICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnYmFybmV5JyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gYmFybmV5ISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgRVMgdGVtcGxhdGUgbGl0ZXJhbCBkZWxpbWl0ZXIgYXMgYW4gXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiAvLyBEaXNhYmxlIHN1cHBvcnQgYnkgcmVwbGFjaW5nIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvICR7IHVzZXIgfSEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ3BlYmJsZXMnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBwZWJibGVzISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSBiYWNrc2xhc2hlcyB0byB0cmVhdCBkZWxpbWl0ZXJzIGFzIHBsYWluIHRleHQuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCU9IFwiXFxcXDwlLSB2YWx1ZSAlXFxcXD5cIiAlPicpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3ZhbHVlJzogJ2lnbm9yZWQnIH0pO1xuICAgICAqIC8vID0+ICc8JS0gdmFsdWUgJT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBpbXBvcnRzYCBvcHRpb24gdG8gaW1wb3J0IGBqUXVlcnlgIGFzIGBqcWAuXG4gICAgICogdmFyIHRleHQgPSAnPCUganEuZWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKHRleHQsIHsgJ2ltcG9ydHMnOiB7ICdqcSc6IGpRdWVyeSB9IH0pO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXJzJzogWydmcmVkJywgJ2Jhcm5leSddIH0pO1xuICAgICAqIC8vID0+ICc8bGk+ZnJlZDwvbGk+PGxpPmJhcm5leTwvbGk+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgc291cmNlVVJMYCBvcHRpb24gdG8gc3BlY2lmeSBhIGN1c3RvbSBzb3VyY2VVUkwgZm9yIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gdXNlciAlPiEnLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAgICogY29tcGlsZWQoZGF0YSk7XG4gICAgICogLy8gPT4gRmluZCB0aGUgc291cmNlIG9mIFwiZ3JlZXRpbmcuanN0XCIgdW5kZXIgdGhlIFNvdXJjZXMgdGFiIG9yIFJlc291cmNlcyBwYW5lbCBvZiB0aGUgd2ViIGluc3BlY3Rvci5cbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHZhcmlhYmxlYCBvcHRpb24gdG8gZW5zdXJlIGEgd2l0aC1zdGF0ZW1lbnQgaXNuJ3QgdXNlZCBpbiB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGkgPCU9IGRhdGEudXNlciAlPiEnLCB7ICd2YXJpYWJsZSc6ICdkYXRhJyB9KTtcbiAgICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAgICogLy8gPT4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAqIC8vICAgdmFyIF9fdCwgX19wID0gJyc7XG4gICAgICogLy8gICBfX3AgKz0gJ2hpICcgKyAoKF9fdCA9ICggZGF0YS51c2VyICkpID09IG51bGwgPyAnJyA6IF9fdCkgKyAnISc7XG4gICAgICogLy8gICByZXR1cm4gX19wO1xuICAgICAqIC8vIH1cbiAgICAgKlxuICAgICAqIC8vIFVzZSBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVycy5cbiAgICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGUgPSAve3soW1xcc1xcU10rPyl9fS9nO1xuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIHt7IHVzZXIgfX0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdtdXN0YWNoZScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIG11c3RhY2hlISdcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZWAgcHJvcGVydHkgdG8gaW5saW5lIGNvbXBpbGVkIHRlbXBsYXRlcyBmb3IgbWVhbmluZ2Z1bFxuICAgICAqIC8vIGxpbmUgbnVtYmVycyBpbiBlcnJvciBtZXNzYWdlcyBhbmQgc3RhY2sgdHJhY2VzLlxuICAgICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdqc3QuanMnKSwgJ1xcXG4gICAgICogICB2YXIgSlNUID0ge1xcXG4gICAgICogICAgIFwibWFpblwiOiAnICsgXy50ZW1wbGF0ZShtYWluVGV4dCkuc291cmNlICsgJ1xcXG4gICAgICogICB9O1xcXG4gICAgICogJyk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgLy8gQmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gKGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvKVxuICAgICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qcyAoaHR0cHM6Ly9naXRodWIuY29tL29sYWRvL2RvVCkuXG4gICAgICB2YXIgc2V0dGluZ3MgPSBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncztcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuXG4gICAgICB2YXIgaW1wb3J0cyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucy5pbXBvcnRzLCBzZXR0aW5ncy5pbXBvcnRzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKSxcbiAgICAgICAgICBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksXG4gICAgICAgICAgaW1wb3J0c1ZhbHVlcyA9IGJhc2VWYWx1ZXMoaW1wb3J0cywgaW1wb3J0c0tleXMpO1xuXG4gICAgICB2YXIgaXNFc2NhcGluZyxcbiAgICAgICAgICBpc0V2YWx1YXRpbmcsXG4gICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsXG4gICAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiO1xuXG4gICAgICAvLyBDb21waWxlIHRoZSByZWdleHAgdG8gbWF0Y2ggZWFjaCBkZWxpbWl0ZXIuXG4gICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwKFxuICAgICAgICAob3B0aW9ucy5lc2NhcGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICBpbnRlcnBvbGF0ZS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAgIChvcHRpb25zLmV2YWx1YXRlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wkJ1xuICAgICAgLCAnZycpO1xuXG4gICAgICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gICAgICB2YXIgc291cmNlVVJMID0gJy8vIyBzb3VyY2VVUkw9JyArXG4gICAgICAgICgnc291cmNlVVJMJyBpbiBvcHRpb25zXG4gICAgICAgICAgPyBvcHRpb25zLnNvdXJjZVVSTFxuICAgICAgICAgIDogKCdsb2Rhc2gudGVtcGxhdGVTb3VyY2VzWycgKyAoKyt0ZW1wbGF0ZUNvdW50ZXIpICsgJ10nKVxuICAgICAgICApICsgJ1xcbic7XG5cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlRGVsaW1pdGVycywgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBlc1RlbXBsYXRlVmFsdWUsIGV2YWx1YXRlVmFsdWUsIG9mZnNldCkge1xuICAgICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgICAvLyBSZXBsYWNlIGRlbGltaXRlcnMgd2l0aCBzbmlwcGV0cy5cbiAgICAgICAgaWYgKGVzY2FwZVZhbHVlKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlVmFsdWUgKyBcIjtcXG5fX3AgKz0gJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgc291cmNlICs9IFwiJyArXFxuKChfX3QgPSAoXCIgKyBpbnRlcnBvbGF0ZVZhbHVlICsgXCIpKSA9PSBudWxsID8gJycgOiBfX3QpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgICAgLy8gVGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBwcm9kdWN0cyBuZWVkcyBgbWF0Y2hgIHJldHVybmVkIGluXG4gICAgICAgIC8vIG9yZGVyIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3QgYG9mZnNldGAgdmFsdWUuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgICAvLyBJZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgd3JhcCBhIHdpdGgtc3RhdGVtZW50IGFyb3VuZCB0aGUgZ2VuZXJhdGVkXG4gICAgICAvLyBjb2RlIHRvIGFkZCB0aGUgZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW4uXG4gICAgICB2YXIgdmFyaWFibGUgPSBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvTG93ZXJDYXNlXShodHRwczovL21kbi5pby90b0xvd2VyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1mb28tYmFyLS0nXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29iYXInXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG93ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gdXBwZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvVXBwZXJDYXNlXShodHRwczovL21kbi5pby90b1VwcGVyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1GT08tQkFSLS0nXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT09CQVInXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ19fRk9PX0JBUl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIGNoclN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KGNoYXJzKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpICsgMTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnICBhYmMnXG4gICAgICpcbiAgICAgKiBfLnRyaW1FbmQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICctXy1hYmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbUVuZChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1FbmQsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSkgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBsZWFkaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW1TdGFydCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICdhYmMgICdcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjLV8tJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW1TdGFydChzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgJycpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBzdHJpbmdUb0FycmF5KGNoYXJzKSk7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBgc3RyaW5nYCBpZiBpdCdzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogVGhlIGxhc3QgY2hhcmFjdGVycyBvZiB0aGUgdHJ1bmNhdGVkIHN0cmluZyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgb21pc3Npb25cbiAgICAgKiBzdHJpbmcgd2hpY2ggZGVmYXVsdHMgdG8gXCIuLi5cIi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cnVuY2F0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubGVuZ3RoPTMwXSBUaGUgbWF4aW11bSBzdHJpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vbWlzc2lvbj0nLi4uJ10gVGhlIHN0cmluZyB0byBpbmRpY2F0ZSB0ZXh0IGlzIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBbb3B0aW9ucy5zZXBhcmF0b3JdIFRoZSBzZXBhcmF0b3IgcGF0dGVybiB0byB0cnVuY2F0ZSB0by5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cnVuY2F0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJyk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hiby4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogJyAnXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZSwuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ2xlbmd0aCc6IDI0LFxuICAgICAqICAgJ3NlcGFyYXRvcic6IC8sPyArL1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUuLi4nXG4gICAgICpcbiAgICAgKiBfLnRydW5jYXRlKCdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWdoYm9yaW5vJywge1xuICAgICAqICAgJ29taXNzaW9uJzogJyBbLi4uXSdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnIFsuLi5dJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgdmFyIGxlbmd0aCA9IERFRkFVTFRfVFJVTkNfTEVOR1RILFxuICAgICAgICAgIG9taXNzaW9uID0gREVGQVVMVF9UUlVOQ19PTUlTU0lPTjtcblxuICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHZhciBzZXBhcmF0b3IgPSAnc2VwYXJhdG9yJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zZXBhcmF0b3IgOiBzZXBhcmF0b3I7XG4gICAgICAgIGxlbmd0aCA9ICdsZW5ndGgnIGluIG9wdGlvbnMgPyB0b0ludGVnZXIob3B0aW9ucy5sZW5ndGgpIDogbGVuZ3RoO1xuICAgICAgICBvbWlzc2lvbiA9ICdvbWlzc2lvbicgaW4gb3B0aW9ucyA/IGJhc2VUb1N0cmluZyhvcHRpb25zLm9taXNzaW9uKSA6IG9taXNzaW9uO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpO1xuICAgICAgICBzdHJMZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGggPj0gc3RyTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZW5kID0gbGVuZ3RoIC0gc3RyaW5nU2l6ZShvbWlzc2lvbik7XG4gICAgICBpZiAoZW5kIDwgMSkge1xuICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gc3RyU3ltYm9sc1xuICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oJycpXG4gICAgICAgIDogc3RyaW5nLnNsaWNlKDAsIGVuZCk7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgICB9XG4gICAgICBpZiAoc3RyU3ltYm9scykge1xuICAgICAgICBlbmQgKz0gKHJlc3VsdC5sZW5ndGggLSBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgdmFyIG1hdGNoLFxuICAgICAgICAgICAgICBzdWJzdHJpbmcgPSByZXN1bHQ7XG5cbiAgICAgICAgICBpZiAoIXNlcGFyYXRvci5nbG9iYWwpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyAnZycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3Vic3RyaW5nKSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdFbmQgPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIG5ld0VuZCA9PT0gdW5kZWZpbmVkID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJpbmcuaW5kZXhPZihiYXNlVG9TdHJpbmcoc2VwYXJhdG9yKSwgZW5kKSAhPSBlbmQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lmxhc3RJbmRleE9mKHNlcGFyYXRvcik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdCArIG9taXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnZlcnNlIG9mIGBfLmVzY2FwZWA7IHRoaXMgbWV0aG9kIGNvbnZlcnRzIHRoZSBIVE1MIGVudGl0aWVzXG4gICAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjMzk7YCBpbiBgc3RyaW5nYCB0b1xuICAgICAqIHRoZWlyIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBIVE1MIGVudGl0aWVzIGFyZSB1bmVzY2FwZWQuIFRvIHVuZXNjYXBlIGFkZGl0aW9uYWxcbiAgICAgKiBIVE1MIGVudGl0aWVzIHVzZSBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZSBbX2hlX10oaHR0cHM6Ly9tdGhzLmJlL2hlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjYuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuZXNjYXBlKCdmcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiAnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5lc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNFc2NhcGVkSHRtbC50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVFc2NhcGVkSHRtbCwgdW5lc2NhcGVIdG1sQ2hhcilcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVwcGVyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJy0tZm9vLWJhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT08gQkFSJ1xuICAgICAqXG4gICAgICogXy51cHBlckNhc2UoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICovXG4gICAgdmFyIHVwcGVyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCArIChpbmRleCA/ICcgJyA6ICcnKSArIHdvcmQudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AgdG8gdXBwZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udXBwZXJGaXJzdCgnZnJlZCcpO1xuICAgICAqIC8vID0+ICdGcmVkJ1xuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdGUkVEJyk7XG4gICAgICogLy8gPT4gJ0ZSRUQnXG4gICAgICovXG4gICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoJ3RvVXBwZXJDYXNlJyk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtwYXR0ZXJuXSBUaGUgcGF0dGVybiB0byBtYXRjaCB3b3Jkcy5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gWydmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIF8ud29yZHMoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJywgL1teLCBdKy9nKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJyYnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHBhdHRlcm4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IHBhdHRlcm47XG5cbiAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGVXb3JkKHN0cmluZykgPyB1bmljb2RlV29yZHMoc3RyaW5nKSA6IGFzY2lpV29yZHMoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gaW52b2tlIGBmdW5jYCwgcmV0dXJuaW5nIGVpdGhlciB0aGUgcmVzdWx0IG9yIHRoZSBjYXVnaHQgZXJyb3JcbiAgICAgKiBvYmplY3QuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhdHRlbXB0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBgZnVuY2AgcmVzdWx0IG9yIGVycm9yIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gQXZvaWQgdGhyb3dpbmcgZXJyb3JzIGZvciBpbnZhbGlkIHNlbGVjdG9ycy5cbiAgICAgKiB2YXIgZWxlbWVudHMgPSBfLmF0dGVtcHQoZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgKiAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgKiB9LCAnPl8+Jyk7XG4gICAgICpcbiAgICAgKiBpZiAoXy5pc0Vycm9yKGVsZW1lbnRzKSkge1xuICAgICAqICAgZWxlbWVudHMgPSBbXTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGlzRXJyb3IoZSkgPyBlIDogbmV3IEVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQmluZHMgbWV0aG9kcyBvZiBhbiBvYmplY3QgdG8gdGhlIG9iamVjdCBpdHNlbGYsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZ1xuICAgICAqIG1ldGhvZC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBiaW5kIGFuZCBhc3NpZ24gdGhlIGJvdW5kIG1ldGhvZHMgdG8uXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gbWV0aG9kTmFtZXMgVGhlIG9iamVjdCBtZXRob2QgbmFtZXMgdG8gYmluZC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdmlldyA9IHtcbiAgICAgKiAgICdsYWJlbCc6ICdkb2NzJyxcbiAgICAgKiAgICdjbGljayc6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICBjb25zb2xlLmxvZygnY2xpY2tlZCAnICsgdGhpcy5sYWJlbCk7XG4gICAgICogICB9XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIF8uYmluZEFsbCh2aWV3LCBbJ2NsaWNrJ10pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB2aWV3LmNsaWNrKTtcbiAgICAgKiAvLyA9PiBMb2dzICdjbGlja2VkIGRvY3MnIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICB2YXIgYmluZEFsbCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgbWV0aG9kTmFtZXMpIHtcbiAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGtleSA9IHRvS2V5KGtleSk7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgYmluZChvYmplY3Rba2V5XSwgb2JqZWN0KSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpdGVyYXRlcyBvdmVyIGBwYWlyc2AgYW5kIGludm9rZXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgKiBmdW5jdGlvbiBvZiB0aGUgZmlyc3QgcHJlZGljYXRlIHRvIHJldHVybiB0cnV0aHkuIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb25cbiAgICAgKiBwYWlycyBhcmUgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZSBjcmVhdGVkXG4gICAgICogZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBwcmVkaWNhdGUtZnVuY3Rpb24gcGFpcnMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8uY29uZChbXG4gICAgICogICBbXy5tYXRjaGVzKHsgJ2EnOiAxIH0pLCAgICAgICAgICAgXy5jb25zdGFudCgnbWF0Y2hlcyBBJyldLFxuICAgICAqICAgW18uY29uZm9ybXMoeyAnYic6IF8uaXNOdW1iZXIgfSksIF8uY29uc3RhbnQoJ21hdGNoZXMgQicpXSxcbiAgICAgKiAgIFtfLnN0dWJUcnVlLCAgICAgICAgICAgICAgICAgICAgICBfLmNvbnN0YW50KCdubyBtYXRjaCcpXVxuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+ICdtYXRjaGVzIEEnXG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAwLCAnYic6IDEgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQidcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6ICcxJywgJ2InOiAnMicgfSk7XG4gICAgICogLy8gPT4gJ25vIG1hdGNoJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmQocGFpcnMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCxcbiAgICAgICAgICB0b0l0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoKTtcblxuICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICBpZiAodHlwZW9mIHBhaXJbMV0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RvSXRlcmF0ZWUocGFpclswXSksIHBhaXJbMV1dO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgIGlmIChhcHBseShwYWlyWzBdLCB0aGlzLCBhcmdzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgcHJlZGljYXRlIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgd2l0aFxuICAgICAqIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBhIGdpdmVuIG9iamVjdCwgcmV0dXJuaW5nIGB0cnVlYCBpZlxuICAgICAqIGFsbCBwcmVkaWNhdGVzIHJldHVybiB0cnV0aHksIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zVG9gIHdpdGhcbiAgICAgKiBgc291cmNlYCBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAyLCAnYic6IDEgfSxcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLmNvbmZvcm1zKHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMTsgfSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ2EnOiAxLCAnYic6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlQ29uZm9ybXMoYmFzZUNsb25lKHNvdXJjZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBgdmFsdWVgIHRvIGRldGVybWluZSB3aGV0aGVyIGEgZGVmYXVsdCB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWQgaW5cbiAgICAgKiBpdHMgcGxhY2UuIFRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBgbnVsbGAsXG4gICAgICogb3IgYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0geyp9IGRlZmF1bHRWYWx1ZSBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKDEsIDEwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiBfLmRlZmF1bHRUbyh1bmRlZmluZWQsIDEwKTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmF1bHRUbyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICByZXR1cm4gKHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBpbnZva2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb25zXG4gICAgICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24sIHdoZXJlIGVhY2ggc3VjY2Vzc2l2ZVxuICAgICAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbZnVuY3NdIFRoZSBmdW5jdGlvbnMgdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbXBvc2l0ZSBmdW5jdGlvbi5cbiAgICAgKiBAc2VlIF8uZmxvd1JpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvdyhbXy5hZGQsIHNxdWFyZV0pO1xuICAgICAqIGFkZFNxdWFyZSgxLCAyKTtcbiAgICAgKiAvLyA9PiA5XG4gICAgICovXG4gICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZsb3dgIGV4Y2VwdCB0aGF0IGl0IGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaW52b2tlcyB0aGUgZ2l2ZW4gZnVuY3Rpb25zIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGFkZFNxdWFyZSA9IF8uZmxvd1JpZ2h0KFtzcXVhcmUsIF8uYWRkXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvd1JpZ2h0ID0gY3JlYXRlRmxvdyh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi4gSWYgYGZ1bmNgIGlzIGEgcHJvcGVydHkgbmFtZSwgdGhlIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGVcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZSBmb3IgYSBnaXZlbiBlbGVtZW50LiBJZiBgZnVuY2AgaXMgYW4gYXJyYXkgb3Igb2JqZWN0LCB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGZvciBlbGVtZW50cyB0aGF0IGNvbnRhaW4gdGhlIGVxdWl2YWxlbnRcbiAgICAgKiBzb3VyY2UgcHJvcGVydGllcywgb3RoZXJ3aXNlIGl0IHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsqfSBbZnVuYz1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY2FsbGJhY2suXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KSk7XG4gICAgICogLy8gPT4gW3sgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9XVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBfLml0ZXJhdGVlKFsndXNlcicsICdmcmVkJ10pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcCh1c2VycywgXy5pdGVyYXRlZSgndXNlcicpKTtcbiAgICAgKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBjdXN0b20gaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKiBfLml0ZXJhdGVlID0gXy53cmFwKF8uaXRlcmF0ZWUsIGZ1bmN0aW9uKGl0ZXJhdGVlLCBmdW5jKSB7XG4gICAgICogICByZXR1cm4gIV8uaXNSZWdFeHAoZnVuYykgPyBpdGVyYXRlZShmdW5jKSA6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gZnVuYy50ZXN0KHN0cmluZyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIoWydhYmMnLCAnZGVmJ10sIC9lZi8pO1xuICAgICAqIC8vID0+IFsnZGVmJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpdGVyYXRlZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmFzZUl0ZXJhdGVlKHR5cGVvZiBmdW5jID09ICdmdW5jdGlvbicgPyBmdW5jIDogYmFzZUNsb25lKGZ1bmMsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBhIGdpdmVuXG4gICAgICogb2JqZWN0IGFuZCBgc291cmNlYCwgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGhhcyBlcXVpdmFsZW50XG4gICAgICogcHJvcGVydHkgdmFsdWVzLCBlbHNlIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhlIGNyZWF0ZWQgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byBgXy5pc01hdGNoYCB3aXRoIGBzb3VyY2VgXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSxcbiAgICAgKiAgIHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ubWF0Y2hlcyh7ICdhJzogNCwgJ2MnOiA2IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdGhlXG4gICAgICogdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIGBzcmNWYWx1ZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlXG4gICAgICogb2JqZWN0IHZhbHVlIGlzIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdFxuICAgICAqIGBzcmNWYWx1ZWAgdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWVcbiAgICAgKiBgXy5pc0VxdWFsYCBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKG9iamVjdHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCkpO1xuICAgICAqIC8vID0+IHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBiYXNlQ2xvbmUoc3JjVmFsdWUsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgyKSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMSkgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZChbJ2EnLCAnYiddKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IF8udGltZXMoMywgXy5jb25zdGFudCksXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2VcbiAgICAgKiBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiwgdGhlbiBtZXRob2RzXG4gICAgICogYXJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIG1peGlucyBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuICAgICAqIF8udm93ZWxzKCdmcmVkJyk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsICYmXG4gICAgICAgICAgIShpc09iamVjdChzb3VyY2UpICYmIChtZXRob2ROYW1lcy5sZW5ndGggfHwgIXByb3BzLmxlbmd0aCkpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdGhpcztcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFpbiA9ICEoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB8fCAhIW9wdGlvbnMuY2hhaW4sXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpO1xuXG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0KHRoaXMuX193cmFwcGVkX18pLFxuICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IGZ1bmMsICdhcmdzJzogYXJndW1lbnRzLCAndGhpc0FyZyc6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgaWYgKHJvb3QuXyA9PT0gdGhpcykge1xuICAgICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgYXJndW1lbnQgYXQgaW5kZXggYG5gLiBJZiBgbmAgaXMgbmVnYXRpdmUsXG4gICAgICogdGhlIG50aCBhcmd1bWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXNzLXRocnUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoMSk7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygtMik7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBpdGVyYXRlZXNgIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlc1xuICAgICAqIGFuZCByZXR1cm5zIHRoZWlyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyKFtNYXRoLm1heCwgTWF0aC5taW5dKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzQsIDFdXG4gICAgICovXG4gICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFsbCoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbcHJlZGljYXRlcz1bXy5pZGVudGl0eV1dXG4gICAgICogIFRoZSBwcmVkaWNhdGVzIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgZnVuYyA9IF8ub3ZlckV2ZXJ5KFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvdmVyRXZlcnkgPSBjcmVhdGVPdmVyKGFycmF5RXZlcnkpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmICoqYW55Kiogb2YgdGhlIGBwcmVkaWNhdGVzYCByZXR1cm5cbiAgICAgKiB0cnV0aHkgd2hlbiBpbnZva2VkIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtwcmVkaWNhdGVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIHByZWRpY2F0ZXMgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyU29tZShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBvdmVyU29tZSA9IGNyZWF0ZU92ZXIoYXJyYXlTb21lKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbXG4gICAgICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICAgICAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5wcm9wZXJ0eWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnNcbiAgICAgKiB0aGUgdmFsdWUgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFswLCAxLCAyXSxcbiAgICAgKiAgICAgb2JqZWN0ID0geyAnYSc6IGFycmF5LCAnYic6IGFycmF5LCAnYyc6IGFycmF5IH07XG4gICAgICpcbiAgICAgKiBfLm1hcChbJ2FbMl0nLCAnY1swXSddLCBfLnByb3BlcnR5T2Yob2JqZWN0KSk7XG4gICAgICogLy8gPT4gWzIsIDBdXG4gICAgICpcbiAgICAgKiBfLm1hcChbWydhJywgJzInXSwgWydjJywgJzAnXV0sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICAgICAqIGBzdGFydGAgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gQSBzdGVwIG9mIGAtMWAgaXMgdXNlZCBpZiBhIG5lZ2F0aXZlXG4gICAgICogYHN0YXJ0YCBpcyBzcGVjaWZpZWQgd2l0aG91dCBhbiBgZW5kYCBvciBgc3RlcGAuIElmIGBlbmRgIGlzIG5vdCBzcGVjaWZpZWQsXG4gICAgICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEphdmFTY3JpcHQgZm9sbG93cyB0aGUgSUVFRS03NTQgc3RhbmRhcmQgZm9yIHJlc29sdmluZ1xuICAgICAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDQpO1xuICAgICAqIC8vID0+IFswLCAxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgtNCk7XG4gICAgICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDEsIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCA0XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzAsIDUsIDEwLCAxNV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNCwgMCk7XG4gICAgICogLy8gPT4gWzEsIDEsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlID0gY3JlYXRlUmFuZ2UoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmFuZ2VgIGV4Y2VwdCB0aGF0IGl0IHBvcHVsYXRlcyB2YWx1ZXMgaW5cbiAgICAgKiBkZXNjZW5kaW5nIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICAgICAqIEBzZWUgXy5pblJhbmdlLCBfLnJhbmdlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCg0KTtcbiAgICAgKiAvLyA9PiBbMywgMiwgMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgtNCk7XG4gICAgICogLy8gPT4gWy0zLCAtMiwgLTEsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMSwgNSk7XG4gICAgICogLy8gPT4gWzQsIDMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgMjAsIDUpO1xuICAgICAqIC8vID0+IFsxNSwgMTAsIDUsIDBdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlUmlnaHQoMCwgLTQsIC0xKTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIHZhciByYW5nZVJpZ2h0ID0gY3JlYXRlUmFuZ2UodHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gICAgICogLy8gPT4gW1tdLCBbXV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAgICAgKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLnN0dWJPYmplY3QpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gICAgICogLy8gPT4gW3t9LCB7fV1cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1Yk9iamVjdCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnJywgJyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YlN0cmluZygpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygyLCBfLnN0dWJUcnVlKTtcbiAgICAgKiAvLyA9PiBbdHJ1ZSwgdHJ1ZV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViVHJ1ZSgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGl0ZXJhdGVlIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzIG9mXG4gICAgICogZWFjaCBpbnZvY2F0aW9uLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMywgU3RyaW5nKTtcbiAgICAgKiAvLyA9PiBbJzAnLCAnMScsICcyJ11cbiAgICAgKlxuICAgICAqICBfLnRpbWVzKDQsIF8uY29uc3RhbnQoMCkpO1xuICAgICAqIC8vID0+IFswLCAwLCAwLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgaWYgKG4gPCAxIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IE1BWF9BUlJBWV9MRU5HVEgsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlKTtcbiAgICAgIG4gLT0gTUFYX0FSUkFZX0xFTkdUSDtcblxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VUaW1lcyhsZW5ndGgsIGl0ZXJhdGVlKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICBpdGVyYXRlZShpbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9QYXRoKCdhLmIuYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2FbMF0uYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BhdGgodmFsdWUpIHtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc1N5bWJvbCh2YWx1ZSkgPyBbdmFsdWVdIDogY29weUFycmF5KHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSB1bmlxdWUgSUQuIElmIGBwcmVmaXhgIGlzIGdpdmVuLCB0aGUgSUQgaXMgYXBwZW5kZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4PScnXSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBJRCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAgICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCk7XG4gICAgICogLy8gPT4gJzEwNSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgcmV0dXJuIHRvU3RyaW5nKHByZWZpeCkgKyBpZDtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXVnZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYW4gYWRkaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFkZGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0b3RhbC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5hZGQoNiwgNCk7XG4gICAgICogLy8gPT4gMTBcbiAgICAgKi9cbiAgICB2YXIgYWRkID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihhdWdlbmQsIGFkZGVuZCkge1xuICAgICAgcmV0dXJuIGF1Z2VuZCArIGFkZGVuZDtcbiAgICB9LCAwKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdXAgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQgdXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIHVwIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jZWlsKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICpcbiAgICAgKiBfLmNlaWwoNi4wMDQsIDIpO1xuICAgICAqIC8vID0+IDYuMDFcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2MDQwLCAtMik7XG4gICAgICogLy8gPT4gNjEwMFxuICAgICAqL1xuICAgIHZhciBjZWlsID0gY3JlYXRlUm91bmQoJ2NlaWwnKTtcblxuICAgIC8qKlxuICAgICAqIERpdmlkZSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdmlkZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBkaXZpc2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aXNvciBUaGUgc2Vjb25kIG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHF1b3RpZW50LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpdmlkZSg2LCA0KTtcbiAgICAgKiAvLyA9PiAxLjVcbiAgICAgKi9cbiAgICB2YXIgZGl2aWRlID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgZG93biB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCBkb3duLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFRoZSBwcmVjaXNpb24gdG8gcm91bmQgZG93biB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIGRvd24gbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDAuMDQ2LCAyKTtcbiAgICAgKiAvLyA9PiAwLjA0XG4gICAgICpcbiAgICAgKiBfLmZsb29yKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MDAwXG4gICAgICovXG4gICAgdmFyIGZsb29yID0gY3JlYXRlUm91bmQoJ2Zsb29yJyk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tYXgoWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiA4XG4gICAgICpcbiAgICAgKiBfLm1heChbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4KGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWF4YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1heEJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heEJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIG1lYW4gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG1lYW4uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWVhbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZWFuKGFycmF5KSB7XG4gICAgICByZXR1cm4gYmFzZU1lYW4oYXJyYXksIGlkZW50aXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1lYW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBhdmVyYWdlZC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLm1lYW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAgICAgKiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiBfLm1pbihbXSk7XG4gICAgICogLy8gPT4gdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlTHQpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgZnVuY3Rpb24obykgeyByZXR1cm4gby5uOyB9KTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4geyAnbic6IDEgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbHkgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC43LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWVyIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbXVsdGlwbGljYW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgbXVsdGlwbGljYXRpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcHJvZHVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tdWx0aXBseSg2LCA0KTtcbiAgICAgKiAvLyA9PiAyNFxuICAgICAqL1xuICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XG4gICAgICByZXR1cm4gbXVsdGlwbGllciAqIG11bHRpcGxpY2FuZDtcbiAgICB9LCAxKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGBudW1iZXJgIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4xMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIFRoZSBudW1iZXIgdG8gcm91bmQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCB0by5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByb3VuZGVkIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNik7XG4gICAgICogLy8gPT4gNFxuICAgICAqXG4gICAgICogXy5yb3VuZCg0LjAwNiwgMik7XG4gICAgICogLy8gPT4gNC4wMVxuICAgICAqXG4gICAgICogXy5yb3VuZCg0MDYwLCAtMik7XG4gICAgICogLy8gPT4gNDEwMFxuICAgICAqL1xuICAgIHZhciByb3VuZCA9IGNyZWF0ZVJvdW5kKCdyb3VuZCcpO1xuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW51ZW5kIFRoZSBmaXJzdCBudW1iZXIgaW4gYSBzdWJ0cmFjdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3VidHJhaGVuZCBUaGUgc2Vjb25kIG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGRpZmZlcmVuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VidHJhY3QoNiwgNCk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIHZhciBzdWJ0cmFjdCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgcmV0dXJuIG1pbnVlbmQgLSBzdWJ0cmFoZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgdGhlIHN1bSBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnN1bShbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU3VtKGFycmF5LCBpZGVudGl0eSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc3VtYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgdmFsdWUgdG8gYmUgc3VtbWVkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiA0IH0sIHsgJ24nOiAyIH0sIHsgJ24nOiA4IH0sIHsgJ24nOiA2IH1dO1xuICAgICAqXG4gICAgICogXy5zdW1CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IDIwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsICduJyk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiAwO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHdyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICBsb2Rhc2guYXJ5ID0gYXJ5O1xuICAgIGxvZGFzaC5hc3NpZ24gPSBhc3NpZ247XG4gICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gICAgbG9kYXNoLmFzc2lnbkluV2l0aCA9IGFzc2lnbkluV2l0aDtcbiAgICBsb2Rhc2guYXNzaWduV2l0aCA9IGFzc2lnbldpdGg7XG4gICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgbG9kYXNoLmJlZm9yZSA9IGJlZm9yZTtcbiAgICBsb2Rhc2guYmluZCA9IGJpbmQ7XG4gICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgIGxvZGFzaC5iaW5kS2V5ID0gYmluZEtleTtcbiAgICBsb2Rhc2guY2FzdEFycmF5ID0gY2FzdEFycmF5O1xuICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgIGxvZGFzaC5jaHVuayA9IGNodW5rO1xuICAgIGxvZGFzaC5jb21wYWN0ID0gY29tcGFjdDtcbiAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xuICAgIGxvZGFzaC5jb25kID0gY29uZDtcbiAgICBsb2Rhc2guY29uZm9ybXMgPSBjb25mb3JtcztcbiAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gICAgbG9kYXNoLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICBsb2Rhc2guY3VycnlSaWdodCA9IGN1cnJ5UmlnaHQ7XG4gICAgbG9kYXNoLmRlYm91bmNlID0gZGVib3VuY2U7XG4gICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgbG9kYXNoLmRlZmF1bHRzRGVlcCA9IGRlZmF1bHRzRGVlcDtcbiAgICBsb2Rhc2guZGVmZXIgPSBkZWZlcjtcbiAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gICAgbG9kYXNoLmRpZmZlcmVuY2VCeSA9IGRpZmZlcmVuY2VCeTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcbiAgICBsb2Rhc2guZHJvcCA9IGRyb3A7XG4gICAgbG9kYXNoLmRyb3BSaWdodCA9IGRyb3BSaWdodDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2guZHJvcFdoaWxlID0gZHJvcFdoaWxlO1xuICAgIGxvZGFzaC5maWxsID0gZmlsbDtcbiAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgIGxvZGFzaC5mbGF0TWFwID0gZmxhdE1hcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlZXAgPSBmbGF0TWFwRGVlcDtcbiAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xuICAgIGxvZGFzaC5mbGF0dGVuID0gZmxhdHRlbjtcbiAgICBsb2Rhc2guZmxhdHRlbkRlZXAgPSBmbGF0dGVuRGVlcDtcbiAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xuICAgIGxvZGFzaC5mbGlwID0gZmxpcDtcbiAgICBsb2Rhc2guZmxvdyA9IGZsb3c7XG4gICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICBsb2Rhc2guZnJvbVBhaXJzID0gZnJvbVBhaXJzO1xuICAgIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XG4gICAgbG9kYXNoLmdyb3VwQnkgPSBncm91cEJ5O1xuICAgIGxvZGFzaC5pbml0aWFsID0gaW5pdGlhbDtcbiAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25CeSA9IGludGVyc2VjdGlvbkJ5O1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb25XaXRoID0gaW50ZXJzZWN0aW9uV2l0aDtcbiAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgIGxvZGFzaC5pbnZlcnRCeSA9IGludmVydEJ5O1xuICAgIGxvZGFzaC5pbnZva2VNYXAgPSBpbnZva2VNYXA7XG4gICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gICAgbG9kYXNoLmtleUJ5ID0ga2V5Qnk7XG4gICAgbG9kYXNoLmtleXMgPSBrZXlzO1xuICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgbG9kYXNoLm1hcCA9IG1hcDtcbiAgICBsb2Rhc2gubWFwS2V5cyA9IG1hcEtleXM7XG4gICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICBsb2Rhc2gubWF0Y2hlcyA9IG1hdGNoZXM7XG4gICAgbG9kYXNoLm1hdGNoZXNQcm9wZXJ0eSA9IG1hdGNoZXNQcm9wZXJ0eTtcbiAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gICAgbG9kYXNoLm1lcmdlID0gbWVyZ2U7XG4gICAgbG9kYXNoLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgICBsb2Rhc2gubWV0aG9kID0gbWV0aG9kO1xuICAgIGxvZGFzaC5tZXRob2RPZiA9IG1ldGhvZE9mO1xuICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgIGxvZGFzaC5uZWdhdGUgPSBuZWdhdGU7XG4gICAgbG9kYXNoLm50aEFyZyA9IG50aEFyZztcbiAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgbG9kYXNoLm9taXRCeSA9IG9taXRCeTtcbiAgICBsb2Rhc2gub25jZSA9IG9uY2U7XG4gICAgbG9kYXNoLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgIGxvZGFzaC5vdmVyID0gb3ZlcjtcbiAgICBsb2Rhc2gub3ZlckFyZ3MgPSBvdmVyQXJncztcbiAgICBsb2Rhc2gub3ZlckV2ZXJ5ID0gb3ZlckV2ZXJ5O1xuICAgIGxvZGFzaC5vdmVyU29tZSA9IG92ZXJTb21lO1xuICAgIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgIGxvZGFzaC5wYXJ0aXRpb24gPSBwYXJ0aXRpb247XG4gICAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICAgIGxvZGFzaC5waWNrQnkgPSBwaWNrQnk7XG4gICAgbG9kYXNoLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgbG9kYXNoLnByb3BlcnR5T2YgPSBwcm9wZXJ0eU9mO1xuICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICBsb2Rhc2gucHVsbEFsbCA9IHB1bGxBbGw7XG4gICAgbG9kYXNoLnB1bGxBbGxCeSA9IHB1bGxBbGxCeTtcbiAgICBsb2Rhc2gucHVsbEFsbFdpdGggPSBwdWxsQWxsV2l0aDtcbiAgICBsb2Rhc2gucHVsbEF0ID0gcHVsbEF0O1xuICAgIGxvZGFzaC5yYW5nZSA9IHJhbmdlO1xuICAgIGxvZGFzaC5yYW5nZVJpZ2h0ID0gcmFuZ2VSaWdodDtcbiAgICBsb2Rhc2gucmVhcmcgPSByZWFyZztcbiAgICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgbG9kYXNoLnJlc3QgPSByZXN0O1xuICAgIGxvZGFzaC5yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICBsb2Rhc2guc2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgbG9kYXNoLnNldCA9IHNldDtcbiAgICBsb2Rhc2guc2V0V2l0aCA9IHNldFdpdGg7XG4gICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgIGxvZGFzaC5zbGljZSA9IHNsaWNlO1xuICAgIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXEgPSBzb3J0ZWRVbmlxO1xuICAgIGxvZGFzaC5zb3J0ZWRVbmlxQnkgPSBzb3J0ZWRVbmlxQnk7XG4gICAgbG9kYXNoLnNwbGl0ID0gc3BsaXQ7XG4gICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICBsb2Rhc2gudGFpbCA9IHRhaWw7XG4gICAgbG9kYXNoLnRha2UgPSB0YWtlO1xuICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgbG9kYXNoLnRha2VSaWdodFdoaWxlID0gdGFrZVJpZ2h0V2hpbGU7XG4gICAgbG9kYXNoLnRha2VXaGlsZSA9IHRha2VXaGlsZTtcbiAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgIGxvZGFzaC50aHJvdHRsZSA9IHRocm90dGxlO1xuICAgIGxvZGFzaC50aHJ1ID0gdGhydTtcbiAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgbG9kYXNoLnRvUGFpcnMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC50b1BhaXJzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLnRvUGF0aCA9IHRvUGF0aDtcbiAgICBsb2Rhc2gudG9QbGFpbk9iamVjdCA9IHRvUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBsb2Rhc2gudW5hcnkgPSB1bmFyeTtcbiAgICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgICBsb2Rhc2gudW5pb25CeSA9IHVuaW9uQnk7XG4gICAgbG9kYXNoLnVuaW9uV2l0aCA9IHVuaW9uV2l0aDtcbiAgICBsb2Rhc2gudW5pcSA9IHVuaXE7XG4gICAgbG9kYXNoLnVuaXFCeSA9IHVuaXFCeTtcbiAgICBsb2Rhc2gudW5pcVdpdGggPSB1bmlxV2l0aDtcbiAgICBsb2Rhc2gudW5zZXQgPSB1bnNldDtcbiAgICBsb2Rhc2gudW56aXAgPSB1bnppcDtcbiAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgIGxvZGFzaC51cGRhdGUgPSB1cGRhdGU7XG4gICAgbG9kYXNoLnVwZGF0ZVdpdGggPSB1cGRhdGVXaXRoO1xuICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgbG9kYXNoLnZhbHVlc0luID0gdmFsdWVzSW47XG4gICAgbG9kYXNoLndpdGhvdXQgPSB3aXRob3V0O1xuICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuICAgIGxvZGFzaC53cmFwID0gd3JhcDtcbiAgICBsb2Rhc2gueG9yID0geG9yO1xuICAgIGxvZGFzaC54b3JCeSA9IHhvckJ5O1xuICAgIGxvZGFzaC54b3JXaXRoID0geG9yV2l0aDtcbiAgICBsb2Rhc2guemlwID0gemlwO1xuICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgbG9kYXNoLnppcE9iamVjdERlZXAgPSB6aXBPYmplY3REZWVwO1xuICAgIGxvZGFzaC56aXBXaXRoID0gemlwV2l0aDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lbnRyaWVzID0gdG9QYWlycztcbiAgICBsb2Rhc2guZW50cmllc0luID0gdG9QYWlyc0luO1xuICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guZXh0ZW5kV2l0aCA9IGFzc2lnbkluV2l0aDtcblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBtaXhpbihsb2Rhc2gsIGxvZGFzaCk7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0aGF0IHJldHVybiB1bndyYXBwZWQgdmFsdWVzIGluIGNoYWluIHNlcXVlbmNlcy5cbiAgICBsb2Rhc2guYWRkID0gYWRkO1xuICAgIGxvZGFzaC5hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgIGxvZGFzaC5jYXBpdGFsaXplID0gY2FwaXRhbGl6ZTtcbiAgICBsb2Rhc2guY2VpbCA9IGNlaWw7XG4gICAgbG9kYXNoLmNsYW1wID0gY2xhbXA7XG4gICAgbG9kYXNoLmNsb25lID0gY2xvbmU7XG4gICAgbG9kYXNoLmNsb25lRGVlcCA9IGNsb25lRGVlcDtcbiAgICBsb2Rhc2guY2xvbmVEZWVwV2l0aCA9IGNsb25lRGVlcFdpdGg7XG4gICAgbG9kYXNoLmNsb25lV2l0aCA9IGNsb25lV2l0aDtcbiAgICBsb2Rhc2guY29uZm9ybXNUbyA9IGNvbmZvcm1zVG87XG4gICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICBsb2Rhc2guZGVmYXVsdFRvID0gZGVmYXVsdFRvO1xuICAgIGxvZGFzaC5kaXZpZGUgPSBkaXZpZGU7XG4gICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgbG9kYXNoLmVxID0gZXE7XG4gICAgbG9kYXNoLmVzY2FwZSA9IGVzY2FwZTtcbiAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICAgIGxvZGFzaC5maW5kID0gZmluZDtcbiAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgIGxvZGFzaC5maW5kS2V5ID0gZmluZEtleTtcbiAgICBsb2Rhc2guZmluZExhc3QgPSBmaW5kTGFzdDtcbiAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLmZpbmRMYXN0S2V5ID0gZmluZExhc3RLZXk7XG4gICAgbG9kYXNoLmZsb29yID0gZmxvb3I7XG4gICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgIGxvZGFzaC5mb3JFYWNoUmlnaHQgPSBmb3JFYWNoUmlnaHQ7XG4gICAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gICAgbG9kYXNoLmZvck93blJpZ2h0ID0gZm9yT3duUmlnaHQ7XG4gICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICBsb2Rhc2guZ3QgPSBndDtcbiAgICBsb2Rhc2guZ3RlID0gZ3RlO1xuICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgbG9kYXNoLmhhc0luID0gaGFzSW47XG4gICAgbG9kYXNoLmhlYWQgPSBoZWFkO1xuICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgIGxvZGFzaC5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuICAgIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgbG9kYXNoLmludm9rZSA9IGludm9rZTtcbiAgICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgbG9kYXNoLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuICAgIGxvZGFzaC5pc0FycmF5TGlrZU9iamVjdCA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuICAgIGxvZGFzaC5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG4gICAgbG9kYXNoLmlzQnVmZmVyID0gaXNCdWZmZXI7XG4gICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICAgIGxvZGFzaC5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgbG9kYXNoLmlzRXF1YWxXaXRoID0gaXNFcXVhbFdpdGg7XG4gICAgbG9kYXNoLmlzRXJyb3IgPSBpc0Vycm9yO1xuICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlO1xuICAgIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc0xlbmd0aCA9IGlzTGVuZ3RoO1xuICAgIGxvZGFzaC5pc01hcCA9IGlzTWFwO1xuICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICBsb2Rhc2guaXNNYXRjaFdpdGggPSBpc01hdGNoV2l0aDtcbiAgICBsb2Rhc2guaXNOYU4gPSBpc05hTjtcbiAgICBsb2Rhc2guaXNOYXRpdmUgPSBpc05hdGl2ZTtcbiAgICBsb2Rhc2guaXNOaWwgPSBpc05pbDtcbiAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICAgIGxvZGFzaC5pc09iamVjdCA9IGlzT2JqZWN0O1xuICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XG4gICAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICAgIGxvZGFzaC5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcbiAgICBsb2Rhc2guaXNTZXQgPSBpc1NldDtcbiAgICBsb2Rhc2guaXNTdHJpbmcgPSBpc1N0cmluZztcbiAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICBsb2Rhc2guaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuICAgIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG4gICAgbG9kYXNoLmlzV2Vha1NldCA9IGlzV2Vha1NldDtcbiAgICBsb2Rhc2guam9pbiA9IGpvaW47XG4gICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICBsb2Rhc2gubGFzdCA9IGxhc3Q7XG4gICAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcbiAgICBsb2Rhc2gubG93ZXJGaXJzdCA9IGxvd2VyRmlyc3Q7XG4gICAgbG9kYXNoLmx0ID0gbHQ7XG4gICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICBsb2Rhc2gubWF4ID0gbWF4O1xuICAgIGxvZGFzaC5tYXhCeSA9IG1heEJ5O1xuICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcbiAgICBsb2Rhc2gubWVhbkJ5ID0gbWVhbkJ5O1xuICAgIGxvZGFzaC5taW4gPSBtaW47XG4gICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XG4gICAgbG9kYXNoLnN0dWJBcnJheSA9IHN0dWJBcnJheTtcbiAgICBsb2Rhc2guc3R1YkZhbHNlID0gc3R1YkZhbHNlO1xuICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcbiAgICBsb2Rhc2guc3R1YlN0cmluZyA9IHN0dWJTdHJpbmc7XG4gICAgbG9kYXNoLnN0dWJUcnVlID0gc3R1YlRydWU7XG4gICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgbG9kYXNoLm50aCA9IG50aDtcbiAgICBsb2Rhc2gubm9Db25mbGljdCA9IG5vQ29uZmxpY3Q7XG4gICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgIGxvZGFzaC5ub3cgPSBub3c7XG4gICAgbG9kYXNoLnBhZCA9IHBhZDtcbiAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xuICAgIGxvZGFzaC5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuICAgIGxvZGFzaC5wYXJzZUludCA9IHBhcnNlSW50O1xuICAgIGxvZGFzaC5yYW5kb20gPSByYW5kb207XG4gICAgbG9kYXNoLnJlZHVjZSA9IHJlZHVjZTtcbiAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICBsb2Rhc2gucmVwZWF0ID0gcmVwZWF0O1xuICAgIGxvZGFzaC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgIGxvZGFzaC5yb3VuZCA9IHJvdW5kO1xuICAgIGxvZGFzaC5ydW5JbkNvbnRleHQgPSBydW5JbkNvbnRleHQ7XG4gICAgbG9kYXNoLnNhbXBsZSA9IHNhbXBsZTtcbiAgICBsb2Rhc2guc2l6ZSA9IHNpemU7XG4gICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4ID0gc29ydGVkSW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRJbmRleE9mID0gc29ydGVkSW5kZXhPZjtcbiAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4ID0gc29ydGVkTGFzdEluZGV4O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhPZiA9IHNvcnRlZExhc3RJbmRleE9mO1xuICAgIGxvZGFzaC5zdGFydENhc2UgPSBzdGFydENhc2U7XG4gICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgIGxvZGFzaC5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICAgIGxvZGFzaC5zdW0gPSBzdW07XG4gICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XG4gICAgbG9kYXNoLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgbG9kYXNoLnRpbWVzID0gdGltZXM7XG4gICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XG4gICAgbG9kYXNoLnRvSW50ZWdlciA9IHRvSW50ZWdlcjtcbiAgICBsb2Rhc2gudG9MZW5ndGggPSB0b0xlbmd0aDtcbiAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XG4gICAgbG9kYXNoLnRvTnVtYmVyID0gdG9OdW1iZXI7XG4gICAgbG9kYXNoLnRvU2FmZUludGVnZXIgPSB0b1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIGxvZGFzaC50b1VwcGVyID0gdG9VcHBlcjtcbiAgICBsb2Rhc2gudHJpbSA9IHRyaW07XG4gICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xuICAgIGxvZGFzaC50cmltU3RhcnQgPSB0cmltU3RhcnQ7XG4gICAgbG9kYXNoLnRydW5jYXRlID0gdHJ1bmNhdGU7XG4gICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgbG9kYXNoLnVuaXF1ZUlkID0gdW5pcXVlSWQ7XG4gICAgbG9kYXNoLnVwcGVyQ2FzZSA9IHVwcGVyQ2FzZTtcbiAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XG5cbiAgICAvLyBBZGQgYWxpYXNlcy5cbiAgICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZmlyc3QgPSBoZWFkO1xuXG4gICAgbWl4aW4obG9kYXNoLCAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc291cmNlID0ge307XG4gICAgICBiYXNlRm9yT3duKGxvZGFzaCwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobG9kYXNoLnByb3RvdHlwZSwgbWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgfSgpKSwgeyAnY2hhaW4nOiBmYWxzZSB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIFRoZSBzZW1hbnRpYyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgbG9kYXNoLlZFUlNJT04gPSBWRVJTSU9OO1xuXG4gICAgLy8gQXNzaWduIGRlZmF1bHQgcGxhY2Vob2xkZXJzLlxuICAgIGFycmF5RWFjaChbJ2JpbmQnLCAnYmluZEtleScsICdjdXJyeScsICdjdXJyeVJpZ2h0JywgJ3BhcnRpYWwnLCAncGFydGlhbFJpZ2h0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIGxvZGFzaFttZXRob2ROYW1lXS5wbGFjZWhvbGRlciA9IGxvZGFzaDtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmRyb3BgIGFuZCBgXy50YWtlYCB2YXJpYW50cy5cbiAgICBhcnJheUVhY2goWydkcm9wJywgJ3Rha2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgbiA9IG4gPT09IHVuZGVmaW5lZCA/IDEgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKG4pLCAwKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gKHRoaXMuX19maWx0ZXJlZF9fICYmICFpbmRleClcbiAgICAgICAgICA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKVxuICAgICAgICAgIDogdGhpcy5jbG9uZSgpO1xuXG4gICAgICAgIGlmIChyZXN1bHQuX19maWx0ZXJlZF9fKSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4obiwgcmVzdWx0Ll9fdGFrZUNvdW50X18pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5fX3ZpZXdzX18ucHVzaCh7XG4gICAgICAgICAgICAnc2l6ZSc6IG5hdGl2ZU1pbihuLCBNQVhfQVJSQVlfTEVOR1RIKSxcbiAgICAgICAgICAgICd0eXBlJzogbWV0aG9kTmFtZSArIChyZXN1bHQuX19kaXJfXyA8IDAgPyAnUmlnaHQnIDogJycpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lICsgJ1JpZ2h0J10gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKVttZXRob2ROYW1lXShuKS5yZXZlcnNlKCk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0aGF0IGFjY2VwdCBhbiBgaXRlcmF0ZWVgIHZhbHVlLlxuICAgIGFycmF5RWFjaChbJ2ZpbHRlcicsICdtYXAnLCAndGFrZVdoaWxlJ10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdHlwZSA9IGluZGV4ICsgMSxcbiAgICAgICAgICBpc0ZpbHRlciA9IHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRyB8fCB0eXBlID09IExBWllfV0hJTEVfRkxBRztcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9faXRlcmF0ZWVzX18ucHVzaCh7XG4gICAgICAgICAgJ2l0ZXJhdGVlJzogZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpLFxuICAgICAgICAgICd0eXBlJzogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0Ll9fZmlsdGVyZWRfXyA9IHJlc3VsdC5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaGVhZGAgYW5kIGBfLmxhc3RgLlxuICAgIGFycmF5RWFjaChbJ2hlYWQnLCAnbGFzdCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIHRha2VOYW1lID0gJ3Rha2UnICsgKGluZGV4ID8gJ1JpZ2h0JyA6ICcnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Rha2VOYW1lXSgxKS52YWx1ZSgpWzBdO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgZm9yIGBfLmluaXRpYWxgIGFuZCBgXy50YWlsYC5cbiAgICBhcnJheUVhY2goWydpbml0aWFsJywgJ3RhaWwnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciBkcm9wTmFtZSA9ICdkcm9wJyArIChpbmRleCA/ICcnIDogJ1JpZ2h0Jyk7XG5cbiAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29tcGFjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGlkZW50aXR5KTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihwcmVkaWNhdGUpLmhlYWQoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkuZmluZChwcmVkaWNhdGUpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24ocGF0aCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlKSkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG5cbiAgICAgIHZhciByZXN1bHQgPSB0aGlzO1xuICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18gJiYgKHN0YXJ0ID4gMCB8fCBlbmQgPCAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC50YWtlUmlnaHQoLXN0YXJ0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmRyb3Aoc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHRvSW50ZWdlcihlbmQpO1xuICAgICAgICByZXN1bHQgPSBlbmQgPCAwID8gcmVzdWx0LmRyb3BSaWdodCgtZW5kKSA6IHJlc3VsdC50YWtlKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS50YWtlUmlnaHRXaGlsZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRha2UoTUFYX0FSUkFZX0xFTkdUSCk7XG4gICAgfTtcblxuICAgIC8vIEFkZCBgTGF6eVdyYXBwZXJgIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY2hlY2tJdGVyYXRlZSA9IC9eKD86ZmlsdGVyfGZpbmR8bWFwfHJlamVjdCl8V2hpbGUkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLFxuICAgICAgICAgIGxvZGFzaEZ1bmMgPSBsb2Rhc2hbaXNUYWtlciA/ICgndGFrZScgKyAobWV0aG9kTmFtZSA9PSAnbGFzdCcgPyAnUmlnaHQnIDogJycpKSA6IG1ldGhvZE5hbWVdLFxuICAgICAgICAgIHJldFVud3JhcHBlZCA9IGlzVGFrZXIgfHwgL15maW5kLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBpZiAoIWxvZGFzaEZ1bmMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgICAgYXJncyA9IGlzVGFrZXIgPyBbMV0gOiBhcmd1bWVudHMsXG4gICAgICAgICAgICBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLFxuICAgICAgICAgICAgaXRlcmF0ZWUgPSBhcmdzWzBdLFxuICAgICAgICAgICAgdXNlTGF6eSA9IGlzTGF6eSB8fCBpc0FycmF5KHZhbHVlKTtcblxuICAgICAgICB2YXIgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBsb2Rhc2hGdW5jLmFwcGx5KGxvZGFzaCwgYXJyYXlQdXNoKFt2YWx1ZV0sIGFyZ3MpKTtcbiAgICAgICAgICByZXR1cm4gKGlzVGFrZXIgJiYgY2hhaW5BbGwpID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlID09ICdmdW5jdGlvbicgJiYgaXRlcmF0ZWUubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAvLyBBdm9pZCBsYXp5IHVzZSBpZiB0aGUgaXRlcmF0ZWUgaGFzIGEgXCJsZW5ndGhcIiB2YWx1ZSBvdGhlciB0aGFuIGAxYC5cbiAgICAgICAgICBpc0xhenkgPSB1c2VMYXp5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYWluQWxsID0gdGhpcy5fX2NoYWluX18sXG4gICAgICAgICAgICBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsXG4gICAgICAgICAgICBpc1Vud3JhcHBlZCA9IHJldFVud3JhcHBlZCAmJiAhY2hhaW5BbGwsXG4gICAgICAgICAgICBvbmx5TGF6eSA9IGlzTGF6eSAmJiAhaXNIeWJyaWQ7XG5cbiAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgIHZhbHVlID0gb25seUxhenkgPyB2YWx1ZSA6IG5ldyBMYXp5V3JhcHBlcih0aGlzKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fLnB1c2goeyAnZnVuYyc6IHRocnUsICdhcmdzJzogW2ludGVyY2VwdG9yXSwgJ3RoaXNBcmcnOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHJlc3VsdCwgY2hhaW5BbGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Vud3JhcHBlZCAmJiBvbmx5TGF6eSkge1xuICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHRoaXMudGhydShpbnRlcmNlcHRvcik7XG4gICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IChpc1Rha2VyID8gcmVzdWx0LnZhbHVlKClbMF0gOiByZXN1bHQudmFsdWUoKSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBBcnJheWAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYXJyYXlFYWNoKFsncG9wJywgJ3B1c2gnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sXG4gICAgICAgICAgY2hhaW5OYW1lID0gL14oPzpwdXNofHNvcnR8dW5zaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpID8gJ3RhcCcgOiAndGhydScsXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gL14oPzpwb3B8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcblxuICAgICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgaWYgKHJldFVud3JhcHBlZCAmJiAhdGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tjaGFpbk5hbWVdKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gTWFwIG1pbmlmaWVkIG1ldGhvZCBuYW1lcyB0byB0aGVpciByZWFsIG5hbWVzLlxuICAgIGJhc2VGb3JPd24oTGF6eVdyYXBwZXIucHJvdG90eXBlLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgbG9kYXNoRnVuYyA9IGxvZGFzaFttZXRob2ROYW1lXTtcbiAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgIHZhciBrZXkgPSAobG9kYXNoRnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgICAgbmFtZXMgPSByZWFsTmFtZXNba2V5XSB8fCAocmVhbE5hbWVzW2tleV0gPSBbXSk7XG5cbiAgICAgICAgbmFtZXMucHVzaCh7ICduYW1lJzogbWV0aG9kTmFtZSwgJ2Z1bmMnOiBsb2Rhc2hGdW5jIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQsIFdSQVBfQklORF9LRVlfRkxBRykubmFtZV0gPSBbe1xuICAgICAgJ25hbWUnOiAnd3JhcHBlcicsXG4gICAgICAnZnVuYyc6IHVuZGVmaW5lZFxuICAgIH1dO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYExhenlXcmFwcGVyYC5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY2xvbmUgPSBsYXp5Q2xvbmU7XG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2UgPSBsYXp5UmV2ZXJzZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudmFsdWUgPSBsYXp5VmFsdWU7XG5cbiAgICAvLyBBZGQgY2hhaW4gc2VxdWVuY2UgbWV0aG9kcyB0byB0aGUgYGxvZGFzaGAgd3JhcHBlci5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmF0ID0gd3JhcHBlckF0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUuY2hhaW4gPSB3cmFwcGVyQ2hhaW47XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb21taXQgPSB3cmFwcGVyQ29tbWl0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUubmV4dCA9IHdyYXBwZXJOZXh0O1xuICAgIGxvZGFzaC5wcm90b3R5cGUucGxhbnQgPSB3cmFwcGVyUGxhbnQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5yZXZlcnNlID0gd3JhcHBlclJldmVyc2U7XG4gICAgbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuXG4gICAgLy8gQWRkIGxhenkgYWxpYXNlcy5cbiAgICBsb2Rhc2gucHJvdG90eXBlLmZpcnN0ID0gbG9kYXNoLnByb3RvdHlwZS5oZWFkO1xuXG4gICAgaWYgKHN5bUl0ZXJhdG9yKSB7XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXSA9IHdyYXBwZXJUb0l0ZXJhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gbG9kYXNoO1xuICB9KTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBFeHBvcnQgbG9kYXNoLlxuICB2YXIgXyA9IHJ1bkluQ29udGV4dCgpO1xuXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG9kYXNoIG9uIHRoZSBnbG9iYWwgb2JqZWN0IHRvIHByZXZlbnQgZXJyb3JzIHdoZW4gTG9kYXNoIGlzXG4gICAgLy8gbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EIGxvYWRlci5cbiAgICAvLyBTZWUgaHR0cDovL3JlcXVpcmVqcy5vcmcvZG9jcy9lcnJvcnMuaHRtbCNtaXNtYXRjaCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIC8vIFVzZSBgXy5ub0NvbmZsaWN0YCB0byByZW1vdmUgTG9kYXNoIGZyb20gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcblxuICAgIC8vIERlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlIHNvLCB0aHJvdWdoIHBhdGggbWFwcGluZywgaXQgY2FuIGJlXG4gICAgLy8gcmVmZXJlbmNlZCBhcyB0aGUgXCJ1bmRlcnNjb3JlXCIgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG4gIC8vIENoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGl0LlxuICBlbHNlIGlmIChmcmVlTW9kdWxlKSB7XG4gICAgLy8gRXhwb3J0IGZvciBOb2RlLmpzLlxuICAgIChmcmVlTW9kdWxlLmV4cG9ydHMgPSBfKS5fID0gXztcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIHN1cHBvcnQuXG4gICAgZnJlZUV4cG9ydHMuXyA9IF87XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gRXhwb3J0IHRvIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIHJvb3QuXyA9IF87XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VNYXAgPSByZXF1aXJlKCcuL19iYXNlTWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLmV2ZXJ5YCwgYF8uZmlsdGVyYCwgYF8ubWFwYCwgYF8ubWFwVmFsdWVzYCwgYF8ucmVqZWN0YCwgYW5kIGBfLnNvbWVgLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFyeWAsIGBjaHVua2AsIGBjdXJyeWAsIGBjdXJyeVJpZ2h0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGV2ZXJ5YCxcbiAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICogYHNhbXBsZVNpemVgLCBgc2xpY2VgLCBgc29tZWAsIGBzb3J0QnlgLCBgc3BsaXRgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLFxuICogYHRlbXBsYXRlYCwgYHRyaW1gLCBgdHJpbUVuZGAsIGB0cmltU3RhcnRgLCBhbmQgYHdvcmRzYFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAqICAgcmV0dXJuIG4gKiBuO1xuICogfVxuICpcbiAqIF8ubWFwKFs0LCA4XSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdXG4gKlxuICogXy5tYXAoeyAnYSc6IDQsICdiJzogOCB9LCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1hcCh1c2VycywgJ3VzZXInKTtcbiAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICovXG5mdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXA7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8ubm9vcCk7XG4gKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7XG4gIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gbm9vcDtcbiIsInZhciBiYXNlUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHknKSxcbiAgICBiYXNlUHJvcGVydHlEZWVwID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5RGVlcCcpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9wZXJ0eTtcbiIsInZhciBhcnJheVJlZHVjZSA9IHJlcXVpcmUoJy4vX2FycmF5UmVkdWNlJyksXG4gICAgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VSZWR1Y2UgPSByZXF1aXJlKCcuL19iYXNlUmVkdWNlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFJlZHVjZXMgYGNvbGxlY3Rpb25gIHRvIGEgdmFsdWUgd2hpY2ggaXMgdGhlIGFjY3VtdWxhdGVkIHJlc3VsdCBvZiBydW5uaW5nXG4gKiBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYCwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gKiBpcyBub3QgZ2l2ZW4sIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCBpcyB1c2VkIGFzIHRoZSBpbml0aWFsXG4gKiB2YWx1ZS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBmb3VyIGFyZ3VtZW50czpcbiAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICpcbiAqIFRoZSBndWFyZGVkIG1ldGhvZHMgYXJlOlxuICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gKiBhbmQgYHNvcnRCeWBcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIF8ucmVkdWNlUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogXy5yZWR1Y2UoWzEsIDJdLCBmdW5jdGlvbihzdW0sIG4pIHtcbiAqICAgcmV0dXJuIHN1bSArIG47XG4gKiB9LCAwKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnJlZHVjZSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gKiAgIHJldHVybiByZXN1bHQ7XG4gKiB9LCB7fSk7XG4gKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2UgOiBiYXNlUmVkdWNlLFxuICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZHVjZTtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNTdHJpbmcgPSByZXF1aXJlKCcuL2lzU3RyaW5nJyksXG4gICAgc3RyaW5nU2l6ZSA9IHJlcXVpcmUoJy4vX3N0cmluZ1NpemUnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpemUgb2YgYGNvbGxlY3Rpb25gIGJ5IHJldHVybmluZyBpdHMgbGVuZ3RoIGZvciBhcnJheS1saWtlXG4gKiB2YWx1ZXMgb3IgdGhlIG51bWJlciBvZiBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICogLy8gPT4gMlxuICpcbiAqIF8uc2l6ZSgncGViYmxlcycpO1xuICogLy8gPT4gN1xuICovXG5mdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgIHJldHVybiBpc1N0cmluZyhjb2xsZWN0aW9uKSA/IHN0cmluZ1NpemUoY29sbGVjdGlvbikgOiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgfVxuICByZXR1cm4gYmFzZUtleXMoY29sbGVjdGlvbikubGVuZ3RoO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNpemU7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViRmFsc2U7XG4iLCJ2YXIgYmFzZVRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVRvU3RyaW5nJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcbiIsInZhciBhcnJheUVhY2ggPSByZXF1aXJlKCcuL19hcnJheUVhY2gnKSxcbiAgICBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKipcbiAqIEFuIGFsdGVybmF0aXZlIHRvIGBfLnJlZHVjZWA7IHRoaXMgbWV0aG9kIHRyYW5zZm9ybXMgYG9iamVjdGAgdG8gYSBuZXdcbiAqIGBhY2N1bXVsYXRvcmAgb2JqZWN0IHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgcnVubmluZyBlYWNoIG9mIGl0cyBvd25cbiAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICogcG90ZW50aWFsbHkgbXV0YXRpbmcgdGhlIGBhY2N1bXVsYXRvcmAgb2JqZWN0LiBJZiBgYWNjdW11bGF0b3JgIGlzIG5vdFxuICogcHJvdmlkZWQsIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGBbW1Byb3RvdHlwZV1dYCB3aWxsIGJlIHVzZWQuIFRoZVxuICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjMuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udHJhbnNmb3JtKFsyLCAzLCA0XSwgZnVuY3Rpb24ocmVzdWx0LCBuKSB7XG4gKiAgIHJlc3VsdC5wdXNoKG4gKj0gbik7XG4gKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICogfSwgW10pO1xuICogLy8gPT4gWzQsIDldXG4gKlxuICogXy50cmFuc2Zvcm0oeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICogICAocmVzdWx0W3ZhbHVlXSB8fCAocmVzdWx0W3ZhbHVlXSA9IFtdKSkucHVzaChrZXkpO1xuICogfSwge30pO1xuICogLy8gPT4geyAnMSc6IFsnYScsICdjJ10sICcyJzogWydiJ10gfVxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgaXNBcnJMaWtlID0gaXNBcnIgfHwgaXNCdWZmZXIob2JqZWN0KSB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KTtcblxuICBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgNCk7XG4gIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgdmFyIEN0b3IgPSBvYmplY3QgJiYgb2JqZWN0LmNvbnN0cnVjdG9yO1xuICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdChvYmplY3QpKSB7XG4gICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgfVxuICB9XG4gIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtO1xuIiwidmFyIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgYmFzZVVuaXEgPSByZXF1aXJlKCcuL19iYXNlVW5pcScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqL1xudmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmlvbjtcbiIsInZhciBiYXNlVmFsdWVzID0gcmVxdWlyZSgnLi9fYmFzZVZhbHVlcycpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmFsdWVzO1xuIiwiLyohIE5hdGl2ZSBQcm9taXNlIE9ubHlcbiAgICB2MC44LjEgKGMpIEt5bGUgU2ltcHNvblxuICAgIE1JVCBMaWNlbnNlOiBodHRwOi8vZ2V0aWZ5Lm1pdC1saWNlbnNlLm9yZ1xuKi9cblxuKGZ1bmN0aW9uIFVNRChuYW1lLGNvbnRleHQsZGVmaW5pdGlvbil7XG5cdC8vIHNwZWNpYWwgZm9ybSBvZiBVTUQgZm9yIHBvbHlmaWxsaW5nIGFjcm9zcyBldmlyb25tZW50c1xuXHRjb250ZXh0W25hbWVdID0gY29udGV4dFtuYW1lXSB8fCBkZWZpbml0aW9uKCk7XG5cdGlmICh0eXBlb2YgbW9kdWxlICE9IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHsgbW9kdWxlLmV4cG9ydHMgPSBjb250ZXh0W25hbWVdOyB9XG5cdGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHsgZGVmaW5lKGZ1bmN0aW9uICRBTUQkKCl7IHJldHVybiBjb250ZXh0W25hbWVdOyB9KTsgfVxufSkoXCJQcm9taXNlXCIsdHlwZW9mIGdsb2JhbCAhPSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdGhpcyxmdW5jdGlvbiBERUYoKXtcblx0Lypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0dmFyIGJ1aWx0SW5Qcm9wLCBjeWNsZSwgc2NoZWR1bGluZ19xdWV1ZSxcblx0XHRUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG5cdFx0dGltZXIgPSAodHlwZW9mIHNldEltbWVkaWF0ZSAhPSBcInVuZGVmaW5lZFwiKSA/XG5cdFx0XHRmdW5jdGlvbiB0aW1lcihmbikgeyByZXR1cm4gc2V0SW1tZWRpYXRlKGZuKTsgfSA6XG5cdFx0XHRzZXRUaW1lb3V0XG5cdDtcblxuXHQvLyBkYW1taXQsIElFOC5cblx0dHJ5IHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJ4XCIse30pO1xuXHRcdGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsLGNvbmZpZykge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosbmFtZSx7XG5cdFx0XHRcdHZhbHVlOiB2YWwsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IGNvbmZpZyAhPT0gZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cblx0Y2F0Y2ggKGVycikge1xuXHRcdGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLG5hbWUsdmFsKSB7XG5cdFx0XHRvYmpbbmFtZV0gPSB2YWw7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH07XG5cdH1cblxuXHQvLyBOb3RlOiB1c2luZyBhIHF1ZXVlIGluc3RlYWQgb2YgYXJyYXkgZm9yIGVmZmljaWVuY3lcblx0c2NoZWR1bGluZ19xdWV1ZSA9IChmdW5jdGlvbiBRdWV1ZSgpIHtcblx0XHR2YXIgZmlyc3QsIGxhc3QsIGl0ZW07XG5cblx0XHRmdW5jdGlvbiBJdGVtKGZuLHNlbGYpIHtcblx0XHRcdHRoaXMuZm4gPSBmbjtcblx0XHRcdHRoaXMuc2VsZiA9IHNlbGY7XG5cdFx0XHR0aGlzLm5leHQgPSB2b2lkIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFkZDogZnVuY3Rpb24gYWRkKGZuLHNlbGYpIHtcblx0XHRcdFx0aXRlbSA9IG5ldyBJdGVtKGZuLHNlbGYpO1xuXHRcdFx0XHRpZiAobGFzdCkge1xuXHRcdFx0XHRcdGxhc3QubmV4dCA9IGl0ZW07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Zmlyc3QgPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3QgPSBpdGVtO1xuXHRcdFx0XHRpdGVtID0gdm9pZCAwO1xuXHRcdFx0fSxcblx0XHRcdGRyYWluOiBmdW5jdGlvbiBkcmFpbigpIHtcblx0XHRcdFx0dmFyIGYgPSBmaXJzdDtcblx0XHRcdFx0Zmlyc3QgPSBsYXN0ID0gY3ljbGUgPSB2b2lkIDA7XG5cblx0XHRcdFx0d2hpbGUgKGYpIHtcblx0XHRcdFx0XHRmLmZuLmNhbGwoZi5zZWxmKTtcblx0XHRcdFx0XHRmID0gZi5uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSkoKTtcblxuXHRmdW5jdGlvbiBzY2hlZHVsZShmbixzZWxmKSB7XG5cdFx0c2NoZWR1bGluZ19xdWV1ZS5hZGQoZm4sc2VsZik7XG5cdFx0aWYgKCFjeWNsZSkge1xuXHRcdFx0Y3ljbGUgPSB0aW1lcihzY2hlZHVsaW5nX3F1ZXVlLmRyYWluKTtcblx0XHR9XG5cdH1cblxuXHQvLyBwcm9taXNlIGR1Y2sgdHlwaW5nXG5cdGZ1bmN0aW9uIGlzVGhlbmFibGUobykge1xuXHRcdHZhciBfdGhlbiwgb190eXBlID0gdHlwZW9mIG87XG5cblx0XHRpZiAobyAhPSBudWxsICYmXG5cdFx0XHQoXG5cdFx0XHRcdG9fdHlwZSA9PSBcIm9iamVjdFwiIHx8IG9fdHlwZSA9PSBcImZ1bmN0aW9uXCJcblx0XHRcdClcblx0XHQpIHtcblx0XHRcdF90aGVuID0gby50aGVuO1xuXHRcdH1cblx0XHRyZXR1cm4gdHlwZW9mIF90aGVuID09IFwiZnVuY3Rpb25cIiA/IF90aGVuIDogZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBub3RpZnkoKSB7XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHRoaXMuY2hhaW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdG5vdGlmeUlzb2xhdGVkKFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHQodGhpcy5zdGF0ZSA9PT0gMSkgPyB0aGlzLmNoYWluW2ldLnN1Y2Nlc3MgOiB0aGlzLmNoYWluW2ldLmZhaWx1cmUsXG5cdFx0XHRcdHRoaXMuY2hhaW5baV1cblx0XHRcdCk7XG5cdFx0fVxuXHRcdHRoaXMuY2hhaW4ubGVuZ3RoID0gMDtcblx0fVxuXG5cdC8vIE5PVEU6IFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiB0byBpc29sYXRlXG5cdC8vIHRoZSBgdHJ5Li5jYXRjaGAgc28gdGhhdCBvdGhlciBjb2RlIGNhbiBiZVxuXHQvLyBvcHRpbWl6ZWQgYmV0dGVyXG5cdGZ1bmN0aW9uIG5vdGlmeUlzb2xhdGVkKHNlbGYsY2IsY2hhaW4pIHtcblx0XHR2YXIgcmV0LCBfdGhlbjtcblx0XHR0cnkge1xuXHRcdFx0aWYgKGNiID09PSBmYWxzZSkge1xuXHRcdFx0XHRjaGFpbi5yZWplY3Qoc2VsZi5tc2cpO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGlmIChjYiA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHJldCA9IHNlbGYubXNnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHJldCA9IGNiLmNhbGwodm9pZCAwLHNlbGYubXNnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChyZXQgPT09IGNoYWluLnByb21pc2UpIHtcblx0XHRcdFx0XHRjaGFpbi5yZWplY3QoVHlwZUVycm9yKFwiUHJvbWlzZS1jaGFpbiBjeWNsZVwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKHJldCkpIHtcblx0XHRcdFx0XHRfdGhlbi5jYWxsKHJldCxjaGFpbi5yZXNvbHZlLGNoYWluLnJlamVjdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y2hhaW4ucmVzb2x2ZShyZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdGNoYWluLnJlamVjdChlcnIpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc29sdmUobXNnKSB7XG5cdFx0dmFyIF90aGVuLCBzZWxmID0gdGhpcztcblxuXHRcdC8vIGFscmVhZHkgdHJpZ2dlcmVkP1xuXHRcdGlmIChzZWxmLnRyaWdnZXJlZCkgeyByZXR1cm47IH1cblxuXHRcdHNlbGYudHJpZ2dlcmVkID0gdHJ1ZTtcblxuXHRcdC8vIHVud3JhcFxuXHRcdGlmIChzZWxmLmRlZikge1xuXHRcdFx0c2VsZiA9IHNlbGYuZGVmO1xuXHRcdH1cblxuXHRcdHRyeSB7XG5cdFx0XHRpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKG1zZykpIHtcblx0XHRcdFx0c2NoZWR1bGUoZnVuY3Rpb24oKXtcblx0XHRcdFx0XHR2YXIgZGVmX3dyYXBwZXIgPSBuZXcgTWFrZURlZldyYXBwZXIoc2VsZik7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdF90aGVuLmNhbGwobXNnLFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAkcmVzb2x2ZSQoKXsgcmVzb2x2ZS5hcHBseShkZWZfd3JhcHBlcixhcmd1bWVudHMpOyB9LFxuXHRcdFx0XHRcdFx0XHRmdW5jdGlvbiAkcmVqZWN0JCgpeyByZWplY3QuYXBwbHkoZGVmX3dyYXBwZXIsYXJndW1lbnRzKTsgfVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0cmVqZWN0LmNhbGwoZGVmX3dyYXBwZXIsZXJyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2VsZi5tc2cgPSBtc2c7XG5cdFx0XHRcdHNlbGYuc3RhdGUgPSAxO1xuXHRcdFx0XHRpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0c2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdHJlamVjdC5jYWxsKG5ldyBNYWtlRGVmV3JhcHBlcihzZWxmKSxlcnIpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlamVjdChtc2cpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHQvLyBhbHJlYWR5IHRyaWdnZXJlZD9cblx0XHRpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cblx0XHRzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cblx0XHQvLyB1bndyYXBcblx0XHRpZiAoc2VsZi5kZWYpIHtcblx0XHRcdHNlbGYgPSBzZWxmLmRlZjtcblx0XHR9XG5cblx0XHRzZWxmLm1zZyA9IG1zZztcblx0XHRzZWxmLnN0YXRlID0gMjtcblx0XHRpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRzY2hlZHVsZShub3RpZnksc2VsZik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixyZXNvbHZlcixyZWplY3Rlcikge1xuXHRcdGZvciAodmFyIGlkeD0wOyBpZHg8YXJyLmxlbmd0aDsgaWR4KyspIHtcblx0XHRcdChmdW5jdGlvbiBJSUZFKGlkeCl7XG5cdFx0XHRcdENvbnN0cnVjdG9yLnJlc29sdmUoYXJyW2lkeF0pXG5cdFx0XHRcdC50aGVuKFxuXHRcdFx0XHRcdGZ1bmN0aW9uICRyZXNvbHZlciQobXNnKXtcblx0XHRcdFx0XHRcdHJlc29sdmVyKGlkeCxtc2cpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0cmVqZWN0ZXJcblx0XHRcdFx0KTtcblx0XHRcdH0pKGlkeCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gTWFrZURlZldyYXBwZXIoc2VsZikge1xuXHRcdHRoaXMuZGVmID0gc2VsZjtcblx0XHR0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWFrZURlZihzZWxmKSB7XG5cdFx0dGhpcy5wcm9taXNlID0gc2VsZjtcblx0XHR0aGlzLnN0YXRlID0gMDtcblx0XHR0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuXHRcdHRoaXMuY2hhaW4gPSBbXTtcblx0XHR0aGlzLm1zZyA9IHZvaWQgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcblx0XHRpZiAodHlwZW9mIGV4ZWN1dG9yICE9IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX19OUE9fXyAhPT0gMCkge1xuXHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgcHJvbWlzZVwiKTtcblx0XHR9XG5cblx0XHQvLyBpbnN0YW5jZSBzaGFkb3dpbmcgdGhlIGluaGVyaXRlZCBcImJyYW5kXCJcblx0XHQvLyB0byBzaWduYWwgYW4gYWxyZWFkeSBcImluaXRpYWxpemVkXCIgcHJvbWlzZVxuXHRcdHRoaXMuX19OUE9fXyA9IDE7XG5cblx0XHR2YXIgZGVmID0gbmV3IE1ha2VEZWYodGhpcyk7XG5cblx0XHR0aGlzW1widGhlblwiXSA9IGZ1bmN0aW9uIHRoZW4oc3VjY2VzcyxmYWlsdXJlKSB7XG5cdFx0XHR2YXIgbyA9IHtcblx0XHRcdFx0c3VjY2VzczogdHlwZW9mIHN1Y2Nlc3MgPT0gXCJmdW5jdGlvblwiID8gc3VjY2VzcyA6IHRydWUsXG5cdFx0XHRcdGZhaWx1cmU6IHR5cGVvZiBmYWlsdXJlID09IFwiZnVuY3Rpb25cIiA/IGZhaWx1cmUgOiBmYWxzZVxuXHRcdFx0fTtcblx0XHRcdC8vIE5vdGU6IGB0aGVuKC4uKWAgaXRzZWxmIGNhbiBiZSBib3Jyb3dlZCB0byBiZSB1c2VkIGFnYWluc3Rcblx0XHRcdC8vIGEgZGlmZmVyZW50IHByb21pc2UgY29uc3RydWN0b3IgZm9yIG1ha2luZyB0aGUgY2hhaW5lZCBwcm9taXNlLFxuXHRcdFx0Ly8gYnkgc3Vic3RpdHV0aW5nIGEgZGlmZmVyZW50IGB0aGlzYCBiaW5kaW5nLlxuXHRcdFx0by5wcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24gZXh0cmFjdENoYWluKHJlc29sdmUscmVqZWN0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0XHR0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG8ucmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRcdG8ucmVqZWN0ID0gcmVqZWN0O1xuXHRcdFx0fSk7XG5cdFx0XHRkZWYuY2hhaW4ucHVzaChvKTtcblxuXHRcdFx0aWYgKGRlZi5zdGF0ZSAhPT0gMCkge1xuXHRcdFx0XHRzY2hlZHVsZShub3RpZnksZGVmKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG8ucHJvbWlzZTtcblx0XHR9O1xuXHRcdHRoaXNbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uICRjYXRjaCQoZmFpbHVyZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsZmFpbHVyZSk7XG5cdFx0fTtcblxuXHRcdHRyeSB7XG5cdFx0XHRleGVjdXRvci5jYWxsKFxuXHRcdFx0XHR2b2lkIDAsXG5cdFx0XHRcdGZ1bmN0aW9uIHB1YmxpY1Jlc29sdmUobXNnKXtcblx0XHRcdFx0XHRyZXNvbHZlLmNhbGwoZGVmLG1zZyk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIHB1YmxpY1JlamVjdChtc2cpIHtcblx0XHRcdFx0XHRyZWplY3QuY2FsbChkZWYsbXNnKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0cmVqZWN0LmNhbGwoZGVmLGVycik7XG5cdFx0fVxuXHR9XG5cblx0dmFyIFByb21pc2VQcm90b3R5cGUgPSBidWlsdEluUHJvcCh7fSxcImNvbnN0cnVjdG9yXCIsUHJvbWlzZSxcblx0XHQvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG5cdCk7XG5cblx0Ly8gTm90ZTogQW5kcm9pZCA0IGNhbm5vdCB1c2UgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSguLilgIGhlcmVcblx0UHJvbWlzZS5wcm90b3R5cGUgPSBQcm9taXNlUHJvdG90eXBlO1xuXG5cdC8vIGJ1aWx0LWluIFwiYnJhbmRcIiB0byBzaWduYWwgYW4gXCJ1bmluaXRpYWxpemVkXCIgcHJvbWlzZVxuXHRidWlsdEluUHJvcChQcm9taXNlUHJvdG90eXBlLFwiX19OUE9fX1wiLDAsXG5cdFx0Lypjb25maWd1cmFibGU9Ki9mYWxzZVxuXHQpO1xuXG5cdGJ1aWx0SW5Qcm9wKFByb21pc2UsXCJyZXNvbHZlXCIsZnVuY3Rpb24gUHJvbWlzZSRyZXNvbHZlKG1zZykge1xuXHRcdHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0XHQvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuXHRcdC8vIG5vdGU6IGJlc3QgXCJpc1Byb21pc2VcIiBjaGVjayB0aGF0J3MgcHJhY3RpY2FsIGZvciBub3dcblx0XHRpZiAobXNnICYmIHR5cGVvZiBtc2cgPT0gXCJvYmplY3RcIiAmJiBtc2cuX19OUE9fXyA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIG1zZztcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcblx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0XHR9XG5cblx0XHRcdHJlc29sdmUobXNnKTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcInJlamVjdFwiLGZ1bmN0aW9uIFByb21pc2UkcmVqZWN0KG1zZykge1xuXHRcdHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWplY3QobXNnKTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcImFsbFwiLGZ1bmN0aW9uIFByb21pc2UkYWxsKGFycikge1xuXHRcdHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cblx0XHQvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuXHRcdGlmIChUb1N0cmluZy5jYWxsKGFycikgIT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcihcIk5vdCBhbiBhcnJheVwiKSk7XG5cdFx0fVxuXHRcdGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gQ29uc3RydWN0b3IucmVzb2x2ZShbXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG5cdFx0XHRpZiAodHlwZW9mIHJlc29sdmUgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByZWplY3QgIT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aCwgbXNncyA9IEFycmF5KGxlbiksIGNvdW50ID0gMDtcblxuXHRcdFx0aXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKSB7XG5cdFx0XHRcdG1zZ3NbaWR4XSA9IG1zZztcblx0XHRcdFx0aWYgKCsrY291bnQgPT09IGxlbikge1xuXHRcdFx0XHRcdHJlc29sdmUobXNncyk7XG5cdFx0XHRcdH1cblx0XHRcdH0scmVqZWN0KTtcblx0XHR9KTtcblx0fSk7XG5cblx0YnVpbHRJblByb3AoUHJvbWlzZSxcInJhY2VcIixmdW5jdGlvbiBQcm9taXNlJHJhY2UoYXJyKSB7XG5cdFx0dmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuXHRcdC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG5cdFx0aWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPSBcIltvYmplY3QgQXJyYXldXCIpIHtcblx0XHRcdHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKFwiTm90IGFuIGFycmF5XCIpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcblx0XHRcdGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG5cdFx0XHR9XG5cblx0XHRcdGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZyl7XG5cdFx0XHRcdHJlc29sdmUobXNnKTtcblx0XHRcdH0scmVqZWN0KTtcblx0XHR9KTtcblx0fSk7XG5cblx0cmV0dXJuIFByb21pc2U7XG59KTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLypcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBKZXJlbXkgV2hpdGxvY2tcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN1cHBvcnRlZExvYWRlcnMgPSB7XG4gIGZpbGU6IHJlcXVpcmUoJy4vbGliL2xvYWRlcnMvZmlsZScpLFxuICBodHRwOiByZXF1aXJlKCcuL2xpYi9sb2FkZXJzL2h0dHAnKSxcbiAgaHR0cHM6IHJlcXVpcmUoJy4vbGliL2xvYWRlcnMvaHR0cCcpXG59O1xudmFyIGRlZmF1bHRMb2FkZXIgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICBzdXBwb3J0ZWRMb2FkZXJzLmh0dHAgOlxuICAgICAgc3VwcG9ydGVkTG9hZGVycy5maWxlO1xuXG4vLyBMb2FkIHByb21pc2VzIHBvbHlmaWxsIGlmIG5lY2Vzc2FyeVxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gIHJlcXVpcmUoJ25hdGl2ZS1wcm9taXNlLW9ubHknKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2NoZW1lIChsb2NhdGlvbikge1xuICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgIGxvY2F0aW9uID0gbG9jYXRpb24uaW5kZXhPZignOi8vJykgPT09IC0xID8gJycgOiBsb2NhdGlvbi5zcGxpdCgnOi8vJylbMF07XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb247XG59XG5cbi8qKlxuICogVXRpbGl0eSB0aGF0IHByb3ZpZGVzIGEgc2luZ2xlIEFQSSBmb3IgbG9hZGluZyB0aGUgY29udGVudCBvZiBhIHBhdGgvVVJMLlxuICpcbiAqIEBtb2R1bGUgcGF0aC1sb2FkZXJcbiAqL1xuXG5mdW5jdGlvbiBnZXRMb2FkZXIgKGxvY2F0aW9uKSB7XG4gIHZhciBzY2hlbWUgPSBnZXRTY2hlbWUobG9jYXRpb24pO1xuICB2YXIgbG9hZGVyID0gc3VwcG9ydGVkTG9hZGVyc1tzY2hlbWVdO1xuXG4gIGlmICh0eXBlb2YgbG9hZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChzY2hlbWUgPT09ICcnKSB7XG4gICAgICBsb2FkZXIgPSBkZWZhdWx0TG9hZGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNjaGVtZTogJyArIHNjaGVtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxvYWRlcjtcbn1cblxuLyoqXG4gKiBMb2FkcyBhIGRvY3VtZW50IGF0IHRoZSBwcm92aWRlZCBsb2NhdGlvbiBhbmQgcmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byB0aGUgZG9jdW1lbnRcbiAqIEBwYXJhbSB7bW9kdWxlOnBhdGgtbG9hZGVyfkxvYWRPcHRpb25zfSBbb3B0aW9uc10gLSBUaGUgbG9hZGVyIG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gQWx3YXlzIHJldHVybnMgYSBwcm9taXNlIGV2ZW4gaWYgdGhlcmUgaXMgYSBjYWxsYmFjayBwcm92aWRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBFeGFtcGxlIHVzaW5nIFByb21pc2VzXG4gKlxuICogUGF0aExvYWRlclxuICogICAubG9hZCgnLi9wYWNrYWdlLmpzb24nKVxuICogICAudGhlbihKU09OLnBhcnNlKVxuICogICAudGhlbihmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAqICAgICBjb25zb2xlLmxvZyhkb2N1bWVudC5uYW1lICsgJyAoJyArIGRvY3VtZW50LnZlcnNpb24gKyAnKTogJyArIGRvY3VtZW50LmRlc2NyaXB0aW9uKTtcbiAqICAgfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKTtcbiAqICAgfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEV4YW1wbGUgdXNpbmcgb3B0aW9ucy5wcmVwYXJlUmVxdWVzdCB0byBwcm92aWRlIGF1dGhlbnRpY2F0aW9uIGRldGFpbHMgZm9yIGEgcmVtb3RlbHkgc2VjdXJlIFVSTFxuICpcbiAqIFBhdGhMb2FkZXJcbiAqICAgLmxvYWQoJ2h0dHBzOi8vYXBpLmdpdGh1Yi5jb20vcmVwb3Mvd2hpdGxvY2tqYy9wYXRoLWxvYWRlcicsIHtcbiAqICAgICBwcmVwYXJlUmVxdWVzdDogZnVuY3Rpb24gKHJlcSwgY2FsbGJhY2spIHtcbiAqICAgICAgIHJlcS5hdXRoKCdteS11c2VybmFtZScsICdteS1wYXNzd29yZCcpO1xuICogICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCByZXEpO1xuICogICAgIH1cbiAqICAgfSlcbiAqICAgLnRoZW4oSlNPTi5wYXJzZSlcbiAqICAgLnRoZW4oZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gKiAgICAgY29uc29sZS5sb2coZG9jdW1lbnQuZnVsbF9uYW1lICsgJzogJyArIGRvY3VtZW50LmRlc2NyaXB0aW9uKTtcbiAqICAgfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKTtcbiAqICAgfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEV4YW1wbGUgbG9hZGluZyBhIFlBTUwgZmlsZVxuICpcbiAqIFBhdGhMb2FkZXJcbiAqICAgLmxvYWQoJy9Vc2Vycy9ub3QteW91L3Byb2plY3RzL3BhdGgtbG9hZGVyLy50cmF2aXMueW1sJylcbiAqICAgLnRoZW4oWUFNTC5zYWZlTG9hZClcbiAqICAgLnRoZW4oZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gKiAgICAgY29uc29sZS5sb2coJ3BhdGgtbG9hZGVyIHVzZXMgdGhlJywgZG9jdW1lbnQubGFuZ3VhZ2UsICdsYW5ndWFnZS4nKTtcbiAqICAgfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKTtcbiAqICAgfSk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEV4YW1wbGUgbG9hZGluZyBhIFlBTUwgZmlsZSB3aXRoIG9wdGlvbnMucHJvY2Vzc0NvbnRlbnQgKFVzZWZ1bCBpZiB5b3UgbmVlZCBpbmZvcm1hdGlvbiBpbiB0aGUgcmF3IHJlc3BvbnNlKVxuICpcbiAqIFBhdGhMb2FkZXJcbiAqICAgLmxvYWQoJy9Vc2Vycy9ub3QteW91L3Byb2plY3RzL3BhdGgtbG9hZGVyLy50cmF2aXMueW1sJywge1xuICogICAgIHByb2Nlc3NDb250ZW50OiBmdW5jdGlvbiAocmVzLCBjYWxsYmFjaykge1xuICogICAgICAgY2FsbGJhY2soWUFNTC5zYWZlTG9hZChyZXMudGV4dCkpO1xuICogICAgIH1cbiAqICAgfSlcbiAqICAgLnRoZW4oZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gKiAgICAgY29uc29sZS5sb2coJ3BhdGgtbG9hZGVyIHVzZXMgdGhlJywgZG9jdW1lbnQubGFuZ3VhZ2UsICdsYW5ndWFnZS4nKTtcbiAqICAgfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKTtcbiAqICAgfSk7XG4gKi9cbm1vZHVsZS5leHBvcnRzLmxvYWQgPSBmdW5jdGlvbiAobG9jYXRpb24sIG9wdGlvbnMpIHtcbiAgdmFyIGFsbFRhc2tzID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgLy8gRGVmYXVsdCBvcHRpb25zIHRvIGVtcHR5IG9iamVjdFxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgYXJndW1lbnRzXG4gIGFsbFRhc2tzID0gYWxsVGFza3MudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xvY2F0aW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsb2NhdGlvbiBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnByb2Nlc3NDb250ZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0aW9ucy5wcm9jZXNzQ29udGVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLnByb2Nlc3NDb250ZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gTG9hZCB0aGUgZG9jdW1lbnQgZnJvbSB0aGUgcHJvdmlkZWQgbG9jYXRpb24gYW5kIHByb2Nlc3MgaXRcbiAgYWxsVGFza3MgPSBhbGxUYXNrc1xuICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBsb2FkZXIgPSBnZXRMb2FkZXIobG9jYXRpb24pO1xuXG4gICAgICAgIGxvYWRlci5sb2FkKGxvY2F0aW9uLCBvcHRpb25zIHx8IHt9LCBmdW5jdGlvbiAoZXJyLCBkb2N1bWVudCkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGRvY3VtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICBpZiAob3B0aW9ucy5wcm9jZXNzQ29udGVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIC8vIEZvciBjb25zaXN0ZW5jeSBiZXR3ZWVuIGZpbGUgYW5kIGh0dHAsIGFsd2F5cyBzZW5kIGFuIG9iamVjdCB3aXRoIGEgJ3RleHQnIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIHJhd1xuICAgICAgICAgIC8vIHN0cmluZyB2YWx1ZSBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgICAgb3B0aW9ucy5wcm9jZXNzQ29udGVudCh0eXBlb2YgcmVzID09PSAnb2JqZWN0JyA/IHJlcyA6IHt0ZXh0OiByZXN9LCBmdW5jdGlvbiAoZXJyLCBwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKHByb2Nlc3NlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIGNvbnRlbnQgcHJvY2Vzc29yLCB3ZSB3aWxsIGFzc3VtZSB0aGF0IGZvciBhbGwgb2JqZWN0cyB0aGF0IGl0IGlzIGEgU3VwZXJhZ2VudCByZXNwb25zZVxuICAgICAgICAvLyBhbmQgd2lsbCByZXR1cm4gaXRzIGB0ZXh0YCBwcm9wZXJ0eSB2YWx1ZS4gIE90aGVyd2lzZSwgd2Ugd2lsbCByZXR1cm4gdGhlIHJhdyByZXNwb25zZS5cbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXMgPT09ICdvYmplY3QnID8gcmVzLnRleHQgOiByZXM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgcmV0dXJuIGFsbFRhc2tzO1xufTtcbiIsIi8qXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgSmVyZW15IFdoaXRsb2NrXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1bnN1cHBvcnRlZEVycm9yID0gbmV3IFR5cGVFcnJvcignVGhlIFxcJ2ZpbGVcXCcgc2NoZW1lIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXInKTtcblxuLyoqXG4gKiBUaGUgZmlsZSBsb2FkZXIgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAdGhyb3dzIHtlcnJvcn0gdGhlIGZpbGUgbG9hZGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXJcbiAqL1xubW9kdWxlLmV4cG9ydHMuZ2V0QmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgdW5zdXBwb3J0ZWRFcnJvcjtcbn07XG5cbi8qKlxuICogVGhlIGZpbGUgbG9hZGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGJyb3dzZXIuXG4gKi9cbm1vZHVsZS5leHBvcnRzLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG5cbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuKHVuc3VwcG9ydGVkRXJyb3IpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IHVuc3VwcG9ydGVkRXJyb3I7XG4gIH1cbn07XG4iLCIvKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuLypcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBKZXJlbXkgV2hpdGxvY2tcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVlc3QgPSByZXF1aXJlKCdzdXBlcmFnZW50Jyk7XG5cbnZhciBzdXBwb3J0ZWRIdHRwTWV0aG9kcyA9IFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ3BhdGNoJywgJ3Bvc3QnLCAncHV0J107XG5cbi8qKlxuICogTG9hZHMgYSBmaWxlIGZyb20gYW4gaHR0cCBvciBodHRwcyBVUkwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIC0gVGhlIGRvY3VtZW50IFVSTCAoSWYgcmVsYXRpdmUsIGxvY2F0aW9uIGlzIHJlbGF0aXZlIHRvIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgbG9hZGVyIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tZXRob2Q9Z2V0XSAtIFRoZSBIVFRQIG1ldGhvZCB0byB1c2UgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0ge21vZHVsZTpQYXRoTG9hZGVyflByZXBhcmVSZXF1ZXN0Q2FsbGJhY2t9IFtvcHRpb25zLnByZXBhcmVSZXF1ZXN0XSAtIFRoZSBjYWxsYmFjayB1c2VkIHRvIHByZXBhcmUgYSByZXF1ZXN0XG4gKiBAcGFyYW0ge21vZHVsZTpQYXRoTG9hZGVyflByb2Nlc3NSZXNwb25zZUNhbGxiYWNrfSBbb3B0aW9ucy5wcm9jZXNzQ29udGVudF0gLSBUaGUgY2FsbGJhY2sgdXNlZCB0byBwcm9jZXNzIHRoZVxuICogcmVzcG9uc2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGVycm9yLWZpcnN0IGNhbGxiYWNrXG4gKi9cbm1vZHVsZS5leHBvcnRzLmxvYWQgPSBmdW5jdGlvbiAobG9jYXRpb24sIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciByZWFsTWV0aG9kID0gb3B0aW9ucy5tZXRob2QgPyBvcHRpb25zLm1ldGhvZC50b0xvd2VyQ2FzZSgpIDogJ2dldCc7XG4gIHZhciBlcnI7XG4gIHZhciByZWFsUmVxdWVzdDtcblxuICBmdW5jdGlvbiBtYWtlUmVxdWVzdCAoZXJyLCByZXEpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBidWZmZXIoKSBpcyBvbmx5IGF2YWlsYWJsZSBpbiBOb2RlLmpzXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyA/IHByb2Nlc3MgOiAwKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nICYmXG4gICAgICAgICAgdHlwZW9mIHJlcS5idWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVxLmJ1ZmZlcih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgcmVxXG4gICAgICAgIC5lbmQoZnVuY3Rpb24gKGVycjIsIHJlcykge1xuICAgICAgICAgIGlmIChlcnIyKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sodW5kZWZpbmVkLCByZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLm1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgZXJyID0gbmV3IFR5cGVFcnJvcignb3B0aW9ucy5tZXRob2QgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH0gZWxzZSBpZiAoc3VwcG9ydGVkSHR0cE1ldGhvZHMuaW5kZXhPZihvcHRpb25zLm1ldGhvZCkgPT09IC0xKSB7XG4gICAgICBlcnIgPSBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm1ldGhvZCBtdXN0IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOiAnICtcbiAgICAgICAgc3VwcG9ydGVkSHR0cE1ldGhvZHMuc2xpY2UoMCwgc3VwcG9ydGVkSHR0cE1ldGhvZHMubGVuZ3RoIC0gMSkuam9pbignLCAnKSArICcgb3IgJyArXG4gICAgICAgIHN1cHBvcnRlZEh0dHBNZXRob2RzW3N1cHBvcnRlZEh0dHBNZXRob2RzLmxlbmd0aCAtIDFdKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMucHJlcGFyZVJlcXVlc3QgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBvcHRpb25zLnByZXBhcmVSZXF1ZXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgZXJyID0gbmV3IFR5cGVFcnJvcignb3B0aW9ucy5wcmVwYXJlUmVxdWVzdCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghZXJyKSB7XG4gICAgcmVhbFJlcXVlc3QgPSByZXF1ZXN0W3JlYWxNZXRob2QgPT09ICdkZWxldGUnID8gJ2RlbCcgOiByZWFsTWV0aG9kXShsb2NhdGlvbik7XG5cbiAgICBpZiAob3B0aW9ucy5wcmVwYXJlUmVxdWVzdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3B0aW9ucy5wcmVwYXJlUmVxdWVzdChyZWFsUmVxdWVzdCwgbWFrZVJlcXVlc3QpO1xuICAgICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgICBjYWxsYmFjayhlcnIyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFrZVJlcXVlc3QodW5kZWZpbmVkLCByZWFsUmVxdWVzdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKGVycik7XG4gIH1cbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGlucHV0ID0+IHtcblx0Y29uc3QgaXNFeHRlbmRlZExlbmd0aFBhdGggPSAvXlxcXFxcXFxcXFw/XFxcXC8udGVzdChpbnB1dCk7XG5cdGNvbnN0IGhhc05vbkFzY2lpID0gL1teXFx1MDAwMC1cXHUwMDgwXSsvLnRlc3QoaW5wdXQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuXHRpZiAoaXNFeHRlbmRlZExlbmd0aFBhdGggfHwgaGFzTm9uQXNjaWkpIHtcblx0XHRyZXR1cm4gaW5wdXQ7XG5cdH1cblxuXHRyZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xufTtcbiIsImZ1bmN0aW9uIEFnZW50KCkge1xuICB0aGlzLl9kZWZhdWx0cyA9IFtdO1xufVxuXG5bXCJ1c2VcIiwgXCJvblwiLCBcIm9uY2VcIiwgXCJzZXRcIiwgXCJxdWVyeVwiLCBcInR5cGVcIiwgXCJhY2NlcHRcIiwgXCJhdXRoXCIsIFwid2l0aENyZWRlbnRpYWxzXCIsIFwic29ydFF1ZXJ5XCIsIFwicmV0cnlcIiwgXCJva1wiLCBcInJlZGlyZWN0c1wiLFxuIFwidGltZW91dFwiLCBcImJ1ZmZlclwiLCBcInNlcmlhbGl6ZVwiLCBcInBhcnNlXCIsIFwiY2FcIiwgXCJrZXlcIiwgXCJwZnhcIiwgXCJjZXJ0XCJdLmZvckVhY2goZnVuY3Rpb24oZm4pIHtcbiAgLyoqIERlZmF1bHQgc2V0dGluZyBmb3IgYWxsIHJlcXVlc3RzIGZyb20gdGhpcyBhZ2VudCAqL1xuICBBZ2VudC5wcm90b3R5cGVbZm5dID0gZnVuY3Rpb24oLyp2YXJhcmdzKi8pIHtcbiAgICB0aGlzLl9kZWZhdWx0cy5wdXNoKHtmbjpmbiwgYXJndW1lbnRzOmFyZ3VtZW50c30pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59KTtcblxuQWdlbnQucHJvdG90eXBlLl9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKHJlcSkge1xuICAgIHRoaXMuX2RlZmF1bHRzLmZvckVhY2goZnVuY3Rpb24oZGVmKSB7XG4gICAgICByZXFbZGVmLmZuXS5hcHBseShyZXEsIGRlZi5hcmd1bWVudHMpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudDtcbiIsIi8qKlxuICogUm9vdCByZWZlcmVuY2UgZm9yIGlmcmFtZXMuXG4gKi9cblxudmFyIHJvb3Q7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gQnJvd3NlciB3aW5kb3dcbiAgcm9vdCA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IC8vIFdlYiBXb3JrZXJcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgeyAvLyBPdGhlciBlbnZpcm9ubWVudHNcbiAgY29uc29sZS53YXJuKFwiVXNpbmcgYnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcbiAgcm9vdCA9IHRoaXM7XG59XG5cbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBSZXF1ZXN0QmFzZSA9IHJlcXVpcmUoJy4vcmVxdWVzdC1iYXNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xudmFyIFJlc3BvbnNlQmFzZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UtYmFzZScpO1xudmFyIEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudC1iYXNlJyk7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fTtcblxuLyoqXG4gKiBFeHBvc2UgYHJlcXVlc3RgLlxuICovXG5cbnZhciByZXF1ZXN0ID0gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0aG9kLCB1cmwpIHtcbiAgLy8gY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHVybCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpLmVuZCh1cmwpO1xuICB9XG5cbiAgLy8gdXJsIGZpcnN0XG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IGV4cG9ydHMuUmVxdWVzdCgnR0VUJywgbWV0aG9kKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbn1cblxuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBEZXRlcm1pbmUgWEhSLlxuICovXG5cbnJlcXVlc3QuZ2V0WEhSID0gZnVuY3Rpb24gKCkge1xuICBpZiAocm9vdC5YTUxIdHRwUmVxdWVzdFxuICAgICAgJiYgKCFyb290LmxvY2F0aW9uIHx8ICdmaWxlOicgIT0gcm9vdC5sb2NhdGlvbi5wcm90b2NvbFxuICAgICAgICAgIHx8ICFyb290LkFjdGl2ZVhPYmplY3QpKSB7XG4gICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdDtcbiAgfSBlbHNlIHtcbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjYuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUC4zLjAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICB9XG4gIHRocm93IEVycm9yKFwiQnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBjb3VsZCBub3QgZmluZCBYSFJcIik7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSwgYWRkZWQgdG8gc3VwcG9ydCBJRS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHRyaW0gPSAnJy50cmltXG4gID8gZnVuY3Rpb24ocykgeyByZXR1cm4gcy50cmltKCk7IH1cbiAgOiBmdW5jdGlvbihzKSB7IHJldHVybiBzLnJlcGxhY2UoLyheXFxzKnxcXHMqJCkvZywgJycpOyB9O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xuICBpZiAoIWlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gIHZhciBwYWlycyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgb2JqW2tleV0pO1xuICB9XG4gIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG59XG5cbi8qKlxuICogSGVscHMgJ3NlcmlhbGl6ZScgd2l0aCBzZXJpYWxpemluZyBhcnJheXMuXG4gKiBNdXRhdGVzIHRoZSBwYWlycyBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKi9cblxuZnVuY3Rpb24gcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdmFsKSB7XG4gIGlmICh2YWwgIT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcHVzaEVuY29kZWRLZXlWYWx1ZVBhaXIocGFpcnMsIGtleSwgdik7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGZvcih2YXIgc3Via2V5IGluIHZhbCkge1xuICAgICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5ICsgJ1snICsgc3Via2V5ICsgJ10nLCB2YWxbc3Via2V5XSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSlcbiAgICAgICAgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkpO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIHNlcmlhbGl6YXRpb24gbWV0aG9kLlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplO1xuXG4vKipcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4geC13d3ctZm9ybS11cmxlbmNvZGVkIGBzdHJgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAqIEByZXR1cm4ge09iamVjdH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XG4gIHZhciBwYWlyO1xuICB2YXIgcG9zO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWlycy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHBhaXIgPSBwYWlyc1tpXTtcbiAgICBwb3MgPSBwYWlyLmluZGV4T2YoJz0nKTtcbiAgICBpZiAocG9zID09IC0xKSB7XG4gICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIpXSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIuc2xpY2UoMCwgcG9zKSldID1cbiAgICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KHBhaXIuc2xpY2UocG9zICsgMSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogRXhwb3NlIHBhcnNlci5cbiAqL1xuXG5yZXF1ZXN0LnBhcnNlU3RyaW5nID0gcGFyc2VTdHJpbmc7XG5cbi8qKlxuICogRGVmYXVsdCBNSU1FIHR5cGUgbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqL1xuXG5yZXF1ZXN0LnR5cGVzID0ge1xuICBodG1sOiAndGV4dC9odG1sJyxcbiAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB4bWw6ICd0ZXh0L3htbCcsXG4gIHVybGVuY29kZWQ6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAnZm9ybSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAnZm9ybS1kYXRhJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzZXJpYWxpemF0aW9uIG1hcC5cbiAqXG4gKiAgICAgc3VwZXJhZ2VudC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24ob2JqKXtcbiAqICAgICAgIHJldHVybiAnZ2VuZXJhdGVkIHhtbCBoZXJlJztcbiAqICAgICB9O1xuICpcbiAqL1xuXG5yZXF1ZXN0LnNlcmlhbGl6ZSA9IHtcbiAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHNlcmlhbGl6ZSxcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnN0cmluZ2lmeVxufTtcblxuLyoqXG4gICogRGVmYXVsdCBwYXJzZXJzLlxuICAqXG4gICogICAgIHN1cGVyYWdlbnQucGFyc2VbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24oc3RyKXtcbiAgKiAgICAgICByZXR1cm4geyBvYmplY3QgcGFyc2VkIGZyb20gc3RyIH07XG4gICogICAgIH07XG4gICpcbiAgKi9cblxucmVxdWVzdC5wYXJzZSA9IHtcbiAgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHBhcnNlU3RyaW5nLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04ucGFyc2Vcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGhlYWRlciBgc3RyYCBpbnRvXG4gKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbWFwcGVkIGZpZWxkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcihzdHIpIHtcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KC9cXHI/XFxuLyk7XG4gIHZhciBmaWVsZHMgPSB7fTtcbiAgdmFyIGluZGV4O1xuICB2YXIgbGluZTtcbiAgdmFyIGZpZWxkO1xuICB2YXIgdmFsO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxpbmUgPSBsaW5lc1tpXTtcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHsgLy8gY291bGQgYmUgZW1wdHkgbGluZSwganVzdCBza2lwIGl0XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGluZGV4KS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHRyaW0obGluZS5zbGljZShpbmRleCArIDEpKTtcbiAgICBmaWVsZHNbZmllbGRdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBgbWltZWAgaXMganNvbiBvciBoYXMgK2pzb24gc3RydWN0dXJlZCBzeW50YXggc3VmZml4LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNKU09OKG1pbWUpIHtcbiAgLy8gc2hvdWxkIG1hdGNoIC9qc29uIG9yICtqc29uXG4gIC8vIGJ1dCBub3QgL2pzb24tc2VxXG4gIHJldHVybiAvW1xcLytdanNvbigkfFteLVxcd10pLy50ZXN0KG1pbWUpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYFJlc3BvbnNlYCB3aXRoIHRoZSBnaXZlbiBgeGhyYC5cbiAqXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXG4gKiAgLSBwYXJzZSBoZWFkZXJcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgQWxpYXNpbmcgYHN1cGVyYWdlbnRgIGFzIGByZXF1ZXN0YCBpcyBuaWNlOlxuICpcbiAqICAgICAgcmVxdWVzdCA9IHN1cGVyYWdlbnQ7XG4gKlxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nKS5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBTZW5kaW5nIGRhdGEgY2FuIGJlIGNoYWluZWQ6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XG4gKlxuICogICAgICByZXF1ZXN0XG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBAcGFyYW0ge1hNTEhUVFBSZXF1ZXN0fSB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBSZXNwb25zZShyZXEpIHtcbiAgdGhpcy5yZXEgPSByZXE7XG4gIHRoaXMueGhyID0gdGhpcy5yZXEueGhyO1xuICAvLyByZXNwb25zZVRleHQgaXMgYWNjZXNzaWJsZSBvbmx5IGlmIHJlc3BvbnNlVHlwZSBpcyAnJyBvciAndGV4dCcgYW5kIG9uIG9sZGVyIGJyb3dzZXJzXG4gIHRoaXMudGV4dCA9ICgodGhpcy5yZXEubWV0aG9kICE9J0hFQUQnICYmICh0aGlzLnhoci5yZXNwb25zZVR5cGUgPT09ICcnIHx8IHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnKSkgfHwgdHlwZW9mIHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgID8gdGhpcy54aHIucmVzcG9uc2VUZXh0XG4gICAgIDogbnVsbDtcbiAgdGhpcy5zdGF0dXNUZXh0ID0gdGhpcy5yZXEueGhyLnN0YXR1c1RleHQ7XG4gIHZhciBzdGF0dXMgPSB0aGlzLnhoci5zdGF0dXM7XG4gIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgIHN0YXR1cyA9IDIwNDtcbiAgfVxuICB0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHN0YXR1cyk7XG4gIHRoaXMuaGVhZGVyID0gdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXIodGhpcy54aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAvLyBnZXRBbGxSZXNwb25zZUhlYWRlcnMgc29tZXRpbWVzIGZhbHNlbHkgcmV0dXJucyBcIlwiIGZvciBDT1JTIHJlcXVlc3RzLCBidXRcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXG4gIC8vIG90aGVyIGhlYWRlcnMgZmFpbHMuXG4gIHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdjb250ZW50LXR5cGUnKTtcbiAgdGhpcy5fc2V0SGVhZGVyUHJvcGVydGllcyh0aGlzLmhlYWRlcik7XG5cbiAgaWYgKG51bGwgPT09IHRoaXMudGV4dCAmJiByZXEuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHRoaXMuYm9keSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYm9keSA9IHRoaXMucmVxLm1ldGhvZCAhPSAnSEVBRCdcbiAgICAgID8gdGhpcy5fcGFyc2VCb2R5KHRoaXMudGV4dCA/IHRoaXMudGV4dCA6IHRoaXMueGhyLnJlc3BvbnNlKVxuICAgICAgOiBudWxsO1xuICB9XG59XG5cblJlc3BvbnNlQmFzZShSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBib2R5IGBzdHJgLlxuICpcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcbiAqIGFyZSBkZWZpbmVkIG9uIHRoZSBgc3VwZXJhZ2VudC5wYXJzZWAgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLl9wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIHBhcnNlID0gcmVxdWVzdC5wYXJzZVt0aGlzLnR5cGVdO1xuICBpZiAodGhpcy5yZXEuX3BhcnNlcikge1xuICAgIHJldHVybiB0aGlzLnJlcS5fcGFyc2VyKHRoaXMsIHN0cik7XG4gIH1cbiAgaWYgKCFwYXJzZSAmJiBpc0pTT04odGhpcy50eXBlKSkge1xuICAgIHBhcnNlID0gcmVxdWVzdC5wYXJzZVsnYXBwbGljYXRpb24vanNvbiddO1xuICB9XG4gIHJldHVybiBwYXJzZSAmJiBzdHIgJiYgKHN0ci5sZW5ndGggfHwgc3RyIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgID8gcGFyc2Uoc3RyKVxuICAgIDogbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGBFcnJvcmAgcmVwcmVzZW50YXRpdmUgb2YgdGhpcyByZXNwb25zZS5cbiAqXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2UucHJvdG90eXBlLnRvRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgcmVxID0gdGhpcy5yZXE7XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kO1xuICB2YXIgdXJsID0gcmVxLnVybDtcblxuICB2YXIgbXNnID0gJ2Nhbm5vdCAnICsgbWV0aG9kICsgJyAnICsgdXJsICsgJyAoJyArIHRoaXMuc3RhdHVzICsgJyknO1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcbiAgZXJyLnVybCA9IHVybDtcblxuICByZXR1cm4gZXJyO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlYC5cbiAqL1xuXG5yZXF1ZXN0LlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdGAgd2l0aCB0aGUgZ2l2ZW4gYG1ldGhvZGAgYW5kIGB1cmxgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChtZXRob2QsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XG4gIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICB0aGlzLnVybCA9IHVybDtcbiAgdGhpcy5oZWFkZXIgPSB7fTsgLy8gcHJlc2VydmVzIGhlYWRlciBuYW1lIGNhc2VcbiAgdGhpcy5faGVhZGVyID0ge307IC8vIGNvZXJjZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyY2FzZVxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpe1xuICAgIHZhciBlcnIgPSBudWxsO1xuICAgIHZhciByZXMgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IG5ldyBSZXNwb25zZShzZWxmKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGVyciA9IG5ldyBFcnJvcignUGFyc2VyIGlzIHVuYWJsZSB0byBwYXJzZSB0aGUgcmVzcG9uc2UnKTtcbiAgICAgIGVyci5wYXJzZSA9IHRydWU7XG4gICAgICBlcnIub3JpZ2luYWwgPSBlO1xuICAgICAgLy8gaXNzdWUgIzY3NTogcmV0dXJuIHRoZSByYXcgcmVzcG9uc2UgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgIGlmIChzZWxmLnhocikge1xuICAgICAgICAvLyBpZTkgZG9lc24ndCBoYXZlICdyZXNwb25zZScgcHJvcGVydHlcbiAgICAgICAgZXJyLnJhd1Jlc3BvbnNlID0gdHlwZW9mIHNlbGYueGhyLnJlc3BvbnNlVHlwZSA9PSAndW5kZWZpbmVkJyA/IHNlbGYueGhyLnJlc3BvbnNlVGV4dCA6IHNlbGYueGhyLnJlc3BvbnNlO1xuICAgICAgICAvLyBpc3N1ZSAjODc2OiByZXR1cm4gdGhlIGh0dHAgc3RhdHVzIGNvZGUgaWYgdGhlIHJlc3BvbnNlIHBhcnNpbmcgZmFpbHNcbiAgICAgICAgZXJyLnN0YXR1cyA9IHNlbGYueGhyLnN0YXR1cyA/IHNlbGYueGhyLnN0YXR1cyA6IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXNDb2RlID0gZXJyLnN0YXR1czsgLy8gYmFja3dhcmRzLWNvbXBhdCBvbmx5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSBudWxsO1xuICAgICAgICBlcnIuc3RhdHVzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcblxuICAgIHZhciBuZXdfZXJyO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXNlbGYuX2lzUmVzcG9uc2VPSyhyZXMpKSB7XG4gICAgICAgIG5ld19lcnIgPSBuZXcgRXJyb3IocmVzLnN0YXR1c1RleHQgfHwgJ1Vuc3VjY2Vzc2Z1bCBIVFRQIHJlc3BvbnNlJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaChjdXN0b21fZXJyKSB7XG4gICAgICBuZXdfZXJyID0gY3VzdG9tX2VycjsgLy8gb2soKSBjYWxsYmFjayBjYW4gdGhyb3dcbiAgICB9XG5cbiAgICAvLyAjMTAwMCBkb24ndCBjYXRjaCBlcnJvcnMgZnJvbSB0aGUgY2FsbGJhY2sgdG8gYXZvaWQgZG91YmxlIGNhbGxpbmcgaXRcbiAgICBpZiAobmV3X2Vycikge1xuICAgICAgbmV3X2Vyci5vcmlnaW5hbCA9IGVycjtcbiAgICAgIG5ld19lcnIucmVzcG9uc2UgPSByZXM7XG4gICAgICBuZXdfZXJyLnN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICBzZWxmLmNhbGxiYWNrKG5ld19lcnIsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIE1peGluIGBFbWl0dGVyYCBhbmQgYFJlcXVlc3RCYXNlYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblJlcXVlc3RCYXNlKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXQgQ29udGVudC1UeXBlIHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xuICpcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcbiAqICAgICAgICAudHlwZSgneG1sJylcbiAqICAgICAgICAuc2VuZCh4bWxzdHJpbmcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCdhcHBsaWNhdGlvbi94bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0NvbnRlbnQtVHlwZScsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQWNjZXB0IHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICBzdXBlcmFnZW50LnR5cGVzLmpzb24gPSAnYXBwbGljYXRpb24vanNvbic7XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcbiAqICAgICAgICAuYWNjZXB0KCdqc29uJylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY2NlcHRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbih0eXBlKXtcbiAgdGhpcy5zZXQoJ0FjY2VwdCcsIHJlcXVlc3QudHlwZXNbdHlwZV0gfHwgdHlwZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgQXV0aG9yaXphdGlvbiBmaWVsZCB2YWx1ZSB3aXRoIGB1c2VyYCBhbmQgYHBhc3NgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Bhc3NdIG9wdGlvbmFsIGluIGNhc2Ugb2YgdXNpbmcgJ2JlYXJlcicgYXMgdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgd2l0aCAndHlwZScgcHJvcGVydHkgJ2F1dG8nLCAnYmFzaWMnIG9yICdiZWFyZXInIChkZWZhdWx0ICdiYXNpYycpXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXV0aCA9IGZ1bmN0aW9uKHVzZXIsIHBhc3MsIG9wdGlvbnMpe1xuICBpZiAoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCkgcGFzcyA9ICcnO1xuICBpZiAodHlwZW9mIHBhc3MgPT09ICdvYmplY3QnICYmIHBhc3MgIT09IG51bGwpIHsgLy8gcGFzcyBpcyBvcHRpb25hbCBhbmQgY2FuIGJlIHJlcGxhY2VkIHdpdGggb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBwYXNzO1xuICAgIHBhc3MgPSAnJztcbiAgfVxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgdHlwZTogJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGJ0b2EgPyAnYmFzaWMnIDogJ2F1dG8nLFxuICAgIH07XG4gIH1cblxuICB2YXIgZW5jb2RlciA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSkge1xuICAgICAgcmV0dXJuIGJ0b2Eoc3RyaW5nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXNlIGJhc2ljIGF1dGgsIGJ0b2EgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfTtcblxuICByZXR1cm4gdGhpcy5fYXV0aCh1c2VyLCBwYXNzLCBvcHRpb25zLCBlbmNvZGVyKTtcbn07XG5cbi8qKlxuICogQWRkIHF1ZXJ5LXN0cmluZyBgdmFsYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxuICogICAgIC5xdWVyeSgnc2l6ZT0xMCcpXG4gKiAgICAgLnF1ZXJ5KHsgY29sb3I6ICdibHVlJyB9KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2YWwpe1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHZhbCkgdmFsID0gc2VyaWFsaXplKHZhbCk7XG4gIGlmICh2YWwpIHRoaXMuX3F1ZXJ5LnB1c2godmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFF1ZXVlIHRoZSBnaXZlbiBgZmlsZWAgYXMgYW4gYXR0YWNobWVudCB0byB0aGUgc3BlY2lmaWVkIGBmaWVsZGAsXG4gKiB3aXRoIG9wdGlvbmFsIGBvcHRpb25zYCAob3IgZmlsZW5hbWUpLlxuICpcbiAqIGBgYCBqc1xuICogcmVxdWVzdC5wb3N0KCcvdXBsb2FkJylcbiAqICAgLmF0dGFjaCgnY29udGVudCcsIG5ldyBCbG9iKFsnPGEgaWQ9XCJhXCI+PGIgaWQ9XCJiXCI+aGV5ITwvYj48L2E+J10sIHsgdHlwZTogXCJ0ZXh0L2h0bWxcIn0pKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGZpZWxkLCBmaWxlLCBvcHRpb25zKXtcbiAgaWYgKGZpbGUpIHtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJzdXBlcmFnZW50IGNhbid0IG1peCAuc2VuZCgpIGFuZCAuYXR0YWNoKClcIik7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQoZmllbGQsIGZpbGUsIG9wdGlvbnMgfHwgZmlsZS5uYW1lKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9nZXRGb3JtRGF0YSA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5fZm9ybURhdGEpIHtcbiAgICB0aGlzLl9mb3JtRGF0YSA9IG5ldyByb290LkZvcm1EYXRhKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2Zvcm1EYXRhO1xufTtcblxuLyoqXG4gKiBJbnZva2UgdGhlIGNhbGxiYWNrIHdpdGggYGVycmAgYW5kIGByZXNgXG4gKiBhbmQgaGFuZGxlIGFyaXR5IGNoZWNrLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gcmVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgcmVzKXtcbiAgaWYgKHRoaXMuX3Nob3VsZFJldHJ5KGVyciwgcmVzKSkge1xuICAgIHJldHVybiB0aGlzLl9yZXRyeSgpO1xuICB9XG5cbiAgdmFyIGZuID0gdGhpcy5fY2FsbGJhY2s7XG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG5cbiAgaWYgKGVycikge1xuICAgIGlmICh0aGlzLl9tYXhSZXRyaWVzKSBlcnIucmV0cmllcyA9IHRoaXMuX3JldHJpZXMgLSAxO1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG5cbiAgZm4oZXJyLCByZXMpO1xufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB4LWRvbWFpbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcm9zc0RvbWFpbkVycm9yID0gZnVuY3Rpb24oKXtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignUmVxdWVzdCBoYXMgYmVlbiB0ZXJtaW5hdGVkXFxuUG9zc2libGUgY2F1c2VzOiB0aGUgbmV0d29yayBpcyBvZmZsaW5lLCBPcmlnaW4gaXMgbm90IGFsbG93ZWQgYnkgQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luLCB0aGUgcGFnZSBpcyBiZWluZyB1bmxvYWRlZCwgZXRjLicpO1xuICBlcnIuY3Jvc3NEb21haW4gPSB0cnVlO1xuXG4gIGVyci5zdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgZXJyLm1ldGhvZCA9IHRoaXMubWV0aG9kO1xuICBlcnIudXJsID0gdGhpcy51cmw7XG5cbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xufTtcblxuLy8gVGhpcyBvbmx5IHdhcm5zLCBiZWNhdXNlIHRoZSByZXF1ZXN0IGlzIHN0aWxsIGxpa2VseSB0byB3b3JrXG5SZXF1ZXN0LnByb3RvdHlwZS5idWZmZXIgPSBSZXF1ZXN0LnByb3RvdHlwZS5jYSA9IFJlcXVlc3QucHJvdG90eXBlLmFnZW50ID0gZnVuY3Rpb24oKXtcbiAgY29uc29sZS53YXJuKFwiVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFRoaXMgdGhyb3dzLCBiZWNhdXNlIGl0IGNhbid0IHNlbmQvcmVjZWl2ZSBkYXRhIGFzIGV4cGVjdGVkXG5SZXF1ZXN0LnByb3RvdHlwZS5waXBlID0gUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbigpe1xuICB0aHJvdyBFcnJvcihcIlN0cmVhbWluZyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhIGhvc3Qgb2JqZWN0LFxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblJlcXVlc3QucHJvdG90eXBlLl9pc0hvc3QgPSBmdW5jdGlvbiBfaXNIb3N0KG9iaikge1xuICAvLyBOYXRpdmUgb2JqZWN0cyBzdHJpbmdpZnkgdG8gW29iamVjdCBGaWxlXSwgW29iamVjdCBCbG9iXSwgW29iamVjdCBGb3JtRGF0YV0sIGV0Yy5cbiAgcmV0dXJuIG9iaiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iaiAmJiAhQXJyYXkuaXNBcnJheShvYmopICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopICE9PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBJbml0aWF0ZSByZXF1ZXN0LCBpbnZva2luZyBjYWxsYmFjayBgZm4ocmVzKWBcbiAqIHdpdGggYW4gaW5zdGFuY2VvZiBgUmVzcG9uc2VgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xuICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgY29uc29sZS53YXJuKFwiV2FybmluZzogLmVuZCgpIHdhcyBjYWxsZWQgdHdpY2UuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBpbiBzdXBlcmFnZW50XCIpO1xuICB9XG4gIHRoaXMuX2VuZENhbGxlZCA9IHRydWU7XG5cbiAgLy8gc3RvcmUgY2FsbGJhY2tcbiAgdGhpcy5fY2FsbGJhY2sgPSBmbiB8fCBub29wO1xuXG4gIC8vIHF1ZXJ5c3RyaW5nXG4gIHRoaXMuX2ZpbmFsaXplUXVlcnlTdHJpbmcoKTtcblxuICByZXR1cm4gdGhpcy5fZW5kKCk7XG59O1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5fZW5kID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhociA9ICh0aGlzLnhociA9IHJlcXVlc3QuZ2V0WEhSKCkpO1xuICB2YXIgZGF0YSA9IHRoaXMuX2Zvcm1EYXRhIHx8IHRoaXMuX2RhdGE7XG5cbiAgdGhpcy5fc2V0VGltZW91dHMoKTtcblxuICAvLyBzdGF0ZSBjaGFuZ2VcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICBpZiAocmVhZHlTdGF0ZSA+PSAyICYmIHNlbGYuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc2VsZi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICAgIH1cbiAgICBpZiAoNCAhPSByZWFkeVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW4gSUU5LCByZWFkcyB0byBhbnkgcHJvcGVydHkgKGUuZy4gc3RhdHVzKSBvZmYgb2YgYW4gYWJvcnRlZCBYSFIgd2lsbFxuICAgIC8vIHJlc3VsdCBpbiB0aGUgZXJyb3IgXCJDb3VsZCBub3QgY29tcGxldGUgdGhlIG9wZXJhdGlvbiBkdWUgdG8gZXJyb3IgYzAwYzAyM2ZcIlxuICAgIHZhciBzdGF0dXM7XG4gICAgdHJ5IHsgc3RhdHVzID0geGhyLnN0YXR1cyB9IGNhdGNoKGUpIHsgc3RhdHVzID0gMDsgfVxuXG4gICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgIGlmIChzZWxmLnRpbWVkb3V0IHx8IHNlbGYuX2Fib3J0ZWQpIHJldHVybjtcbiAgICAgIHJldHVybiBzZWxmLmNyb3NzRG9tYWluRXJyb3IoKTtcbiAgICB9XG4gICAgc2VsZi5lbWl0KCdlbmQnKTtcbiAgfTtcblxuICAvLyBwcm9ncmVzc1xuICB2YXIgaGFuZGxlUHJvZ3Jlc3MgPSBmdW5jdGlvbihkaXJlY3Rpb24sIGUpIHtcbiAgICBpZiAoZS50b3RhbCA+IDApIHtcbiAgICAgIGUucGVyY2VudCA9IGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMDtcbiAgICB9XG4gICAgZS5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIGUpO1xuICB9O1xuICBpZiAodGhpcy5oYXNMaXN0ZW5lcnMoJ3Byb2dyZXNzJykpIHtcbiAgICB0cnkge1xuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICdkb3dubG9hZCcpO1xuICAgICAgaWYgKHhoci51cGxvYWQpIHtcbiAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gaGFuZGxlUHJvZ3Jlc3MuYmluZChudWxsLCAndXBsb2FkJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAvLyBBY2Nlc3NpbmcgeGhyLnVwbG9hZCBmYWlscyBpbiBJRSBmcm9tIGEgd2ViIHdvcmtlciwgc28ganVzdCBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAvLyBSZXBvcnRlZCBoZXJlOlxuICAgICAgLy8gaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy84MzcyNDUveG1saHR0cHJlcXVlc3QtdXBsb2FkLXRocm93cy1pbnZhbGlkLWFyZ3VtZW50LXdoZW4tdXNlZC1mcm9tLXdlYi13b3JrZXItY29udGV4dFxuICAgIH1cbiAgfVxuXG4gIC8vIGluaXRpYXRlIHJlcXVlc3RcbiAgdHJ5IHtcbiAgICBpZiAodGhpcy51c2VybmFtZSAmJiB0aGlzLnBhc3N3b3JkKSB7XG4gICAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUsIHRoaXMudXNlcm5hbWUsIHRoaXMucGFzc3dvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmwsIHRydWUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gc2VlICMxMTQ5XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2soZXJyKTtcbiAgfVxuXG4gIC8vIENPUlNcbiAgaWYgKHRoaXMuX3dpdGhDcmVkZW50aWFscykgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cbiAgLy8gYm9keVxuICBpZiAoIXRoaXMuX2Zvcm1EYXRhICYmICdHRVQnICE9IHRoaXMubWV0aG9kICYmICdIRUFEJyAhPSB0aGlzLm1ldGhvZCAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSAmJiAhdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgLy8gc2VyaWFsaXplIHN0dWZmXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICB2YXIgc2VyaWFsaXplID0gdGhpcy5fc2VyaWFsaXplciB8fCByZXF1ZXN0LnNlcmlhbGl6ZVtjb250ZW50VHlwZSA/IGNvbnRlbnRUeXBlLnNwbGl0KCc7JylbMF0gOiAnJ107XG4gICAgaWYgKCFzZXJpYWxpemUgJiYgaXNKU09OKGNvbnRlbnRUeXBlKSkge1xuICAgICAgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL2pzb24nXTtcbiAgICB9XG4gICAgaWYgKHNlcmlhbGl6ZSkgZGF0YSA9IHNlcmlhbGl6ZShkYXRhKTtcbiAgfVxuXG4gIC8vIHNldCBoZWFkZXIgZmllbGRzXG4gIGZvciAodmFyIGZpZWxkIGluIHRoaXMuaGVhZGVyKSB7XG4gICAgaWYgKG51bGwgPT0gdGhpcy5oZWFkZXJbZmllbGRdKSBjb250aW51ZTtcblxuICAgIGlmICh0aGlzLmhlYWRlci5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpXG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihmaWVsZCwgdGhpcy5oZWFkZXJbZmllbGRdKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9yZXNwb25zZVR5cGUpIHtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gdGhpcy5fcmVzcG9uc2VUeXBlO1xuICB9XG5cbiAgLy8gc2VuZCBzdHVmZlxuICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCB0aGlzKTtcblxuICAvLyBJRTExIHhoci5zZW5kKHVuZGVmaW5lZCkgc2VuZHMgJ3VuZGVmaW5lZCcgc3RyaW5nIGFzIFBPU1QgcGF5bG9hZCAoaW5zdGVhZCBvZiBub3RoaW5nKVxuICAvLyBXZSBuZWVkIG51bGwgaGVyZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICB4aHIuc2VuZCh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcgPyBkYXRhIDogbnVsbCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucmVxdWVzdC5hZ2VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEFnZW50KCk7XG59O1xuXG5bXCJHRVRcIiwgXCJQT1NUXCIsIFwiT1BUSU9OU1wiLCBcIlBBVENIXCIsIFwiUFVUXCIsIFwiREVMRVRFXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gIEFnZW50LnByb3RvdHlwZVttZXRob2QudG9Mb3dlckNhc2UoKV0gPSBmdW5jdGlvbih1cmwsIGZuKSB7XG4gICAgdmFyIHJlcSA9IG5ldyByZXF1ZXN0LlJlcXVlc3QobWV0aG9kLCB1cmwpO1xuICAgIHRoaXMuX3NldERlZmF1bHRzKHJlcSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICByZXEuZW5kKGZuKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcTtcbiAgfTtcbn0pO1xuXG5BZ2VudC5wcm90b3R5cGUuZGVsID0gQWdlbnQucHJvdG90eXBlWydkZWxldGUnXTtcblxuLyoqXG4gKiBHRVQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LmdldCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0dFVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogSEVBRCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuaGVhZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0hFQUQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEucXVlcnkoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIE9QVElPTlMgcXVlcnkgdG8gYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gW2RhdGFdIG9yIGZuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0Lm9wdGlvbnMgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdPUFRJT05TJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIERFTEVURSBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVsKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0RFTEVURScsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufVxuXG5yZXF1ZXN0WydkZWwnXSA9IGRlbDtcbnJlcXVlc3RbJ2RlbGV0ZSddID0gZGVsO1xuXG4vKipcbiAqIFBBVENIIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBhdGNoID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUEFUQ0gnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogUE9TVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtkYXRhXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wb3N0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUE9TVCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQVVQgYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucHV0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnUFVUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XG4gIHJldHVybiBudWxsICE9PSBvYmogJiYgJ29iamVjdCcgPT09IHR5cGVvZiBvYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIG9mIG1peGVkLWluIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiBub2RlIGFuZCBjbGllbnQgY29kZVxuICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzLW9iamVjdCcpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVxdWVzdEJhc2VgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVxdWVzdEJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVxdWVzdEJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdEJhc2Uob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIFJlcXVlc3RCYXNlLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gUmVxdWVzdEJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBDbGVhciBwcmV2aW91cyB0aW1lb3V0LlxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gX2NsZWFyVGltZW91dCgpe1xuICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICBjbGVhclRpbWVvdXQodGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpO1xuICBkZWxldGUgdGhpcy5fdGltZXI7XG4gIGRlbGV0ZSB0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGRlZmF1bHQgcmVzcG9uc2UgYm9keSBwYXJzZXJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHRvIGNvbnZlcnQgaW5jb21pbmcgZGF0YSBpbnRvIHJlcXVlc3QuYm9keVxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGZuKXtcbiAgdGhpcy5fcGFyc2VyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgZm9ybWF0IG9mIGJpbmFyeSByZXNwb25zZSBib2R5LlxuICogSW4gYnJvd3NlciB2YWxpZCBmb3JtYXRzIGFyZSAnYmxvYicgYW5kICdhcnJheWJ1ZmZlcicsXG4gKiB3aGljaCByZXR1cm4gQmxvYiBhbmQgQXJyYXlCdWZmZXIsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBJbiBOb2RlIGFsbCB2YWx1ZXMgcmVzdWx0IGluIEJ1ZmZlci5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC5yZXNwb25zZVR5cGUoJ2Jsb2InKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVzcG9uc2VUeXBlID0gZnVuY3Rpb24odmFsKXtcbiAgdGhpcy5fcmVzcG9uc2VUeXBlID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXF1ZXN0IGJvZHkgc2VyaWFsaXplclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBkYXRhIHNldCB2aWEgLnNlbmQgb3IgLmF0dGFjaCBpbnRvIHBheWxvYWQgdG8gc2VuZFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoZm4pe1xuICB0aGlzLl9zZXJpYWxpemVyID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgdGltZW91dHMuXG4gKlxuICogLSByZXNwb25zZSB0aW1lb3V0IGlzIHRpbWUgYmV0d2VlbiBzZW5kaW5nIHJlcXVlc3QgYW5kIHJlY2VpdmluZyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgcmVzcG9uc2UuIEluY2x1ZGVzIEROUyBhbmQgY29ubmVjdGlvbiB0aW1lLlxuICogLSBkZWFkbGluZSBpcyB0aGUgdGltZSBmcm9tIHN0YXJ0IG9mIHRoZSByZXF1ZXN0IHRvIHJlY2VpdmluZyByZXNwb25zZSBib2R5IGluIGZ1bGwuIElmIHRoZSBkZWFkbGluZSBpcyB0b28gc2hvcnQgbGFyZ2UgZmlsZXMgbWF5IG5vdCBsb2FkIGF0IGFsbCBvbiBzbG93IGNvbm5lY3Rpb25zLlxuICpcbiAqIFZhbHVlIG9mIDAgb3IgZmFsc2UgbWVhbnMgbm8gdGltZW91dC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IG1zIG9yIHtyZXNwb25zZSwgZGVhZGxpbmV9XG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiB0aW1lb3V0KG9wdGlvbnMpe1xuICBpZiAoIW9wdGlvbnMgfHwgJ29iamVjdCcgIT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnM7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0ID0gMDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZvcih2YXIgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBzd2l0Y2gob3B0aW9uKSB7XG4gICAgICBjYXNlICdkZWFkbGluZSc6XG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLmRlYWRsaW5lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jlc3BvbnNlJzpcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0ID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIHRpbWVvdXQgb3B0aW9uXCIsIG9wdGlvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgbnVtYmVyIG9mIHJldHJ5IGF0dGVtcHRzIG9uIGVycm9yLlxuICpcbiAqIEZhaWxlZCByZXF1ZXN0cyB3aWxsIGJlIHJldHJpZWQgJ2NvdW50JyB0aW1lcyBpZiB0aW1lb3V0IG9yIGVyci5jb2RlID49IDUwMC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmV0cnkgPSBmdW5jdGlvbiByZXRyeShjb3VudCwgZm4pe1xuICAvLyBEZWZhdWx0IHRvIDEgaWYgbm8gY291bnQgcGFzc2VkIG9yIHRydWVcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgY291bnQgPT09IHRydWUpIGNvdW50ID0gMTtcbiAgaWYgKGNvdW50IDw9IDApIGNvdW50ID0gMDtcbiAgdGhpcy5fbWF4UmV0cmllcyA9IGNvdW50O1xuICB0aGlzLl9yZXRyaWVzID0gMDtcbiAgdGhpcy5fcmV0cnlDYWxsYmFjayA9IGZuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBFUlJPUl9DT0RFUyA9IFtcbiAgJ0VDT05OUkVTRVQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VBRERSSU5GTycsXG4gICdFU09DS0VUVElNRURPVVQnXG5dO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWQuXG4gKiAoQm9ycm93ZWQgZnJvbSBzZWdtZW50aW8vc3VwZXJhZ2VudC1yZXRyeSlcbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IFtyZXNdXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9zaG91bGRSZXRyeSA9IGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gIGlmICghdGhpcy5fbWF4UmV0cmllcyB8fCB0aGlzLl9yZXRyaWVzKysgPj0gdGhpcy5fbWF4UmV0cmllcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5fcmV0cnlDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSB0aGlzLl9yZXRyeUNhbGxiYWNrKGVyciwgcmVzKTtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAob3ZlcnJpZGUgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyB1bmRlZmluZWQgZmFsbHMgYmFjayB0byBkZWZhdWx0c1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlcyAmJiByZXMuc3RhdHVzICYmIHJlcy5zdGF0dXMgPj0gNTAwICYmIHJlcy5zdGF0dXMgIT0gNTAxKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGVycikge1xuICAgIGlmIChlcnIuY29kZSAmJiB+RVJST1JfQ09ERVMuaW5kZXhPZihlcnIuY29kZSkpIHJldHVybiB0cnVlO1xuICAgIC8vIFN1cGVyYWdlbnQgdGltZW91dFxuICAgIGlmIChlcnIudGltZW91dCAmJiBlcnIuY29kZSA9PSAnRUNPTk5BQk9SVEVEJykgcmV0dXJuIHRydWU7XG4gICAgaWYgKGVyci5jcm9zc0RvbWFpbikgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXRyeSByZXF1ZXN0XG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3JldHJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICAvLyBub2RlXG4gIGlmICh0aGlzLnJlcSkge1xuICAgIHRoaXMucmVxID0gbnVsbDtcbiAgICB0aGlzLnJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB9XG5cbiAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlO1xuICB0aGlzLnRpbWVkb3V0ID0gZmFsc2U7XG5cbiAgcmV0dXJuIHRoaXMuX2VuZCgpO1xufTtcblxuLyoqXG4gKiBQcm9taXNlIHN1cHBvcnRcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVqZWN0XVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIHRoZW4ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gIGlmICghdGhpcy5fZnVsbGZpbGxlZFByb21pc2UpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX2VuZENhbGxlZCkge1xuICAgICAgY29uc29sZS53YXJuKFwiV2FybmluZzogc3VwZXJhZ2VudCByZXF1ZXN0IHdhcyBzZW50IHR3aWNlLCBiZWNhdXNlIGJvdGggLmVuZCgpIGFuZCAudGhlbigpIHdlcmUgY2FsbGVkLiBOZXZlciBjYWxsIC5lbmQoKSBpZiB5b3UgdXNlIHByb21pc2VzXCIpO1xuICAgIH1cbiAgICB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKGlubmVyUmVzb2x2ZSwgaW5uZXJSZWplY3QpIHtcbiAgICAgIHNlbGYuZW5kKGZ1bmN0aW9uKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIpIGlubmVyUmVqZWN0KGVycik7XG4gICAgICAgIGVsc2UgaW5uZXJSZXNvbHZlKHJlcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZnVsbGZpbGxlZFByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24oY2IpIHtcbiAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIGNiKTtcbn07XG5cbi8qKlxuICogQWxsb3cgZm9yIGV4dGVuc2lvblxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZm4pIHtcbiAgZm4odGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLm9rID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBjYikgdGhyb3cgRXJyb3IoXCJDYWxsYmFjayByZXF1aXJlZFwiKTtcbiAgdGhpcy5fb2tDYWxsYmFjayA9IGNiO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5faXNSZXNwb25zZU9LID0gZnVuY3Rpb24ocmVzKSB7XG4gIGlmICghcmVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX29rQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fb2tDYWxsYmFjayhyZXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcy5zdGF0dXMgPj0gMjAwICYmIHJlcy5zdGF0dXMgPCAzMDA7XG59O1xuXG4vKipcbiAqIEdldCByZXF1ZXN0IGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgcmV0dXJuIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgaGVhZGVyIGBmaWVsZGAgdmFsdWUuXG4gKiBUaGlzIGlzIGEgZGVwcmVjYXRlZCBpbnRlcm5hbCBBUEkuIFVzZSBgLmdldChmaWVsZClgIGluc3RlYWQuXG4gKlxuICogKGdldEhlYWRlciBpcyBubyBsb25nZXIgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBzdXBlcmFnZW50IGNvZGUgYmFzZSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gUmVxdWVzdEJhc2UucHJvdG90eXBlLmdldDtcblxuLyoqXG4gKiBTZXQgaGVhZGVyIGBmaWVsZGAgdG8gYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3QuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxuICogICAgICAgIC5zZXQoJ1gtQVBJLUtleScsICdmb29iYXInKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnNldCh7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLCAnWC1BUEktS2V5JzogJ2Zvb2JhcicgfSlcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGZpZWxkXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGZpZWxkLCB2YWwpe1xuICBpZiAoaXNPYmplY3QoZmllbGQpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGZpZWxkKSB7XG4gICAgICB0aGlzLnNldChrZXksIGZpZWxkW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV0gPSB2YWw7XG4gIHRoaXMuaGVhZGVyW2ZpZWxkXSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBoZWFkZXIgYGZpZWxkYC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxuICogICAgICAgIC51bnNldCgnVXNlci1BZ2VudCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uKGZpZWxkKXtcbiAgZGVsZXRlIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbiAgZGVsZXRlIHRoaXMuaGVhZGVyW2ZpZWxkXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBmaWVsZCBgbmFtZWAgYW5kIGB2YWxgLCBvciBtdWx0aXBsZSBmaWVsZHMgd2l0aCBvbmUgb2JqZWN0XG4gKiBmb3IgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgcmVxdWVzdCBib2RpZXMuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoJ2ZvbycsICdiYXInKVxuICogICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuZmllbGQoeyBmb286ICdiYXInLCBiYXo6ICdxdXgnIH0pXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV8QnVmZmVyfGZzLlJlYWRTdHJlYW19IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZmllbGQgPSBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgLy8gbmFtZSBzaG91bGQgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGFuIG9iamVjdC5cbiAgaWYgKG51bGwgPT09IG5hbWUgfHwgdW5kZWZpbmVkID09PSBuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSBuYW1lIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgY29uc29sZS5lcnJvcihcIi5maWVsZCgpIGNhbid0IGJlIHVzZWQgaWYgLnNlbmQoKSBpcyB1c2VkLiBQbGVhc2UgdXNlIG9ubHkgLnNlbmQoKSBvciBvbmx5IC5maWVsZCgpICYgLmF0dGFjaCgpXCIpO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KG5hbWUpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcbiAgICAgIHRoaXMuZmllbGQoa2V5LCBuYW1lW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICBmb3IgKHZhciBpIGluIHZhbCkge1xuICAgICAgdGhpcy5maWVsZChuYW1lLCB2YWxbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHZhbCBzaG91bGQgYmUgZGVmaW5lZCBub3dcbiAgaWYgKG51bGwgPT09IHZhbCB8fCB1bmRlZmluZWQgPT09IHZhbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignLmZpZWxkKG5hbWUsIHZhbCkgdmFsIGNhbiBub3QgYmUgZW1wdHknKTtcbiAgfVxuICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgdmFsKSB7XG4gICAgdmFsID0gJycgKyB2YWw7XG4gIH1cbiAgdGhpcy5fZ2V0Rm9ybURhdGEoKS5hcHBlbmQobmFtZSwgdmFsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFib3J0IHRoZSByZXF1ZXN0LCBhbmQgY2xlYXIgcG90ZW50aWFsIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGhpcy5fYWJvcnRlZCA9IHRydWU7XG4gIHRoaXMueGhyICYmIHRoaXMueGhyLmFib3J0KCk7IC8vIGJyb3dzZXJcbiAgdGhpcy5yZXEgJiYgdGhpcy5yZXEuYWJvcnQoKTsgLy8gbm9kZVxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICB0aGlzLmVtaXQoJ2Fib3J0Jyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucywgYmFzZTY0RW5jb2Rlcikge1xuICBzd2l0Y2ggKG9wdGlvbnMudHlwZSkge1xuICAgIGNhc2UgJ2Jhc2ljJzpcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBiYXNlNjRFbmNvZGVyKHVzZXIgKyAnOicgKyBwYXNzKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1dG8nOlxuICAgICAgdGhpcy51c2VybmFtZSA9IHVzZXI7XG4gICAgICB0aGlzLnBhc3N3b3JkID0gcGFzcztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmVhcmVyJzogLy8gdXNhZ2Ugd291bGQgYmUgLmF1dGgoYWNjZXNzVG9rZW4sIHsgdHlwZTogJ2JlYXJlcicgfSlcbiAgICAgIHRoaXMuc2V0KCdBdXRob3JpemF0aW9uJywgJ0JlYXJlciAnICsgdXNlcik7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5hYmxlIHRyYW5zbWlzc2lvbiBvZiBjb29raWVzIHdpdGggeC1kb21haW4gcmVxdWVzdHMuXG4gKlxuICogTm90ZSB0aGF0IGZvciB0aGlzIHRvIHdvcmsgdGhlIG9yaWdpbiBtdXN0IG5vdCBiZVxuICogdXNpbmcgXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIiB3aXRoIGEgd2lsZGNhcmQsXG4gKiBhbmQgYWxzbyBtdXN0IHNldCBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCJcbiAqIHRvIFwidHJ1ZVwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLndpdGhDcmVkZW50aWFscyA9IGZ1bmN0aW9uKG9uKSB7XG4gIC8vIFRoaXMgaXMgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uYWxpdHkuIE5vZGUgc2lkZSBpcyBuby1vcC5cbiAgaWYgKG9uID09IHVuZGVmaW5lZCkgb24gPSB0cnVlO1xuICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4IHJlZGlyZWN0cyB0byBgbmAuIERvZXMgbm90aW5nIGluIGJyb3dzZXIgWEhSIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnJlZGlyZWN0cyA9IGZ1bmN0aW9uKG4pe1xuICB0aGlzLl9tYXhSZWRpcmVjdHMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWF4aW11bSBzaXplIG9mIGJ1ZmZlcmVkIHJlc3BvbnNlIGJvZHksIGluIGJ5dGVzLiBDb3VudHMgdW5jb21wcmVzc2VkIHNpemUuXG4gKiBEZWZhdWx0IDIwME1CLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLm1heFJlc3BvbnNlU2l6ZSA9IGZ1bmN0aW9uKG4pe1xuICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiBuKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgfVxuICB0aGlzLl9tYXhSZXNwb25zZVNpemUgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydCB0byBhIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0IChub3QgSlNPTiBzdHJpbmcpIG9mIHNjYWxhciBwcm9wZXJ0aWVzLlxuICogTm90ZSBhcyB0aGlzIG1ldGhvZCBpcyBkZXNpZ25lZCB0byByZXR1cm4gYSB1c2VmdWwgbm9uLXRoaXMgdmFsdWUsXG4gKiBpdCBjYW5ub3QgYmUgY2hhaW5lZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlc2NyaWJpbmcgbWV0aG9kLCB1cmwsIGFuZCBkYXRhIG9mIHRoaXMgcmVxdWVzdFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB1cmw6IHRoaXMudXJsLFxuICAgIGRhdGE6IHRoaXMuX2RhdGEsXG4gICAgaGVhZGVyczogdGhpcy5faGVhZGVyLFxuICB9O1xufTtcblxuLyoqXG4gKiBTZW5kIGBkYXRhYCBhcyB0aGUgcmVxdWVzdCBib2R5LCBkZWZhdWx0aW5nIHRoZSBgLnR5cGUoKWAgdG8gXCJqc29uXCIgd2hlblxuICogYW4gb2JqZWN0IGlzIGdpdmVuLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgIC8vIG1hbnVhbCBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2pzb24nKVxuICogICAgICAgICAuc2VuZCgne1wibmFtZVwiOlwidGpcIn0nKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8ganNvblxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIG1hbnVhbCB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnZm9ybScpXG4gKiAgICAgICAgIC5zZW5kKCduYW1lPXRqJylcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBhdXRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gZGVmYXVsdHMgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKCduYW1lPXRvYmknKVxuICogICAgICAgIC5zZW5kKCdzcGVjaWVzPWZlcnJldCcpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgaXNPYmogPSBpc09iamVjdChkYXRhKTtcbiAgdmFyIHR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuXG4gIGlmICh0aGlzLl9mb3JtRGF0YSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCIuc2VuZCgpIGNhbid0IGJlIHVzZWQgaWYgLmF0dGFjaCgpIG9yIC5maWVsZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIik7XG4gIH1cblxuICBpZiAoaXNPYmogJiYgIXRoaXMuX2RhdGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChkYXRhICYmIHRoaXMuX2RhdGEgJiYgdGhpcy5faXNIb3N0KHRoaXMuX2RhdGEpKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJDYW4ndCBtZXJnZSB0aGVzZSBzZW5kIGNhbGxzXCIpO1xuICB9XG5cbiAgLy8gbWVyZ2VcbiAgaWYgKGlzT2JqICYmIGlzT2JqZWN0KHRoaXMuX2RhdGEpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgIHRoaXMuX2RhdGFba2V5XSA9IGRhdGFba2V5XTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICAvLyBkZWZhdWx0IHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICAgIGlmICghdHlwZSkgdGhpcy50eXBlKCdmb3JtJyk7XG4gICAgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG4gICAgaWYgKCdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnID09IHR5cGUpIHtcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhXG4gICAgICAgID8gdGhpcy5fZGF0YSArICcmJyArIGRhdGFcbiAgICAgICAgOiBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kYXRhID0gKHRoaXMuX2RhdGEgfHwgJycpICsgZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICBpZiAoIWlzT2JqIHx8IHRoaXMuX2lzSG9zdChkYXRhKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0byBqc29uXG4gIGlmICghdHlwZSkgdGhpcy50eXBlKCdqc29uJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTb3J0IGBxdWVyeXN0cmluZ2AgYnkgdGhlIHNvcnQgZnVuY3Rpb25cbiAqXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gZGVmYXVsdCBvcmRlclxuICogICAgICAgcmVxdWVzdC5nZXQoJy91c2VyJylcbiAqICAgICAgICAgLnF1ZXJ5KCduYW1lPU5pY2snKVxuICogICAgICAgICAucXVlcnkoJ3NlYXJjaD1NYW5ueScpXG4gKiAgICAgICAgIC5zb3J0UXVlcnkoKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGN1c3RvbWl6ZWQgc29ydCBmdW5jdGlvblxuICogICAgICAgcmVxdWVzdC5nZXQoJy91c2VyJylcbiAqICAgICAgICAgLnF1ZXJ5KCduYW1lPU5pY2snKVxuICogICAgICAgICAucXVlcnkoJ3NlYXJjaD1NYW5ueScpXG4gKiAgICAgICAgIC5zb3J0UXVlcnkoZnVuY3Rpb24oYSwgYil7XG4gKiAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNvcnRcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc29ydFF1ZXJ5ID0gZnVuY3Rpb24oc29ydCkge1xuICAvLyBfc29ydCBkZWZhdWx0IHRvIHRydWUgYnV0IG90aGVyd2lzZSBjYW4gYmUgYSBmdW5jdGlvbiBvciBib29sZWFuXG4gIHRoaXMuX3NvcnQgPSB0eXBlb2Ygc29ydCA9PT0gJ3VuZGVmaW5lZCcgPyB0cnVlIDogc29ydDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENvbXBvc2UgcXVlcnlzdHJpbmcgdG8gYXBwZW5kIHRvIHJlcS51cmxcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9maW5hbGl6ZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5fcXVlcnkuam9pbignJicpO1xuICBpZiAocXVlcnkpIHtcbiAgICB0aGlzLnVybCArPSAodGhpcy51cmwuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPycpICsgcXVlcnk7XG4gIH1cbiAgdGhpcy5fcXVlcnkubGVuZ3RoID0gMDsgLy8gTWFrZXMgdGhlIGNhbGwgaWRlbXBvdGVudFxuXG4gIGlmICh0aGlzLl9zb3J0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy51cmwuaW5kZXhPZignPycpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgcXVlcnlBcnIgPSB0aGlzLnVybC5zdWJzdHJpbmcoaW5kZXggKyAxKS5zcGxpdCgnJicpO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLl9zb3J0KSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQodGhpcy5fc29ydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWVyeUFyci5zb3J0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IHRoaXMudXJsLnN1YnN0cmluZygwLCBpbmRleCkgKyAnPycgKyBxdWVyeUFyci5qb2luKCcmJyk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBGb3IgYmFja3dhcmRzIGNvbXBhdCBvbmx5XG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2FwcGVuZFF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24oKSB7Y29uc29sZS50cmFjZShcIlVuc3VwcG9ydGVkXCIpO31cblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB0aW1lb3V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fdGltZW91dEVycm9yID0gZnVuY3Rpb24ocmVhc29uLCB0aW1lb3V0LCBlcnJubyl7XG4gIGlmICh0aGlzLl9hYm9ydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IocmVhc29uICsgdGltZW91dCArICdtcyBleGNlZWRlZCcpO1xuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XG4gIGVyci5jb2RlID0gJ0VDT05OQUJPUlRFRCc7XG4gIGVyci5lcnJubyA9IGVycm5vO1xuICB0aGlzLnRpbWVkb3V0ID0gdHJ1ZTtcbiAgdGhpcy5hYm9ydCgpO1xuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3NldFRpbWVvdXRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBkZWFkbGluZVxuICBpZiAodGhpcy5fdGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcbiAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignVGltZW91dCBvZiAnLCBzZWxmLl90aW1lb3V0LCAnRVRJTUUnKTtcbiAgICB9LCB0aGlzLl90aW1lb3V0KTtcbiAgfVxuICAvLyByZXNwb25zZSB0aW1lb3V0XG4gIGlmICh0aGlzLl9yZXNwb25zZVRpbWVvdXQgJiYgIXRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyKSB7XG4gICAgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBzZWxmLl90aW1lb3V0RXJyb3IoJ1Jlc3BvbnNlIHRpbWVvdXQgb2YgJywgc2VsZi5fcmVzcG9uc2VUaW1lb3V0LCAnRVRJTUVET1VUJyk7XG4gICAgfSwgdGhpcy5fcmVzcG9uc2VUaW1lb3V0KTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBFeHBvc2UgYFJlc3BvbnNlQmFzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZXNwb25zZUJhc2U7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VCYXNlYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlQmFzZShvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gUmVzcG9uc2VCYXNlLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gUmVzcG9uc2VCYXNlLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogR2V0IGNhc2UtaW5zZW5zaXRpdmUgYGZpZWxkYCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gdGhpcy5oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XG59O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgcmVsYXRlZCBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBgLnR5cGVgIHRoZSBjb250ZW50IHR5cGUgd2l0aG91dCBwYXJhbXNcbiAqXG4gKiBBIHJlc3BvbnNlIG9mIFwiQ29udGVudC1UeXBlOiB0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAqIHdpbGwgcHJvdmlkZSB5b3Ugd2l0aCBhIGAudHlwZWAgb2YgXCJ0ZXh0L3BsYWluXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKGhlYWRlcil7XG4gICAgLy8gVE9ETzogbW9hciFcbiAgICAvLyBUT0RPOiBtYWtlIHRoaXMgYSB1dGlsXG5cbiAgICAvLyBjb250ZW50LXR5cGVcbiAgICB2YXIgY3QgPSBoZWFkZXJbJ2NvbnRlbnQtdHlwZSddIHx8ICcnO1xuICAgIHRoaXMudHlwZSA9IHV0aWxzLnR5cGUoY3QpO1xuXG4gICAgLy8gcGFyYW1zXG4gICAgdmFyIHBhcmFtcyA9IHV0aWxzLnBhcmFtcyhjdCk7XG4gICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykgdGhpc1trZXldID0gcGFyYW1zW2tleV07XG5cbiAgICB0aGlzLmxpbmtzID0ge307XG5cbiAgICAvLyBsaW5rc1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChoZWFkZXIubGluaykge1xuICAgICAgICAgICAgdGhpcy5saW5rcyA9IHV0aWxzLnBhcnNlTGlua3MoaGVhZGVyLmxpbmspO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgIH1cbn07XG5cbi8qKlxuICogU2V0IGZsYWdzIHN1Y2ggYXMgYC5va2AgYmFzZWQgb24gYHN0YXR1c2AuXG4gKlxuICogRm9yIGV4YW1wbGUgYSAyeHggcmVzcG9uc2Ugd2lsbCBnaXZlIHlvdSBhIGAub2tgIG9mIF9fdHJ1ZV9fXG4gKiB3aGVyZWFzIDV4eCB3aWxsIGJlIF9fZmFsc2VfXyBhbmQgYC5lcnJvcmAgd2lsbCBiZSBfX3RydWVfXy4gVGhlXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcbiAqIHNwZWNpZmljLCBhbmQgYC5zdGF0dXNUeXBlYCBpcyB0aGUgY2xhc3Mgb2YgZXJyb3IgcmFuZ2luZyBmcm9tIDEuLjVcbiAqIHNvbWV0aW1lcyB1c2VmdWwgZm9yIG1hcHBpbmcgcmVzcG9uZCBjb2xvcnMgZXRjLlxuICpcbiAqIFwic3VnYXJcIiBwcm9wZXJ0aWVzIGFyZSBhbHNvIGRlZmluZWQgZm9yIGNvbW1vbiBjYXNlcy4gQ3VycmVudGx5IHByb3ZpZGluZzpcbiAqXG4gKiAgIC0gLm5vQ29udGVudFxuICogICAtIC5iYWRSZXF1ZXN0XG4gKiAgIC0gLnVuYXV0aG9yaXplZFxuICogICAtIC5ub3RBY2NlcHRhYmxlXG4gKiAgIC0gLm5vdEZvdW5kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVzcG9uc2VCYXNlLnByb3RvdHlwZS5fc2V0U3RhdHVzUHJvcGVydGllcyA9IGZ1bmN0aW9uKHN0YXR1cyl7XG4gICAgdmFyIHR5cGUgPSBzdGF0dXMgLyAxMDAgfCAwO1xuXG4gICAgLy8gc3RhdHVzIC8gY2xhc3NcbiAgICB0aGlzLnN0YXR1cyA9IHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1R5cGUgPSB0eXBlO1xuXG4gICAgLy8gYmFzaWNzXG4gICAgdGhpcy5pbmZvID0gMSA9PSB0eXBlO1xuICAgIHRoaXMub2sgPSAyID09IHR5cGU7XG4gICAgdGhpcy5yZWRpcmVjdCA9IDMgPT0gdHlwZTtcbiAgICB0aGlzLmNsaWVudEVycm9yID0gNCA9PSB0eXBlO1xuICAgIHRoaXMuc2VydmVyRXJyb3IgPSA1ID09IHR5cGU7XG4gICAgdGhpcy5lcnJvciA9ICg0ID09IHR5cGUgfHwgNSA9PSB0eXBlKVxuICAgICAgICA/IHRoaXMudG9FcnJvcigpXG4gICAgICAgIDogZmFsc2U7XG5cbiAgICAvLyBzdWdhclxuICAgIHRoaXMuY3JlYXRlZCA9IDIwMSA9PSBzdGF0dXM7XG4gICAgdGhpcy5hY2NlcHRlZCA9IDIwMiA9PSBzdGF0dXM7XG4gICAgdGhpcy5ub0NvbnRlbnQgPSAyMDQgPT0gc3RhdHVzO1xuICAgIHRoaXMuYmFkUmVxdWVzdCA9IDQwMCA9PSBzdGF0dXM7XG4gICAgdGhpcy51bmF1dGhvcml6ZWQgPSA0MDEgPT0gc3RhdHVzO1xuICAgIHRoaXMubm90QWNjZXB0YWJsZSA9IDQwNiA9PSBzdGF0dXM7XG4gICAgdGhpcy5mb3JiaWRkZW4gPSA0MDMgPT0gc3RhdHVzO1xuICAgIHRoaXMubm90Rm91bmQgPSA0MDQgPT0gc3RhdHVzO1xuICAgIHRoaXMudW5wcm9jZXNzYWJsZUVudGl0eSA9IDQyMiA9PSBzdGF0dXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbWltZSB0eXBlIGZvciB0aGUgZ2l2ZW4gYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICo7ICovKS5zaGlmdCgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gaGVhZGVyIGZpZWxkIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJhbXMgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKjsgKi8pLnJlZHVjZShmdW5jdGlvbihvYmosIHN0cil7XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKj0gKi8pO1xuICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuICAgIHZhciB2YWwgPSBwYXJ0cy5zaGlmdCgpO1xuXG4gICAgaWYgKGtleSAmJiB2YWwpIG9ialtrZXldID0gdmFsO1xuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbn07XG5cbi8qKlxuICogUGFyc2UgTGluayBoZWFkZXIgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucGFyc2VMaW5rcyA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqLCAqLykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgc3RyKXtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqOyAqLyk7XG4gICAgdmFyIHVybCA9IHBhcnRzWzBdLnNsaWNlKDEsIC0xKTtcbiAgICB2YXIgcmVsID0gcGFydHNbMV0uc3BsaXQoLyAqPSAqLylbMV0uc2xpY2UoMSwgLTEpO1xuICAgIG9ialtyZWxdID0gdXJsO1xuICAgIHJldHVybiBvYmo7XG4gIH0sIHt9KTtcbn07XG5cbi8qKlxuICogU3RyaXAgY29udGVudCByZWxhdGVkIGZpZWxkcyBmcm9tIGBoZWFkZXJgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcbiAqIEByZXR1cm4ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmNsZWFuSGVhZGVyID0gZnVuY3Rpb24oaGVhZGVyLCBjaGFuZ2VzT3JpZ2luKXtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC10eXBlJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ3RyYW5zZmVyLWVuY29kaW5nJ107XG4gIGRlbGV0ZSBoZWFkZXJbJ2hvc3QnXTtcbiAgLy8gc2VjdWlydHlcbiAgaWYgKGNoYW5nZXNPcmlnaW4pIHtcbiAgICBkZWxldGUgaGVhZGVyWydhdXRob3JpemF0aW9uJ107XG4gICAgZGVsZXRlIGhlYWRlclsnY29va2llJ107XG4gIH1cbiAgcmV0dXJuIGhlYWRlcjtcbn07XG4iLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiIsImV4cG9ydCBmdW5jdGlvbiBtZXJnZSguLi5zZXRzOkFycmF5PHN0cmluZz4pOnN0cmluZyB7XG5cdGlmIChzZXRzLmxlbmd0aCA+IDEpIHtcblx0XHRzZXRzWzBdID0gc2V0c1swXS5zbGljZSgwLCAtMSk7XG5cdFx0Y29uc3QgeGwgPSBzZXRzLmxlbmd0aCAtIDE7XG5cdFx0Zm9yIChsZXQgeCA9IDE7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRzZXRzW3hdID0gc2V0c1t4XS5zbGljZSgxLCAtMSk7XG5cdFx0fVxuXHRcdHNldHNbeGxdID0gc2V0c1t4bF0uc2xpY2UoMSk7XG5cdFx0cmV0dXJuIHNldHMuam9pbignJyk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHNldHNbMF07XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YmV4cChzdHI6c3RyaW5nKTpzdHJpbmcge1xuXHRyZXR1cm4gXCIoPzpcIiArIHN0ciArIFwiKVwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHlwZU9mKG86YW55KTpzdHJpbmcge1xuXHRyZXR1cm4gbyA9PT0gdW5kZWZpbmVkID8gXCJ1bmRlZmluZWRcIiA6IChvID09PSBudWxsID8gXCJudWxsXCIgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc3BsaXQoXCIgXCIpLnBvcCgpLnNwbGl0KFwiXVwiKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9VcHBlckNhc2Uoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0cmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9BcnJheShvYmo6YW55KTpBcnJheTxhbnk+IHtcblx0cmV0dXJuIG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gbnVsbCA/IChvYmogaW5zdGFuY2VvZiBBcnJheSA/IG9iaiA6ICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gXCJudW1iZXJcIiB8fCBvYmouc3BsaXQgfHwgb2JqLnNldEludGVydmFsIHx8IG9iai5jYWxsID8gW29ial0gOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopKSkgOiBbXTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldDogb2JqZWN0LCBzb3VyY2U6IGFueSk6IGFueSB7XG5cdGNvbnN0IG9iaiA9IHRhcmdldCBhcyBhbnk7XG5cdGlmIChzb3VyY2UpIHtcblx0XHRmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdG9ialtrZXldID0gc291cmNlW2tleV07XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvYmo7XG59IiwiaW1wb3J0IHsgVVJJUmVnRXhwcyB9IGZyb20gXCIuL3VyaVwiO1xuaW1wb3J0IHsgbWVyZ2UsIHN1YmV4cCB9IGZyb20gXCIuL3V0aWxcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRXhwcyhpc0lSSTpib29sZWFuKTpVUklSZWdFeHBzIHtcblx0Y29uc3Rcblx0XHRBTFBIQSQkID0gXCJbQS1aYS16XVwiLFxuXHRcdENSJCA9IFwiW1xcXFx4MERdXCIsXG5cdFx0RElHSVQkJCA9IFwiWzAtOV1cIixcblx0XHREUVVPVEUkJCA9IFwiW1xcXFx4MjJdXCIsXG5cdFx0SEVYRElHJCQgPSBtZXJnZShESUdJVCQkLCBcIltBLUZhLWZdXCIpLCAgLy9jYXNlLWluc2Vuc2l0aXZlXG5cdFx0TEYkJCA9IFwiW1xcXFx4MEFdXCIsXG5cdFx0U1AkJCA9IFwiW1xcXFx4MjBdXCIsXG5cdFx0UENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpLCAgLy9leHBhbmRlZFxuXHRcdEdFTl9ERUxJTVMkJCA9IFwiW1xcXFw6XFxcXC9cXFxcP1xcXFwjXFxcXFtcXFxcXVxcXFxAXVwiLFxuXHRcdFNVQl9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJlxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXD1dXCIsXG5cdFx0UkVTRVJWRUQkJCA9IG1lcmdlKEdFTl9ERUxJTVMkJCwgU1VCX0RFTElNUyQkKSxcblx0XHRVQ1NDSEFSJCQgPSBpc0lSSSA/IFwiW1xcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl1cIiA6IFwiW11cIiwgIC8vc3Vic2V0LCBleGNsdWRlcyBiaWRpIGNvbnRyb2wgY2hhcmFjdGVyc1xuXHRcdElQUklWQVRFJCQgPSBpc0lSSSA/IFwiW1xcXFx1RTAwMC1cXFxcdUY4RkZdXCIgOiBcIltdXCIsICAvL3N1YnNldFxuXHRcdFVOUkVTRVJWRUQkJCA9IG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwtXFxcXC5cXFxcX1xcXFx+XVwiLCBVQ1NDSEFSJCQpLFxuXHRcdFNDSEVNRSQgPSBzdWJleHAoQUxQSEEkJCArIG1lcmdlKEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIikgKyBcIipcIiksXG5cdFx0VVNFUklORk8kID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikpICsgXCIqXCIpLFxuXHRcdERFQ19PQ1RFVCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCJbMS05XVwiICsgRElHSVQkJCkgKyBcInxcIiArIERJR0lUJCQpLFxuXHRcdERFQ19PQ1RFVF9SRUxBWEVEJCA9IHN1YmV4cChzdWJleHAoXCIyNVswLTVdXCIpICsgXCJ8XCIgKyBzdWJleHAoXCIyWzAtNF1cIiArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIxXCIgKyBESUdJVCQkICsgRElHSVQkJCkgKyBcInxcIiArIHN1YmV4cChcIjA/WzEtOV1cIiArIERJR0lUJCQpICsgXCJ8MD8wP1wiICsgRElHSVQkJCksICAvL3JlbGF4ZWQgcGFyc2luZyBydWxlc1xuXHRcdElQVjRBRERSRVNTJCA9IHN1YmV4cChERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQgKyBcIlxcXFwuXCIgKyBERUNfT0NURVRfUkVMQVhFRCQpLFxuXHRcdEgxNiQgPSBzdWJleHAoSEVYRElHJCQgKyBcInsxLDR9XCIpLFxuXHRcdExTMzIkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiICsgSDE2JCkgKyBcInxcIiArIElQVjRBRERSRVNTJCksXG5cdFx0SVBWNkFERFJFU1MxJCA9IHN1YmV4cCggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns2fVwiICsgTFMzMiQpLCAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIDYoIGgxNiBcIjpcIiApIGxzMzJcblx0XHRJUFY2QUREUkVTUzIkID0gc3ViZXhwKCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezV9XCIgKyBMUzMyJCksIC8vICAgICAgICAgICAgICAgICAgICAgIFwiOjpcIiA1KCBoMTYgXCI6XCIgKSBsczMyXG5cdFx0SVBWNkFERFJFU1MzJCA9IHN1YmV4cChzdWJleHAoICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns0fVwiICsgTFMzMiQpLCAvL1sgICAgICAgICAgICAgICBoMTYgXSBcIjo6XCIgNCggaDE2IFwiOlwiICkgbHMzMlxuXHRcdElQVjZBRERSRVNTNCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7M31cIiArIExTMzIkKSwgLy9bICoxKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMyggaDE2IFwiOlwiICkgbHMzMlxuXHRcdElQVjZBRERSRVNTNSQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMn1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7Mn1cIiArIExTMzIkKSwgLy9bICoyKCBoMTYgXCI6XCIgKSBoMTYgXSBcIjo6XCIgMiggaDE2IFwiOlwiICkgbHMzMlxuXHRcdElQVjZBRERSRVNTNiQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsM31cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgICAgICAgIEgxNiQgKyBcIlxcXFw6XCIgICAgICAgICAgKyBMUzMyJCksIC8vWyAqMyggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgIGgxNiBcIjpcIiAgIGxzMzJcblx0XHRJUFY2QUREUkVTUzckID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDR9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBMUzMyJCksIC8vWyAqNCggaDE2IFwiOlwiICkgaDE2IF0gXCI6OlwiICAgICAgICAgICAgICBsczMyXG5cdFx0SVBWNkFERFJFU1M4JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw1fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgSDE2JCApLCAvL1sgKjUoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIiAgICAgICAgICAgICAgaDE2XG5cdFx0SVBWNkFERFJFU1M5JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCw2fVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLCAvL1sgKjYoIGgxNiBcIjpcIiApIGgxNiBdIFwiOjpcIlxuXHRcdElQVjZBRERSRVNTJCA9IHN1YmV4cChbSVBWNkFERFJFU1MxJCwgSVBWNkFERFJFU1MyJCwgSVBWNkFERFJFU1MzJCwgSVBWNkFERFJFU1M0JCwgSVBWNkFERFJFU1M1JCwgSVBWNkFERFJFU1M2JCwgSVBWNkFERFJFU1M3JCwgSVBWNkFERFJFU1M4JCwgSVBWNkFERFJFU1M5JF0uam9pbihcInxcIikpLFxuXHRcdFpPTkVJRCQgPSBzdWJleHAoc3ViZXhwKFVOUkVTRVJWRUQkJCArIFwifFwiICsgUENUX0VOQ09ERUQkKSArIFwiK1wiKSwgIC8vUkZDIDY4NzRcblx0XHRJUFY2QUREUlokID0gc3ViZXhwKElQVjZBRERSRVNTJCArIFwiXFxcXCUyNVwiICsgWk9ORUlEJCksICAvL1JGQyA2ODc0XG5cdFx0SVBWNkFERFJaX1JFTEFYRUQkID0gc3ViZXhwKElQVjZBRERSRVNTJCArIHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkICsgXCJ7Mn0pXCIpICsgWk9ORUlEJCksICAvL1JGQyA2ODc0LCB3aXRoIHJlbGF4ZWQgcGFyc2luZyBydWxlc1xuXHRcdElQVkZVVFVSRSQgPSBzdWJleHAoXCJbdlZdXCIgKyBIRVhESUckJCArIFwiK1xcXFwuXCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpdXCIpICsgXCIrXCIpLFxuXHRcdElQX0xJVEVSQUwkID0gc3ViZXhwKFwiXFxcXFtcIiArIHN1YmV4cChJUFY2QUREUlpfUkVMQVhFRCQgKyBcInxcIiArIElQVjZBRERSRVNTJCArIFwifFwiICsgSVBWRlVUVVJFJCkgKyBcIlxcXFxdXCIpLCAgLy9SRkMgNjg3NFxuXHRcdFJFR19OQU1FJCA9IHN1YmV4cChzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCkpICsgXCIqXCIpLFxuXHRcdEhPU1QkID0gc3ViZXhwKElQX0xJVEVSQUwkICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQgKyBcIig/IVwiICsgUkVHX05BTUUkICsgXCIpXCIgKyBcInxcIiArIFJFR19OQU1FJCksXG5cdFx0UE9SVCQgPSBzdWJleHAoRElHSVQkJCArIFwiKlwiKSxcblx0XHRBVVRIT1JJVFkkID0gc3ViZXhwKHN1YmV4cChVU0VSSU5GTyQgKyBcIkBcIikgKyBcIj9cIiArIEhPU1QkICsgc3ViZXhwKFwiXFxcXDpcIiArIFBPUlQkKSArIFwiP1wiKSxcblx0XHRQQ0hBUiQgPSBzdWJleHAoUENUX0VOQ09ERUQkICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQF1cIikpLFxuXHRcdFNFR01FTlQkID0gc3ViZXhwKFBDSEFSJCArIFwiKlwiKSxcblx0XHRTRUdNRU5UX05aJCA9IHN1YmV4cChQQ0hBUiQgKyBcIitcIiksXG5cdFx0U0VHTUVOVF9OWl9OQyQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJCArIFwifFwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQsIFwiW1xcXFxAXVwiKSkgKyBcIitcIiksXG5cdFx0UEFUSF9BQkVNUFRZJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1wiICsgU0VHTUVOVCQpICsgXCIqXCIpLFxuXHRcdFBBVEhfQUJTT0xVVEUkID0gc3ViZXhwKFwiXFxcXC9cIiArIHN1YmV4cChTRUdNRU5UX05aJCArIFBBVEhfQUJFTVBUWSQpICsgXCI/XCIpLCAgLy9zaW1wbGlmaWVkXG5cdFx0UEFUSF9OT1NDSEVNRSQgPSBzdWJleHAoU0VHTUVOVF9OWl9OQyQgKyBQQVRIX0FCRU1QVFkkKSwgIC8vc2ltcGxpZmllZFxuXHRcdFBBVEhfUk9PVExFU1MkID0gc3ViZXhwKFNFR01FTlRfTlokICsgUEFUSF9BQkVNUFRZJCksICAvL3NpbXBsaWZpZWRcblx0XHRQQVRIX0VNUFRZJCA9IFwiKD8hXCIgKyBQQ0hBUiQgKyBcIilcIixcblx0XHRQQVRIJCA9IHN1YmV4cChQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG5cdFx0UVVFUlkkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxcIiArIG1lcmdlKFwiW1xcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpKSArIFwiKlwiKSxcblx0XHRGUkFHTUVOVCQgPSBzdWJleHAoc3ViZXhwKFBDSEFSJCArIFwifFtcXFxcL1xcXFw/XVwiKSArIFwiKlwiKSxcblx0XHRISUVSX1BBUlQkID0gc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC9cIiArIEFVVEhPUklUWSQgKyBQQVRIX0FCRU1QVFkkKSArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCksXG5cdFx0VVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSxcblx0XHRSRUxBVElWRV9QQVJUJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvXCIgKyBBVVRIT1JJVFkkICsgUEFUSF9BQkVNUFRZJCkgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQpLFxuXHRcdFJFTEFUSVZFJCA9IHN1YmV4cChSRUxBVElWRV9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSxcblx0XHRVUklfUkVGRVJFTkNFJCA9IHN1YmV4cChVUkkkICsgXCJ8XCIgKyBSRUxBVElWRSQpLFxuXHRcdEFCU09MVVRFX1VSSSQgPSBzdWJleHAoU0NIRU1FJCArIFwiXFxcXDpcIiArIEhJRVJfUEFSVCQgKyBzdWJleHAoXCJcXFxcP1wiICsgUVVFUlkkKSArIFwiP1wiKSxcblxuXHRcdEdFTkVSSUNfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIixcblx0XHRSRUxBVElWRV9SRUYkID0gXCJeKCl7MH1cIiArIHN1YmV4cChzdWJleHAoXCJcXFxcL1xcXFwvKFwiICsgc3ViZXhwKFwiKFwiICsgVVNFUklORk8kICsgXCIpQFwiKSArIFwiPyhcIiArIEhPU1QkICsgXCIpXCIgKyBzdWJleHAoXCJcXFxcOihcIiArIFBPUlQkICsgXCIpXCIpICsgXCI/KVwiKSArIFwiPyhcIiArIFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9FTVBUWSQgKyBcIilcIikgKyBzdWJleHAoXCJcXFxcPyhcIiArIFFVRVJZJCArIFwiKVwiKSArIFwiP1wiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG5cdFx0QUJTT0xVVEVfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/JFwiLFxuXHRcdFNBTUVET0NfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsXG5cdFx0QVVUSE9SSVRZX1JFRiQgPSBcIl5cIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPyRcIlxuXHQ7XG5cblx0cmV0dXJuIHtcblx0XHROT1RfU0NIRU1FIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcK1xcXFwtXFxcXC5dXCIpLCBcImdcIiksXG5cdFx0Tk9UX1VTRVJJTkZPIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG5cdFx0Tk9UX0hPU1QgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFxbXFxcXF1cXFxcOl1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG5cdFx0Tk9UX1BBVEggOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXDpcXFxcQF1cIiwgVU5SRVNFUlZFRCQkLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG5cdFx0Tk9UX1BBVEhfTk9TQ0hFTUUgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFwvXFxcXEBdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdE5PVF9RVUVSWSA6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQFxcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpLCBcImdcIiksXG5cdFx0Tk9UX0ZSQUdNRU5UIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkLCBcIltcXFxcOlxcXFxAXFxcXC9cXFxcP11cIiksIFwiZ1wiKSxcblx0XHRFU0NBUEUgOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuXHRcdFVOUkVTRVJWRUQgOiBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpLFxuXHRcdE9USEVSX0NIQVJTIDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVdXCIsIFVOUkVTRVJWRUQkJCwgUkVTRVJWRUQkJCksIFwiZ1wiKSxcblx0XHRQQ1RfRU5DT0RFRCA6IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIiksXG5cdFx0SVBWNEFERFJFU1MgOiBuZXcgUmVnRXhwKFwiXihcIiArIElQVjRBRERSRVNTJCArIFwiKSRcIiksXG5cdFx0SVBWNkFERFJFU1MgOiBuZXcgUmVnRXhwKFwiXlxcXFxbPyhcIiArIElQVjZBRERSRVNTJCArIFwiKVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkICsgXCJ7Mn0pXCIpICsgXCIoXCIgKyBaT05FSUQkICsgXCIpXCIpICsgXCI/XFxcXF0/JFwiKSAgLy9SRkMgNjg3NCwgd2l0aCByZWxheGVkIHBhcnNpbmcgcnVsZXNcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYnVpbGRFeHBzKGZhbHNlKTtcbiIsImltcG9ydCB7IFVSSVJlZ0V4cHMgfSBmcm9tIFwiLi91cmlcIjtcbmltcG9ydCB7IGJ1aWxkRXhwcyB9IGZyb20gXCIuL3JlZ2V4cHMtdXJpXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGJ1aWxkRXhwcyh0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuY29uc3QgbWF4SW50ID0gMjE0NzQ4MzY0NzsgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG4vKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5jb25zdCBiYXNlID0gMzY7XG5jb25zdCB0TWluID0gMTtcbmNvbnN0IHRNYXggPSAyNjtcbmNvbnN0IHNrZXcgPSAzODtcbmNvbnN0IGRhbXAgPSA3MDA7XG5jb25zdCBpbml0aWFsQmlhcyA9IDcyO1xuY29uc3QgaW5pdGlhbE4gPSAxMjg7IC8vIDB4ODBcbmNvbnN0IGRlbGltaXRlciA9ICctJzsgLy8gJ1xceDJEJ1xuXG4vKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuY29uc3QgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS87XG5jb25zdCByZWdleE5vbkFTQ0lJID0gL1teXFwwLVxceDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xuY29uc3QgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4vKiogRXJyb3IgbWVzc2FnZXMgKi9cbmNvbnN0IGVycm9ycyA9IHtcblx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcbn07XG5cbi8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cbmNvbnN0IGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbmNvbnN0IGZsb29yID0gTWF0aC5mbG9vcjtcbmNvbnN0IHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vKipcbiAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG59XG5cbi8qKlxuICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuICogaXRlbS5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRjb25zdCByZXN1bHQgPSBbXTtcblx0bGV0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuICogYWRkcmVzc2VzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAqIGNoYXJhY3Rlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0Y29uc3QgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0bGV0IHJlc3VsdCA9ICcnO1xuXHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHR9XG5cdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0Y29uc3QgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdGNvbnN0IGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4gKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG4gKiBtYXRjaGluZyBVVEYtMTYuXG4gKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcbiAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAqIEBuYW1lIGRlY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0Y29uc3Qgb3V0cHV0ID0gW107XG5cdGxldCBjb3VudGVyID0gMDtcblx0Y29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRjb25zdCB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0Ly8gSXQncyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cblx0XHRcdGNvbnN0IGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBMb3cgc3Vycm9nYXRlLlxuXHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSXQncyBhbiB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGVcblx0XHRcdFx0Ly8gbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG4gKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICogQG5hbWUgZW5jb2RlXG4gKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuICovXG5jb25zdCB1Y3MyZW5jb2RlID0gYXJyYXkgPT4gU3RyaW5nLmZyb21Db2RlUG9pbnQoLi4uYXJyYXkpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cbiAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG4gKi9cbmNvbnN0IGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xuXHRpZiAoY29kZVBvaW50IC0gMHgzMCA8IDB4MEEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHgxNjtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg0MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg0MTtcblx0fVxuXHRpZiAoY29kZVBvaW50IC0gMHg2MSA8IDB4MUEpIHtcblx0XHRyZXR1cm4gY29kZVBvaW50IC0gMHg2MTtcblx0fVxuXHRyZXR1cm4gYmFzZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG4gKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAqL1xuY29uc3QgZGlnaXRUb0Jhc2ljID0gZnVuY3Rpb24oZGlnaXQsIGZsYWcpIHtcblx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgYWRhcHQgPSBmdW5jdGlvbihkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0bGV0IGsgPSAwO1xuXHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHR9XG5cdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuICogc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICovXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHQvLyBEb24ndCB1c2UgVUNTLTIuXG5cdGNvbnN0IG91dHB1dCA9IFtdO1xuXHRjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0bGV0IGkgPSAwO1xuXHRsZXQgbiA9IGluaXRpYWxOO1xuXHRsZXQgYmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRsZXQgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0YmFzaWMgPSAwO1xuXHR9XG5cblx0Zm9yIChsZXQgaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdH1cblx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0fVxuXG5cdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRmb3IgKGxldCBpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0bGV0IG9sZGkgPSBpO1xuXHRcdGZvciAobGV0IHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdGNvbnN0IHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHR9XG5cblx0XHRjb25zdCBvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHR9XG5cblx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdGkgJT0gb3V0O1xuXG5cdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dC5cblx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0fVxuXG5cdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5vdXRwdXQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG5jb25zdCBlbmNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuXHRjb25zdCBvdXRwdXQgPSBbXTtcblxuXHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuXHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdC8vIENhY2hlIHRoZSBsZW5ndGguXG5cdGxldCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cblx0bGV0IG4gPSBpbml0aWFsTjtcblx0bGV0IGRlbHRhID0gMDtcblx0bGV0IGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuXHRmb3IgKGNvbnN0IGN1cnJlbnRWYWx1ZSBvZiBpbnB1dCkge1xuXHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0fVxuXHR9XG5cblx0bGV0IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblx0bGV0IGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7XG5cblx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyB3aXRoIGEgZGVsaW1pdGVyIHVubGVzcyBpdCdzIGVtcHR5LlxuXHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHR9XG5cblx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0bGV0IG0gPSBtYXhJbnQ7XG5cdFx0Zm9yIChjb25zdCBjdXJyZW50VmFsdWUgb2YgaW5wdXQpIHtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93LlxuXHRcdGNvbnN0IGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0fVxuXG5cdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRuID0gbTtcblxuXHRcdGZvciAoY29uc3QgY3VycmVudFZhbHVlIG9mIGlucHV0KSB7XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuXHRcdFx0XHRsZXQgcSA9IGRlbHRhO1xuXHRcdFx0XHRmb3IgKGxldCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRjb25zdCB0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0Y29uc3QgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdCsrZGVsdGE7XG5cdFx0KytuO1xuXG5cdH1cblx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICogY29udmVydCB0byBVbmljb2RlLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gKiBzdHJpbmcuXG4gKi9cbmNvbnN0IHRvVW5pY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG5cdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHQ6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG4gKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAqIEFTQ0lJLlxuICogQG1lbWJlck9mIHB1bnljb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICogVW5pY29kZSBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG4gKiBlbWFpbCBhZGRyZXNzLlxuICovXG5jb25zdCB0b0FTQ0lJID0gZnVuY3Rpb24oaW5wdXQpIHtcblx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHQ6IHN0cmluZztcblx0fSk7XG59O1xuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuY29uc3QgcHVueWNvZGUgPSB7XG5cdC8qKlxuXHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAdHlwZSBTdHJpbmdcblx0ICovXG5cdCd2ZXJzaW9uJzogJzIuMS4wJyxcblx0LyoqXG5cdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHQndWNzMic6IHtcblx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHR9LFxuXHQnZGVjb2RlJzogZGVjb2RlLFxuXHQnZW5jb2RlJzogZW5jb2RlLFxuXHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHB1bnljb2RlO1xuIiwiLyoqXG4gKiBVUkkuanNcbiAqXG4gKiBAZmlsZW92ZXJ2aWV3IEFuIFJGQyAzOTg2IGNvbXBsaWFudCwgc2NoZW1lIGV4dGVuZGFibGUgVVJJIHBhcnNpbmcvdmFsaWRhdGluZy9yZXNvbHZpbmcgbGlicmFyeSBmb3IgSmF2YVNjcmlwdC5cbiAqIEBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpnYXJ5LmNvdXJ0QGdtYWlsLmNvbVwiPkdhcnkgQ291cnQ8L2E+XG4gKiBAc2VlIGh0dHA6Ly9naXRodWIuY29tL2dhcnljb3VydC91cmktanNcbiAqL1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDExIEdhcnkgQ291cnQuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlXG4gKiBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcbiAqXG4gKiAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZlxuICogICAgICAgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICpcbiAqICAgIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0XG4gKiAgICAgICBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFsc1xuICogICAgICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgR0FSWSBDT1VSVCBgYEFTIElTJycgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRURcbiAqIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkRcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBHQVJZIENPVVJUIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUlxuICogU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuICogQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElOR1xuICogTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGXG4gKiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBUaGUgdmlld3MgYW5kIGNvbmNsdXNpb25zIGNvbnRhaW5lZCBpbiB0aGUgc29mdHdhcmUgYW5kIGRvY3VtZW50YXRpb24gYXJlIHRob3NlIG9mIHRoZVxuICogYXV0aG9ycyBhbmQgc2hvdWxkIG5vdCBiZSBpbnRlcnByZXRlZCBhcyByZXByZXNlbnRpbmcgb2ZmaWNpYWwgcG9saWNpZXMsIGVpdGhlciBleHByZXNzZWRcbiAqIG9yIGltcGxpZWQsIG9mIEdhcnkgQ291cnQuXG4gKi9cblxuaW1wb3J0IFVSSV9QUk9UT0NPTCBmcm9tIFwiLi9yZWdleHBzLXVyaVwiO1xuaW1wb3J0IElSSV9QUk9UT0NPTCBmcm9tIFwiLi9yZWdleHBzLWlyaVwiO1xuaW1wb3J0IHB1bnljb2RlIGZyb20gXCJwdW55Y29kZVwiO1xuaW1wb3J0IHsgdG9VcHBlckNhc2UsIHR5cGVPZiwgYXNzaWduIH0gZnJvbSBcIi4vdXRpbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVSSUNvbXBvbmVudHMge1xuXHRzY2hlbWU/OnN0cmluZztcblx0dXNlcmluZm8/OnN0cmluZztcblx0aG9zdD86c3RyaW5nO1xuXHRwb3J0PzpudW1iZXJ8c3RyaW5nO1xuXHRwYXRoPzpzdHJpbmc7XG5cdHF1ZXJ5PzpzdHJpbmc7XG5cdGZyYWdtZW50PzpzdHJpbmc7XG5cdHJlZmVyZW5jZT86c3RyaW5nO1xuXHRlcnJvcj86c3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVSSU9wdGlvbnMge1xuXHRzY2hlbWU/OnN0cmluZztcblx0cmVmZXJlbmNlPzpzdHJpbmc7XG5cdHRvbGVyYW50Pzpib29sZWFuO1xuXHRhYnNvbHV0ZVBhdGg/OmJvb2xlYW47XG5cdGlyaT86Ym9vbGVhbjtcblx0dW5pY29kZVN1cHBvcnQ/OmJvb2xlYW47XG5cdGRvbWFpbkhvc3Q/OmJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVJJU2NoZW1lSGFuZGxlcjxDb21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyA9IFVSSUNvbXBvbmVudHMsIE9wdGlvbnMgZXh0ZW5kcyBVUklPcHRpb25zID0gVVJJT3B0aW9ucywgUGFyZW50Q29tcG9uZW50cyBleHRlbmRzIFVSSUNvbXBvbmVudHMgPSBVUklDb21wb25lbnRzPiB7XG5cdHNjaGVtZTpzdHJpbmc7XG5cdHBhcnNlKGNvbXBvbmVudHM6UGFyZW50Q29tcG9uZW50cywgb3B0aW9uczpPcHRpb25zKTpDb21wb25lbnRzO1xuXHRzZXJpYWxpemUoY29tcG9uZW50czpDb21wb25lbnRzLCBvcHRpb25zOk9wdGlvbnMpOlBhcmVudENvbXBvbmVudHM7XG5cdHVuaWNvZGVTdXBwb3J0Pzpib29sZWFuO1xuXHRkb21haW5Ib3N0Pzpib29sZWFuO1xuXHRhYnNvbHV0ZVBhdGg/OmJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVJJUmVnRXhwcyB7XG5cdE5PVF9TQ0hFTUUgOiBSZWdFeHAsXG5cdE5PVF9VU0VSSU5GTyA6IFJlZ0V4cCxcblx0Tk9UX0hPU1QgOiBSZWdFeHAsXG5cdE5PVF9QQVRIIDogUmVnRXhwLFxuXHROT1RfUEFUSF9OT1NDSEVNRSA6IFJlZ0V4cCxcblx0Tk9UX1FVRVJZIDogUmVnRXhwLFxuXHROT1RfRlJBR01FTlQgOiBSZWdFeHAsXG5cdEVTQ0FQRSA6IFJlZ0V4cCxcblx0VU5SRVNFUlZFRCA6IFJlZ0V4cCxcblx0T1RIRVJfQ0hBUlMgOiBSZWdFeHAsXG5cdFBDVF9FTkNPREVEIDogUmVnRXhwLFxuXHRJUFY0QUREUkVTUyA6IFJlZ0V4cCxcblx0SVBWNkFERFJFU1MgOiBSZWdFeHAsXG59XG5cbmV4cG9ydCBjb25zdCBTQ0hFTUVTOntbc2NoZW1lOnN0cmluZ106VVJJU2NoZW1lSGFuZGxlcn0gPSB7fTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBjdEVuY0NoYXIoY2hyOnN0cmluZyk6c3RyaW5nIHtcblx0Y29uc3QgYyA9IGNoci5jaGFyQ29kZUF0KDApO1xuXHRsZXQgZTpzdHJpbmc7XG5cblx0aWYgKGMgPCAxNikgZSA9IFwiJTBcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdGVsc2UgaWYgKGMgPCAxMjgpIGUgPSBcIiVcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdGVsc2UgaWYgKGMgPCAyMDQ4KSBlID0gXCIlXCIgKyAoKGMgPj4gNikgfCAxOTIpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoKGMgJiA2MykgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRlbHNlIGUgPSBcIiVcIiArICgoYyA+PiAxMikgfCAyMjQpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoKChjID4+IDYpICYgNjMpIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArIFwiJVwiICsgKChjICYgNjMpIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblxuXHRyZXR1cm4gZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBjdERlY0NoYXJzKHN0cjpzdHJpbmcpOnN0cmluZyB7XG5cdGxldCBuZXdTdHIgPSBcIlwiO1xuXHRsZXQgaSA9IDA7XG5cdGNvbnN0IGlsID0gc3RyLmxlbmd0aDtcblxuXHR3aGlsZSAoaSA8IGlsKSB7XG5cdFx0Y29uc3QgYyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDEsIDIpLCAxNik7XG5cblx0XHRpZiAoYyA8IDEyOCkge1xuXHRcdFx0bmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG5cdFx0XHRpICs9IDM7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGMgPj0gMTk0ICYmIGMgPCAyMjQpIHtcblx0XHRcdGlmICgoaWwgLSBpKSA+PSA2KSB7XG5cdFx0XHRcdGNvbnN0IGMyID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNCwgMiksIDE2KTtcblx0XHRcdFx0bmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChjICYgMzEpIDw8IDYpIHwgKGMyICYgNjMpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDYpO1xuXHRcdFx0fVxuXHRcdFx0aSArPSA2O1xuXHRcdH1cblx0XHRlbHNlIGlmIChjID49IDIyNCkge1xuXHRcdFx0aWYgKChpbCAtIGkpID49IDkpIHtcblx0XHRcdFx0Y29uc3QgYzIgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuXHRcdFx0XHRjb25zdCBjMyA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDcsIDIpLCAxNik7XG5cdFx0XHRcdG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDE1KSA8PCAxMikgfCAoKGMyICYgNjMpIDw8IDYpIHwgKGMzICYgNjMpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDkpO1xuXHRcdFx0fVxuXHRcdFx0aSArPSA5O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdG5ld1N0ciArPSBzdHIuc3Vic3RyKGksIDMpO1xuXHRcdFx0aSArPSAzO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdTdHI7XG59XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIHByb3RvY29sOlVSSVJlZ0V4cHMpIHtcblx0ZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZChzdHI6c3RyaW5nKTpzdHJpbmcge1xuXHRcdGNvbnN0IGRlY1N0ciA9IHBjdERlY0NoYXJzKHN0cik7XG5cdFx0cmV0dXJuICghZGVjU3RyLm1hdGNoKHByb3RvY29sLlVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyKTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRzLnNjaGVtZSkgY29tcG9uZW50cy5zY2hlbWUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfU0NIRU1FLCBcIlwiKTtcblx0aWYgKGNvbXBvbmVudHMudXNlcmluZm8gIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy51c2VyaW5mbyA9IFN0cmluZyhjb21wb25lbnRzLnVzZXJpbmZvKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9VU0VSSU5GTywgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXHRpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMuaG9zdCA9IFN0cmluZyhjb21wb25lbnRzLmhvc3QpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShwcm90b2NvbC5OT1RfSE9TVCwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXHRpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpIGNvbXBvbmVudHMucGF0aCA9IFN0cmluZyhjb21wb25lbnRzLnBhdGgpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoKGNvbXBvbmVudHMuc2NoZW1lID8gcHJvdG9jb2wuTk9UX1BBVEggOiBwcm90b2NvbC5OT1RfUEFUSF9OT1NDSEVNRSksIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcblx0aWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkgY29tcG9uZW50cy5xdWVyeSA9IFN0cmluZyhjb21wb25lbnRzLnF1ZXJ5KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKHByb3RvY29sLk5PVF9RVUVSWSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuXHRpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSBjb21wb25lbnRzLmZyYWdtZW50ID0gU3RyaW5nKGNvbXBvbmVudHMuZnJhZ21lbnQpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0ZSQUdNRU5ULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG5cblx0cmV0dXJuIGNvbXBvbmVudHM7XG59O1xuXG5mdW5jdGlvbiBfc3RyaXBMZWFkaW5nWmVyb3Moc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0cmV0dXJuIHN0ci5yZXBsYWNlKC9eMCooLiopLywgXCIkMVwiKSB8fCBcIjBcIjtcbn1cblxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjQoaG9zdDpzdHJpbmcsIHByb3RvY29sOlVSSVJlZ0V4cHMpOnN0cmluZyB7XG5cdGNvbnN0IG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjRBRERSRVNTKSB8fCBbXTtcblx0Y29uc3QgWywgYWRkcmVzc10gPSBtYXRjaGVzO1xuXHRcblx0aWYgKGFkZHJlc3MpIHtcblx0XHRyZXR1cm4gYWRkcmVzcy5zcGxpdChcIi5cIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykuam9pbihcIi5cIik7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGhvc3Q7XG5cdH1cbn1cblxuZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjYoaG9zdDpzdHJpbmcsIHByb3RvY29sOlVSSVJlZ0V4cHMpOnN0cmluZyB7XG5cdGNvbnN0IG1hdGNoZXMgPSBob3N0Lm1hdGNoKHByb3RvY29sLklQVjZBRERSRVNTKSB8fCBbXTtcblx0Y29uc3QgWywgYWRkcmVzcywgem9uZV0gPSBtYXRjaGVzO1xuXG5cdGlmIChhZGRyZXNzKSB7XG5cdFx0Y29uc3QgW2xhc3QsIGZpcnN0XSA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKS5zcGxpdCgnOjonKS5yZXZlcnNlKCk7XG5cdFx0Y29uc3QgZmlyc3RGaWVsZHMgPSBmaXJzdCA/IGZpcnN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKSA6IFtdO1xuXHRcdGNvbnN0IGxhc3RGaWVsZHMgPSBsYXN0LnNwbGl0KFwiOlwiKS5tYXAoX3N0cmlwTGVhZGluZ1plcm9zKTtcblx0XHRjb25zdCBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID0gcHJvdG9jb2wuSVBWNEFERFJFU1MudGVzdChsYXN0RmllbGRzW2xhc3RGaWVsZHMubGVuZ3RoIC0gMV0pO1xuXHRcdGNvbnN0IGZpZWxkQ291bnQgPSBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID8gNyA6IDg7XG5cdFx0Y29uc3QgbGFzdEZpZWxkc1N0YXJ0ID0gbGFzdEZpZWxkcy5sZW5ndGggLSBmaWVsZENvdW50O1xuXHRcdGNvbnN0IGZpZWxkcyA9IEFycmF5PHN0cmluZz4oZmllbGRDb3VudCk7XG5cblx0XHRmb3IgKGxldCB4ID0gMDsgeCA8IGZpZWxkQ291bnQ7ICsreCkge1xuXHRcdFx0ZmllbGRzW3hdID0gZmlyc3RGaWVsZHNbeF0gfHwgbGFzdEZpZWxkc1tsYXN0RmllbGRzU3RhcnQgKyB4XSB8fCAnJztcblx0XHR9XG5cblx0XHRpZiAoaXNMYXN0RmllbGRJUHY0QWRkcmVzcykge1xuXHRcdFx0ZmllbGRzW2ZpZWxkQ291bnQgLSAxXSA9IF9ub3JtYWxpemVJUHY0KGZpZWxkc1tmaWVsZENvdW50IC0gMV0sIHByb3RvY29sKTtcblx0XHR9XG5cblx0XHRjb25zdCBhbGxaZXJvRmllbGRzID0gZmllbGRzLnJlZHVjZTxBcnJheTx7aW5kZXg6bnVtYmVyLGxlbmd0aDpudW1iZXJ9Pj4oKGFjYywgZmllbGQsIGluZGV4KSA9PiB7XG5cdFx0XHRpZiAoIWZpZWxkIHx8IGZpZWxkID09PSBcIjBcIikge1xuXHRcdFx0XHRjb25zdCBsYXN0TG9uZ2VzdCA9IGFjY1thY2MubGVuZ3RoIC0gMV07XG5cdFx0XHRcdGlmIChsYXN0TG9uZ2VzdCAmJiBsYXN0TG9uZ2VzdC5pbmRleCArIGxhc3RMb25nZXN0Lmxlbmd0aCA9PT0gaW5kZXgpIHtcblx0XHRcdFx0XHRsYXN0TG9uZ2VzdC5sZW5ndGgrKztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhY2MucHVzaCh7IGluZGV4LCBsZW5ndGggOiAxIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYWNjO1xuXHRcdH0sIFtdKTtcblxuXHRcdGNvbnN0IGxvbmdlc3RaZXJvRmllbGRzID0gYWxsWmVyb0ZpZWxkcy5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKVswXTtcblxuXHRcdGxldCBuZXdIb3N0OnN0cmluZztcblx0XHRpZiAobG9uZ2VzdFplcm9GaWVsZHMgJiYgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Y29uc3QgbmV3Rmlyc3QgPSBmaWVsZHMuc2xpY2UoMCwgbG9uZ2VzdFplcm9GaWVsZHMuaW5kZXgpIDtcblx0XHRcdGNvbnN0IG5ld0xhc3QgPSBmaWVsZHMuc2xpY2UobG9uZ2VzdFplcm9GaWVsZHMuaW5kZXggKyBsb25nZXN0WmVyb0ZpZWxkcy5sZW5ndGgpO1xuXHRcdFx0bmV3SG9zdCA9IG5ld0ZpcnN0LmpvaW4oXCI6XCIpICsgXCI6OlwiICsgbmV3TGFzdC5qb2luKFwiOlwiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3SG9zdCA9IGZpZWxkcy5qb2luKFwiOlwiKTtcblx0XHR9XG5cblx0XHRpZiAoem9uZSkge1xuXHRcdFx0bmV3SG9zdCArPSBcIiVcIiArIHpvbmU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG5ld0hvc3Q7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGhvc3Q7XG5cdH1cbn1cblxuY29uc3QgVVJJX1BBUlNFID0gL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KFteXFwvPyNAXSopQCk/KFxcW1teXFwvPyNcXF1dK1xcXXxbXlxcLz8jOl0qKSg/OlxcOihcXGQqKSk/KSk/KFtePyNdKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58XFxufFxccikqKSk/L2k7XG5jb25zdCBOT19NQVRDSF9JU19VTkRFRklORUQgPSAoPFJlZ0V4cE1hdGNoQXJyYXk+KFwiXCIpLm1hdGNoKC8oKXswfS8pKVsxXSA9PT0gdW5kZWZpbmVkO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2UodXJpU3RyaW5nOnN0cmluZywgb3B0aW9uczpVUklPcHRpb25zID0ge30pOlVSSUNvbXBvbmVudHMge1xuXHRjb25zdCBjb21wb25lbnRzOlVSSUNvbXBvbmVudHMgPSB7fTtcblx0Y29uc3QgcHJvdG9jb2wgPSAob3B0aW9ucy5pcmkgIT09IGZhbHNlID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MKTtcblxuXHRpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09IFwic3VmZml4XCIpIHVyaVN0cmluZyA9IChvcHRpb25zLnNjaGVtZSA/IG9wdGlvbnMuc2NoZW1lICsgXCI6XCIgOiBcIlwiKSArIFwiLy9cIiArIHVyaVN0cmluZztcblxuXHRjb25zdCBtYXRjaGVzID0gdXJpU3RyaW5nLm1hdGNoKFVSSV9QQVJTRSk7XG5cblx0aWYgKG1hdGNoZXMpIHtcblx0XHRpZiAoTk9fTUFUQ0hfSVNfVU5ERUZJTkVEKSB7XG5cdFx0XHQvL3N0b3JlIGVhY2ggY29tcG9uZW50XG5cdFx0XHRjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV07XG5cdFx0XHRjb21wb25lbnRzLnVzZXJpbmZvID0gbWF0Y2hlc1szXTtcblx0XHRcdGNvbXBvbmVudHMuaG9zdCA9IG1hdGNoZXNbNF07XG5cdFx0XHRjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG5cdFx0XHRjb21wb25lbnRzLnF1ZXJ5ID0gbWF0Y2hlc1s3XTtcblx0XHRcdGNvbXBvbmVudHMuZnJhZ21lbnQgPSBtYXRjaGVzWzhdO1xuXG5cdFx0XHQvL2ZpeCBwb3J0IG51bWJlclxuXHRcdFx0aWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcblx0XHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gbWF0Y2hlc1s1XTtcblx0XHRcdH1cblx0XHR9IGVsc2UgeyAgLy9JRSBGSVggZm9yIGltcHJvcGVyIFJlZ0V4cCBtYXRjaGluZ1xuXHRcdFx0Ly9zdG9yZSBlYWNoIGNvbXBvbmVudFxuXHRcdFx0Y29tcG9uZW50cy5zY2hlbWUgPSBtYXRjaGVzWzFdIHx8IHVuZGVmaW5lZDtcblx0XHRcdGNvbXBvbmVudHMudXNlcmluZm8gPSAodXJpU3RyaW5nLmluZGV4T2YoXCJAXCIpICE9PSAtMSA/IG1hdGNoZXNbM10gOiB1bmRlZmluZWQpO1xuXHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gKHVyaVN0cmluZy5pbmRleE9mKFwiLy9cIikgIT09IC0xID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZCk7XG5cdFx0XHRjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG5cdFx0XHRjb21wb25lbnRzLnBhdGggPSBtYXRjaGVzWzZdIHx8IFwiXCI7XG5cdFx0XHRjb21wb25lbnRzLnF1ZXJ5ID0gKHVyaVN0cmluZy5pbmRleE9mKFwiP1wiKSAhPT0gLTEgPyBtYXRjaGVzWzddIDogdW5kZWZpbmVkKTtcblx0XHRcdGNvbXBvbmVudHMuZnJhZ21lbnQgPSAodXJpU3RyaW5nLmluZGV4T2YoXCIjXCIpICE9PSAtMSA/IG1hdGNoZXNbOF0gOiB1bmRlZmluZWQpO1xuXG5cdFx0XHQvL2ZpeCBwb3J0IG51bWJlclxuXHRcdFx0aWYgKGlzTmFOKGNvbXBvbmVudHMucG9ydCkpIHtcblx0XHRcdFx0Y29tcG9uZW50cy5wb3J0ID0gKHVyaVN0cmluZy5tYXRjaCgvXFwvXFwvKD86LnxcXG4pKlxcOig/OlxcL3xcXD98XFwjfCQpLykgPyBtYXRjaGVzWzRdIDogdW5kZWZpbmVkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY29tcG9uZW50cy5ob3N0KSB7XG5cdFx0XHQvL25vcm1hbGl6ZSBJUCBob3N0c1xuXHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoY29tcG9uZW50cy5ob3N0LCBwcm90b2NvbCksIHByb3RvY29sKTtcblx0XHR9XG5cblx0XHQvL2RldGVybWluZSByZWZlcmVuY2UgdHlwZVxuXHRcdGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBjb21wb25lbnRzLnBvcnQgPT09IHVuZGVmaW5lZCAmJiAhY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucXVlcnkgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInNhbWUtZG9jdW1lbnRcIjtcblx0XHR9IGVsc2UgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGNvbXBvbmVudHMucmVmZXJlbmNlID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH0gZWxzZSBpZiAoY29tcG9uZW50cy5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjb21wb25lbnRzLnJlZmVyZW5jZSA9IFwiYWJzb2x1dGVcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInVyaVwiO1xuXHRcdH1cblxuXHRcdC8vY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcblx0XHRpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IGNvbXBvbmVudHMucmVmZXJlbmNlKSB7XG5cdFx0XHRjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBpcyBub3QgYSBcIiArIG9wdGlvbnMucmVmZXJlbmNlICsgXCIgcmVmZXJlbmNlLlwiO1xuXHRcdH1cblxuXHRcdC8vZmluZCBzY2hlbWUgaGFuZGxlclxuXHRcdGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcblxuXHRcdC8vY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG5cdFx0aWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0ICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci51bmljb2RlU3VwcG9ydCkpIHtcblx0XHRcdC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuXHRcdFx0aWYgKGNvbXBvbmVudHMuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpKSB7XG5cdFx0XHRcdC8vY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRjb21wb25lbnRzLmhvc3QgPSBwdW55Y29kZS50b0FTQ0lJKGNvbXBvbmVudHMuaG9zdC5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBwY3REZWNDaGFycykudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly9jb252ZXJ0IElSSSAtPiBVUklcblx0XHRcdF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBVUklfUFJPVE9DT0wpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvL25vcm1hbGl6ZSBlbmNvZGluZ3Ncblx0XHRcdF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCk7XG5cdFx0fVxuXG5cdFx0Ly9wZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG5cdFx0aWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuXHRcdFx0c2NoZW1lSGFuZGxlci5wYXJzZShjb21wb25lbnRzLCBvcHRpb25zKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG5cdH1cblxuXHRyZXR1cm4gY29tcG9uZW50cztcbn07XG5cbmZ1bmN0aW9uIF9yZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOnN0cmluZ3x1bmRlZmluZWQge1xuXHRjb25zdCBwcm90b2NvbCA9IChvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0wpO1xuXHRjb25zdCB1cmlUb2tlbnM6QXJyYXk8c3RyaW5nPiA9IFtdO1xuXG5cdGlmIChjb21wb25lbnRzLnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcblx0XHR1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnVzZXJpbmZvKTtcblx0XHR1cmlUb2tlbnMucHVzaChcIkBcIik7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcblx0XHQvL25vcm1hbGl6ZSBJUCBob3N0cywgYWRkIGJyYWNrZXRzIGFuZCBlc2NhcGUgem9uZSBzZXBhcmF0b3IgZm9yIElQdjZcblx0XHR1cmlUb2tlbnMucHVzaChfbm9ybWFsaXplSVB2Nihfbm9ybWFsaXplSVB2NChTdHJpbmcoY29tcG9uZW50cy5ob3N0KSwgcHJvdG9jb2wpLCBwcm90b2NvbCkucmVwbGFjZShwcm90b2NvbC5JUFY2QUREUkVTUywgKF8sICQxLCAkMikgPT4gXCJbXCIgKyAkMSArICgkMiA/IFwiJTI1XCIgKyAkMiA6IFwiXCIpICsgXCJdXCIpKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgY29tcG9uZW50cy5wb3J0ID09PSBcIm51bWJlclwiKSB7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuXHRcdHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMucG9ydC50b1N0cmluZygxMCkpO1xuXHR9XG5cblx0cmV0dXJuIHVyaVRva2Vucy5sZW5ndGggPyB1cmlUb2tlbnMuam9pbihcIlwiKSA6IHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IFJEUzEgPSAvXlxcLlxcLj9cXC8vO1xuY29uc3QgUkRTMiA9IC9eXFwvXFwuKFxcL3wkKS87XG5jb25zdCBSRFMzID0gL15cXC9cXC5cXC4oXFwvfCQpLztcbmNvbnN0IFJEUzQgPSAvXlxcLlxcLj8kLztcbmNvbnN0IFJEUzUgPSAvXlxcLz8oPzoufFxcbikqPyg/PVxcL3wkKS87XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyhpbnB1dDpzdHJpbmcpOnN0cmluZyB7XG5cdGNvbnN0IG91dHB1dDpBcnJheTxzdHJpbmc+ID0gW107XG5cblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xuXHRcdGlmIChpbnB1dC5tYXRjaChSRFMxKSkge1xuXHRcdFx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzEsIFwiXCIpO1xuXHRcdH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMikpIHtcblx0XHRcdGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMyLCBcIi9cIik7XG5cdFx0fSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMzKSkge1xuXHRcdFx0aW5wdXQgPSBpbnB1dC5yZXBsYWNlKFJEUzMsIFwiL1wiKTtcblx0XHRcdG91dHB1dC5wb3AoKTtcblx0XHR9IGVsc2UgaWYgKGlucHV0ID09PSBcIi5cIiB8fCBpbnB1dCA9PT0gXCIuLlwiKSB7XG5cdFx0XHRpbnB1dCA9IFwiXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGltID0gaW5wdXQubWF0Y2goUkRTNSk7XG5cdFx0XHRpZiAoaW0pIHtcblx0XHRcdFx0Y29uc3QgcyA9IGltWzBdO1xuXHRcdFx0XHRpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKTtcblx0XHRcdFx0b3V0cHV0LnB1c2gocyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvblwiKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb3V0cHV0LmpvaW4oXCJcIik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zID0ge30pOnN0cmluZyB7XG5cdGNvbnN0IHByb3RvY29sID0gKG9wdGlvbnMuaXJpID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MKTtcblx0Y29uc3QgdXJpVG9rZW5zOkFycmF5PHN0cmluZz4gPSBbXTtcblxuXHQvL2ZpbmQgc2NoZW1lIGhhbmRsZXJcblx0Y29uc3Qgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudHMuc2NoZW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCldO1xuXG5cdC8vcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgc2VyaWFsaXphdGlvblxuXHRpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSkgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucyk7XG5cblx0aWYgKGNvbXBvbmVudHMuaG9zdCkge1xuXHRcdC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYW4gSVB2NiBhZGRyZXNzXG5cdFx0aWYgKHByb3RvY29sLklQVjZBRERSRVNTLnRlc3QoY29tcG9uZW50cy5ob3N0KSkge1xuXHRcdFx0Ly9UT0RPOiBub3JtYWxpemUgSVB2NiBhZGRyZXNzIGFzIHBlciBSRkMgNTk1MlxuXHRcdH1cblxuXHRcdC8vaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuXHRcdGVsc2UgaWYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSB7XG5cdFx0XHQvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcG9uZW50cy5ob3N0ID0gKCFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShjb21wb25lbnRzLmhvc3QpKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gXCIgKyAoIW9wdGlvbnMuaXJpID8gXCJBU0NJSVwiIDogXCJVbmljb2RlXCIpICsgXCIgdmlhIHB1bnljb2RlOiBcIiArIGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly9ub3JtYWxpemUgZW5jb2Rpbmdcblx0X25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcblxuXHRpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09IFwic3VmZml4XCIgJiYgY29tcG9uZW50cy5zY2hlbWUpIHtcblx0XHR1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnNjaGVtZSk7XG5cdFx0dXJpVG9rZW5zLnB1c2goXCI6XCIpO1xuXHR9XG5cblx0Y29uc3QgYXV0aG9yaXR5ID0gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKTtcblx0aWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSBcInN1ZmZpeFwiKSB7XG5cdFx0XHR1cmlUb2tlbnMucHVzaChcIi8vXCIpO1xuXHRcdH1cblxuXHRcdHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSk7XG5cblx0XHRpZiAoY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5jaGFyQXQoMCkgIT09IFwiL1wiKSB7XG5cdFx0XHR1cmlUb2tlbnMucHVzaChcIi9cIik7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0bGV0IHMgPSBjb21wb25lbnRzLnBhdGg7XG5cblx0XHRpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG5cdFx0XHRzID0gcmVtb3ZlRG90U2VnbWVudHMocyk7XG5cdFx0fVxuXG5cdFx0aWYgKGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzID0gcy5yZXBsYWNlKC9eXFwvXFwvLywgXCIvJTJGXCIpOyAgLy9kb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxuXHRcdH1cblxuXHRcdHVyaVRva2Vucy5wdXNoKHMpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuXHRcdHVyaVRva2Vucy5wdXNoKFwiP1wiKTtcblx0XHR1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnF1ZXJ5KTtcblx0fVxuXG5cdGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcblx0XHR1cmlUb2tlbnMucHVzaChcIiNcIik7XG5cdFx0dXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5mcmFnbWVudCk7XG5cdH1cblxuXHRyZXR1cm4gdXJpVG9rZW5zLmpvaW4oXCJcIik7ICAvL21lcmdlIHRva2VucyBpbnRvIGEgc3RyaW5nXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudHMoYmFzZTpVUklDb21wb25lbnRzLCByZWxhdGl2ZTpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMgPSB7fSwgc2tpcE5vcm1hbGl6YXRpb24/OmJvb2xlYW4pOlVSSUNvbXBvbmVudHMge1xuXHRjb25zdCB0YXJnZXQ6VVJJQ29tcG9uZW50cyA9IHt9O1xuXG5cdGlmICghc2tpcE5vcm1hbGl6YXRpb24pIHtcblx0XHRiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKTsgIC8vbm9ybWFsaXplIGJhc2UgY29tcG9uZW50c1xuXHRcdHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucyk7ICAvL25vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRzXG5cdH1cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0aWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuXHRcdHRhcmdldC5zY2hlbWUgPSByZWxhdGl2ZS5zY2hlbWU7XG5cdFx0Ly90YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuXHRcdHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuXHRcdHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdDtcblx0XHR0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG5cdFx0dGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuXHRcdHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuXHR9IGVsc2Uge1xuXHRcdGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdC8vdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcblx0XHRcdHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuXHRcdFx0dGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0O1xuXHRcdFx0dGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuXHRcdFx0dGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuXHRcdFx0dGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICghcmVsYXRpdmUucGF0aCkge1xuXHRcdFx0XHR0YXJnZXQucGF0aCA9IGJhc2UucGF0aDtcblx0XHRcdFx0aWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXQucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAocmVsYXRpdmUucGF0aC5jaGFyQXQoMCkgPT09IFwiL1wiKSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LnBhdGggPSBcIi9cIiArIHJlbGF0aXZlLnBhdGg7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghYmFzZS5wYXRoKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQucGF0aCA9IHJlbGF0aXZlLnBhdGg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSArIHJlbGF0aXZlLnBhdGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuXHRcdFx0fVxuXHRcdFx0Ly90YXJnZXQuYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG5cdFx0XHR0YXJnZXQudXNlcmluZm8gPSBiYXNlLnVzZXJpbmZvO1xuXHRcdFx0dGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3Q7XG5cdFx0XHR0YXJnZXQucG9ydCA9IGJhc2UucG9ydDtcblx0XHR9XG5cdFx0dGFyZ2V0LnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuXHR9XG5cblx0dGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnQ7XG5cblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKGJhc2VVUkk6c3RyaW5nLCByZWxhdGl2ZVVSSTpzdHJpbmcsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOnN0cmluZyB7XG5cdGNvbnN0IHNjaGVtZWxlc3NPcHRpb25zID0gYXNzaWduKHsgc2NoZW1lIDogJ251bGwnIH0sIG9wdGlvbnMpO1xuXHRyZXR1cm4gc2VyaWFsaXplKHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpLCBzY2hlbWVsZXNzT3B0aW9ucyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHVyaTpzdHJpbmcsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOnN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUodXJpOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOlVSSUNvbXBvbmVudHM7XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHVyaTphbnksIG9wdGlvbnM/OlVSSU9wdGlvbnMpOmFueSB7XG5cdGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG5cdFx0dXJpID0gc2VyaWFsaXplKHBhcnNlKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuXHR9IGVsc2UgaWYgKHR5cGVPZih1cmkpID09PSBcIm9iamVjdFwiKSB7XG5cdFx0dXJpID0gcGFyc2Uoc2VyaWFsaXplKDxVUklDb21wb25lbnRzPnVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuXHR9XG5cblx0cmV0dXJuIHVyaTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbCh1cmlBOnN0cmluZywgdXJpQjpzdHJpbmcsIG9wdGlvbnM/OiBVUklPcHRpb25zKTpib29sZWFuO1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsKHVyaUE6VVJJQ29tcG9uZW50cywgdXJpQjpVUklDb21wb25lbnRzLCBvcHRpb25zPzpVUklPcHRpb25zKTpib29sZWFuO1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsKHVyaUE6YW55LCB1cmlCOmFueSwgb3B0aW9ucz86VVJJT3B0aW9ucyk6Ym9vbGVhbiB7XG5cdGlmICh0eXBlb2YgdXJpQSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdHVyaUEgPSBzZXJpYWxpemUocGFyc2UodXJpQSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuXHR9IGVsc2UgaWYgKHR5cGVPZih1cmlBKSA9PT0gXCJvYmplY3RcIikge1xuXHRcdHVyaUEgPSBzZXJpYWxpemUoPFVSSUNvbXBvbmVudHM+dXJpQSwgb3B0aW9ucyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVyaUIgPT09IFwic3RyaW5nXCIpIHtcblx0XHR1cmlCID0gc2VyaWFsaXplKHBhcnNlKHVyaUIsIG9wdGlvbnMpLCBvcHRpb25zKTtcblx0fSBlbHNlIGlmICh0eXBlT2YodXJpQikgPT09IFwib2JqZWN0XCIpIHtcblx0XHR1cmlCID0gc2VyaWFsaXplKDxVUklDb21wb25lbnRzPnVyaUIsIG9wdGlvbnMpO1xuXHR9XG5cblx0cmV0dXJuIHVyaUEgPT09IHVyaUI7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlQ29tcG9uZW50KHN0cjpzdHJpbmcsIG9wdGlvbnM/OlVSSU9wdGlvbnMpOnN0cmluZyB7XG5cdHJldHVybiBzdHIgJiYgc3RyLnRvU3RyaW5nKCkucmVwbGFjZSgoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLkVTQ0FQRSA6IElSSV9QUk9UT0NPTC5FU0NBUEUpLCBwY3RFbmNDaGFyKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZUNvbXBvbmVudChzdHI6c3RyaW5nLCBvcHRpb25zPzpVUklPcHRpb25zKTpzdHJpbmcge1xuXHRyZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCA6IElSSV9QUk9UT0NPTC5QQ1RfRU5DT0RFRCksIHBjdERlY0NoYXJzKTtcbn07XG4iLCJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuXG5jb25zdCBoYW5kbGVyOlVSSVNjaGVtZUhhbmRsZXIgPSB7XG5cdHNjaGVtZSA6IFwiaHR0cFwiLFxuXG5cdGRvbWFpbkhvc3QgOiB0cnVlLFxuXG5cdHBhcnNlIDogZnVuY3Rpb24gKGNvbXBvbmVudHM6VVJJQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVUklDb21wb25lbnRzIHtcblx0XHQvL3JlcG9ydCBtaXNzaW5nIGhvc3Rcblx0XHRpZiAoIWNvbXBvbmVudHMuaG9zdCkge1xuXHRcdFx0Y29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJIVFRQIFVSSXMgbXVzdCBoYXZlIGEgaG9zdC5cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOlVSSUNvbXBvbmVudHMge1xuXHRcdC8vbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcblx0XHRpZiAoY29tcG9uZW50cy5wb3J0ID09PSAoU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpICE9PSBcImh0dHBzXCIgPyA4MCA6IDQ0MykgfHwgY29tcG9uZW50cy5wb3J0ID09PSBcIlwiKSB7XG5cdFx0XHRjb21wb25lbnRzLnBvcnQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdFxuXHRcdC8vbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG5cdFx0aWYgKCFjb21wb25lbnRzLnBhdGgpIHtcblx0XHRcdGNvbXBvbmVudHMucGF0aCA9IFwiL1wiO1xuXHRcdH1cblxuXHRcdC8vTk9URTogV2UgZG8gbm90IHBhcnNlIHF1ZXJ5IHN0cmluZ3MgZm9yIEhUVFAgVVJJc1xuXHRcdC8vYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG5cdFx0Ly9hbmQgbm90IHRoZSBIVFRQIHNwZWMuXG5cblx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IGh0dHAgZnJvbSBcIi4vaHR0cFwiO1xuXG5jb25zdCBoYW5kbGVyOlVSSVNjaGVtZUhhbmRsZXIgPSB7XG5cdHNjaGVtZSA6IFwiaHR0cHNcIixcblx0ZG9tYWluSG9zdCA6IGh0dHAuZG9tYWluSG9zdCxcblx0cGFyc2UgOiBodHRwLnBhcnNlLFxuXHRzZXJpYWxpemUgOiBodHRwLnNlcmlhbGl6ZVxufVxuXG5leHBvcnQgZGVmYXVsdCBoYW5kbGVyOyIsImltcG9ydCB7IFVSSVNjaGVtZUhhbmRsZXIsIFVSSUNvbXBvbmVudHMsIFVSSU9wdGlvbnMgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgeyBwY3RFbmNDaGFyLCBwY3REZWNDaGFycywgdW5lc2NhcGVDb21wb25lbnQgfSBmcm9tIFwiLi4vdXJpXCI7XG5pbXBvcnQgcHVueWNvZGUgZnJvbSBcInB1bnljb2RlXCI7XG5pbXBvcnQgeyBtZXJnZSwgc3ViZXhwLCB0b1VwcGVyQ2FzZSwgdG9BcnJheSB9IGZyb20gXCIuLi91dGlsXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFpbHRvSGVhZGVycyB7XG5cdFtoZm5hbWU6c3RyaW5nXTpzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYWlsdG9Db21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyB7XG5cdHRvOkFycmF5PHN0cmluZz4sXG5cdGhlYWRlcnM/Ok1haWx0b0hlYWRlcnMsXG5cdHN1YmplY3Q/OnN0cmluZyxcblx0Ym9keT86c3RyaW5nXG59XG5cbmNvbnN0IE86TWFpbHRvSGVhZGVycyA9IHt9O1xuY29uc3QgaXNJUkkgPSB0cnVlO1xuXG4vL1JGQyAzOTg2XG5jb25zdCBVTlJFU0VSVkVEJCQgPSBcIltBLVphLXowLTlcXFxcLVxcXFwuXFxcXF9cXFxcflwiICsgKGlzSVJJID8gXCJcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZcIiA6IFwiXCIpICsgXCJdXCI7XG5jb25zdCBIRVhESUckJCA9IFwiWzAtOUEtRmEtZl1cIjsgIC8vY2FzZS1pbnNlbnNpdGl2ZVxuY29uc3QgUENUX0VOQ09ERUQkID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVs4OUEtRmEtZl1cIiArIEhFWERJRyQkICsgXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSArIFwifFwiICsgc3ViZXhwKFwiJVwiICsgSEVYRElHJCQgKyBIRVhESUckJCkpOyAgLy9leHBhbmRlZFxuXG4vL1JGQyA1MzIyLCBleGNlcHQgdGhlc2Ugc3ltYm9scyBhcyBwZXIgUkZDIDYwNjg6IEAgOiAvID8gIyBbIF0gJiA7ID1cbi8vY29uc3QgQVRFWFQkJCA9IFwiW0EtWmEtejAtOVxcXFwhXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFwvXFxcXD1cXFxcP1xcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVRFWFQkJCA9IFwiW1xcXFx4MDEtXFxcXHgwOFxcXFx4MEJcXFxceDBDXFxcXHgwRS1cXFxceDFGXFxcXHg3Rl1cIjsgIC8vKCVkMS04IC8gJWQxMS0xMiAvICVkMTQtMzEgLyAlZDEyNylcbi8vY29uc3QgUVRFWFQkJCA9IG1lcmdlKFwiW1xcXFx4MjFcXFxceDIzLVxcXFx4NUJcXFxceDVELVxcXFx4N0VdXCIsIE9CU19RVEVYVCQkKTsgIC8vJWQzMyAvICVkMzUtOTEgLyAlZDkzLTEyNiAvIG9icy1xdGV4dFxuLy9jb25zdCBWQ0hBUiQkID0gXCJbXFxcXHgyMS1cXFxceDdFXVwiO1xuLy9jb25zdCBXU1AkJCA9IFwiW1xcXFx4MjBcXFxceDA5XVwiO1xuLy9jb25zdCBPQlNfUVAkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIG1lcmdlKFwiW1xcXFx4MDBcXFxceDBEXFxcXHgwQV1cIiwgT0JTX1FURVhUJCQpKTsgIC8vJWQwIC8gQ1IgLyBMRiAvIG9icy1xdGV4dFxuLy9jb25zdCBGV1MkID0gc3ViZXhwKHN1YmV4cChXU1AkJCArIFwiKlwiICsgXCJcXFxceDBEXFxcXHgwQVwiKSArIFwiP1wiICsgV1NQJCQgKyBcIitcIik7XG4vL2NvbnN0IFFVT1RFRF9QQUlSJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcXFxcXFwiICsgc3ViZXhwKFZDSEFSJCQgKyBcInxcIiArIFdTUCQkKSkgKyBcInxcIiArIE9CU19RUCQpO1xuLy9jb25zdCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIHN1YmV4cChGV1MkICsgXCI/XCIgKyBRQ09OVEVOVCQpICsgXCIqXCIgKyBGV1MkICsgXCI/XCIgKyAnXFxcXFwiJyk7XG5jb25zdCBBVEVYVCQkID0gXCJbQS1aYS16MC05XFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKlxcXFwrXFxcXC1cXFxcXlxcXFxfXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl1cIjtcbmNvbnN0IFFURVhUJCQgPSBcIltcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLVxcXFwuMC05XFxcXDxcXFxcPkEtWlxcXFx4NUUtXFxcXHg3RV1cIjtcbmNvbnN0IFZDSEFSJCQgPSBtZXJnZShRVEVYVCQkLCBcIltcXFxcXFxcIlxcXFxcXFxcXVwiKTtcbmNvbnN0IERPVF9BVE9NX1RFWFQkID0gc3ViZXhwKEFURVhUJCQgKyBcIitcIiArIHN1YmV4cChcIlxcXFwuXCIgKyBBVEVYVCQkICsgXCIrXCIpICsgXCIqXCIpO1xuY29uc3QgUVVPVEVEX1BBSVIkID0gc3ViZXhwKFwiXFxcXFxcXFxcIiArIFZDSEFSJCQpO1xuY29uc3QgUUNPTlRFTlQkID0gc3ViZXhwKFFURVhUJCQgKyBcInxcIiArIFFVT1RFRF9QQUlSJCk7XG5jb25zdCBRVU9URURfU1RSSU5HJCA9IHN1YmV4cCgnXFxcXFwiJyArIFFDT05URU5UJCArIFwiKlwiICsgJ1xcXFxcIicpO1xuXG4vL1JGQyA2MDY4XG5jb25zdCBEVEVYVF9OT19PQlMkJCA9IFwiW1xcXFx4MjEtXFxcXHg1QVxcXFx4NUUtXFxcXHg3RV1cIjsgIC8vJWQzMy05MCAvICVkOTQtMTI2XG5jb25zdCBTT01FX0RFTElNUyQkID0gXCJbXFxcXCFcXFxcJFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXDpcXFxcQF1cIjtcbmNvbnN0IFFDSEFSJCA9IHN1YmV4cChVTlJFU0VSVkVEJCQgKyBcInxcIiArIFBDVF9FTkNPREVEJCArIFwifFwiICsgU09NRV9ERUxJTVMkJCk7XG5jb25zdCBET01BSU4kID0gc3ViZXhwKERPVF9BVE9NX1RFWFQkICsgXCJ8XCIgKyBcIlxcXFxbXCIgKyBEVEVYVF9OT19PQlMkJCArIFwiKlwiICsgXCJcXFxcXVwiKTtcbmNvbnN0IExPQ0FMX1BBUlQkID0gc3ViZXhwKERPVF9BVE9NX1RFWFQkICsgXCJ8XCIgKyBRVU9URURfU1RSSU5HJCk7XG5jb25zdCBBRERSX1NQRUMkID0gc3ViZXhwKExPQ0FMX1BBUlQkICsgXCJcXFxcQFwiICsgRE9NQUlOJCk7XG5jb25zdCBUTyQgPSBzdWJleHAoQUREUl9TUEVDJCArIHN1YmV4cChcIlxcXFwsXCIgKyBBRERSX1NQRUMkKSArIFwiKlwiKTtcbmNvbnN0IEhGTkFNRSQgPSBzdWJleHAoUUNIQVIkICsgXCIqXCIpO1xuY29uc3QgSEZWQUxVRSQgPSBIRk5BTUUkO1xuY29uc3QgSEZJRUxEJCA9IHN1YmV4cChIRk5BTUUkICsgXCJcXFxcPVwiICsgSEZWQUxVRSQpO1xuY29uc3QgSEZJRUxEUzIkID0gc3ViZXhwKEhGSUVMRCQgKyBzdWJleHAoXCJcXFxcJlwiICsgSEZJRUxEJCkgKyBcIipcIik7XG5jb25zdCBIRklFTERTJCA9IHN1YmV4cChcIlxcXFw/XCIgKyBIRklFTERTMiQpO1xuY29uc3QgTUFJTFRPX1VSSSA9IG5ldyBSZWdFeHAoXCJebWFpbHRvXFxcXDpcIiArIFRPJCArIFwiP1wiICsgSEZJRUxEUyQgKyBcIj8kXCIpO1xuXG5jb25zdCBVTlJFU0VSVkVEID0gbmV3IFJlZ0V4cChVTlJFU0VSVkVEJCQsIFwiZ1wiKTtcbmNvbnN0IFBDVF9FTkNPREVEID0gbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQsIFwiZ1wiKTtcbmNvbnN0IE5PVF9MT0NBTF9QQVJUID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgJ1tcXFxcXCJdJywgVkNIQVIkJCksIFwiZ1wiKTtcbmNvbnN0IE5PVF9ET01BSU4gPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFURVhUJCQsIFwiW1xcXFwuXVwiLCBcIltcXFxcW11cIiwgRFRFWFRfTk9fT0JTJCQsIFwiW1xcXFxdXVwiKSwgXCJnXCIpO1xuY29uc3QgTk9UX0hGTkFNRSA9IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkLCBTT01FX0RFTElNUyQkKSwgXCJnXCIpO1xuY29uc3QgTk9UX0hGVkFMVUUgPSBOT1RfSEZOQU1FO1xuY29uc3QgVE8gPSBuZXcgUmVnRXhwKFwiXlwiICsgVE8kICsgXCIkXCIpO1xuY29uc3QgSEZJRUxEUyA9IG5ldyBSZWdFeHAoXCJeXCIgKyBIRklFTERTMiQgKyBcIiRcIik7XG5cbmZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyOnN0cmluZyk6c3RyaW5nIHtcblx0Y29uc3QgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcblx0cmV0dXJuICghZGVjU3RyLm1hdGNoKFVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyKTtcbn1cblxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyPE1haWx0b0NvbXBvbmVudHM+ID0gIHtcblx0c2NoZW1lIDogXCJtYWlsdG9cIixcblxuXHRwYXJzZSA6IGZ1bmN0aW9uIChjb21wb25lbnRzOlVSSUNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6TWFpbHRvQ29tcG9uZW50cyB7XG5cdFx0Y29uc3QgbWFpbHRvQ29tcG9uZW50cyA9IGNvbXBvbmVudHMgYXMgTWFpbHRvQ29tcG9uZW50cztcblx0XHRjb25zdCB0byA9IG1haWx0b0NvbXBvbmVudHMudG8gPSAobWFpbHRvQ29tcG9uZW50cy5wYXRoID8gbWFpbHRvQ29tcG9uZW50cy5wYXRoLnNwbGl0KFwiLFwiKSA6IFtdKTtcblx0XHRtYWlsdG9Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG5cblx0XHRpZiAobWFpbHRvQ29tcG9uZW50cy5xdWVyeSkge1xuXHRcdFx0bGV0IHVua25vd25IZWFkZXJzID0gZmFsc2Vcblx0XHRcdGNvbnN0IGhlYWRlcnM6TWFpbHRvSGVhZGVycyA9IHt9O1xuXHRcdFx0Y29uc3QgaGZpZWxkcyA9IG1haWx0b0NvbXBvbmVudHMucXVlcnkuc3BsaXQoXCImXCIpO1xuXG5cdFx0XHRmb3IgKGxldCB4ID0gMCwgeGwgPSBoZmllbGRzLmxlbmd0aDsgeCA8IHhsOyArK3gpIHtcblx0XHRcdFx0Y29uc3QgaGZpZWxkID0gaGZpZWxkc1t4XS5zcGxpdChcIj1cIik7XG5cblx0XHRcdFx0c3dpdGNoIChoZmllbGRbMF0pIHtcblx0XHRcdFx0XHRjYXNlIFwidG9cIjpcblx0XHRcdFx0XHRcdGNvbnN0IHRvQWRkcnMgPSBoZmllbGRbMV0uc3BsaXQoXCIsXCIpO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgeCA9IDAsIHhsID0gdG9BZGRycy5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRcdFx0XHRcdHRvLnB1c2godG9BZGRyc1t4XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlIFwic3ViamVjdFwiOlxuXHRcdFx0XHRcdFx0bWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgXCJib2R5XCI6XG5cdFx0XHRcdFx0XHRtYWlsdG9Db21wb25lbnRzLmJvZHkgPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdHVua25vd25IZWFkZXJzID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGhlYWRlcnNbdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzBdLCBvcHRpb25zKV0gPSB1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMV0sIG9wdGlvbnMpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHVua25vd25IZWFkZXJzKSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdH1cblxuXHRcdG1haWx0b0NvbXBvbmVudHMucXVlcnkgPSB1bmRlZmluZWQ7XG5cblx0XHRmb3IgKGxldCB4ID0gMCwgeGwgPSB0by5sZW5ndGg7IHggPCB4bDsgKyt4KSB7XG5cdFx0XHRjb25zdCBhZGRyID0gdG9beF0uc3BsaXQoXCJAXCIpO1xuXG5cdFx0XHRhZGRyWzBdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclswXSk7XG5cblx0XHRcdGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCkge1xuXHRcdFx0XHQvL2NvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YWRkclsxXSA9IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRtYWlsdG9Db21wb25lbnRzLmVycm9yID0gbWFpbHRvQ29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWRkclsxXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMV0sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRvW3hdID0gYWRkci5qb2luKFwiQFwiKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFpbHRvQ29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAobWFpbHRvQ29tcG9uZW50czpNYWlsdG9Db21wb25lbnRzLCBvcHRpb25zOlVSSU9wdGlvbnMpOlVSSUNvbXBvbmVudHMge1xuXHRcdGNvbnN0IGNvbXBvbmVudHMgPSBtYWlsdG9Db21wb25lbnRzIGFzIFVSSUNvbXBvbmVudHM7XG5cdFx0Y29uc3QgdG8gPSB0b0FycmF5KG1haWx0b0NvbXBvbmVudHMudG8pO1xuXHRcdGlmICh0bykge1xuXHRcdFx0Zm9yIChsZXQgeCA9IDAsIHhsID0gdG8ubGVuZ3RoOyB4IDwgeGw7ICsreCkge1xuXHRcdFx0XHRjb25zdCB0b0FkZHIgPSBTdHJpbmcodG9beF0pO1xuXHRcdFx0XHRjb25zdCBhdElkeCA9IHRvQWRkci5sYXN0SW5kZXhPZihcIkBcIik7XG5cdFx0XHRcdGNvbnN0IGxvY2FsUGFydCA9ICh0b0FkZHIuc2xpY2UoMCwgYXRJZHgpKS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfTE9DQUxfUEFSVCwgcGN0RW5jQ2hhcik7XG5cdFx0XHRcdGxldCBkb21haW4gPSB0b0FkZHIuc2xpY2UoYXRJZHggKyAxKTtcblxuXHRcdFx0XHQvL2NvbnZlcnQgSUROIHZpYSBwdW55Y29kZVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGRvbWFpbiA9ICghb3B0aW9ucy5pcmkgPyBwdW55Y29kZS50b0FTQ0lJKHVuZXNjYXBlQ29tcG9uZW50KGRvbWFpbiwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSkgOiBwdW55Y29kZS50b1VuaWNvZGUoZG9tYWluKSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkVtYWlsIGFkZHJlc3MncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBcIiArICghb3B0aW9ucy5pcmkgPyBcIkFTQ0lJXCIgOiBcIlVuaWNvZGVcIikgKyBcIiB2aWEgcHVueWNvZGU6IFwiICsgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRvW3hdID0gbG9jYWxQYXJ0ICsgXCJAXCIgKyBkb21haW47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBvbmVudHMucGF0aCA9IHRvLmpvaW4oXCIsXCIpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgfHwge307XG5cblx0XHRpZiAobWFpbHRvQ29tcG9uZW50cy5zdWJqZWN0KSBoZWFkZXJzW1wic3ViamVjdFwiXSA9IG1haWx0b0NvbXBvbmVudHMuc3ViamVjdDtcblx0XHRpZiAobWFpbHRvQ29tcG9uZW50cy5ib2R5KSBoZWFkZXJzW1wiYm9keVwiXSA9IG1haWx0b0NvbXBvbmVudHMuYm9keTtcblxuXHRcdGNvbnN0IGZpZWxkcyA9IFtdO1xuXHRcdGZvciAoY29uc3QgbmFtZSBpbiBoZWFkZXJzKSB7XG5cdFx0XHRpZiAoaGVhZGVyc1tuYW1lXSAhPT0gT1tuYW1lXSkge1xuXHRcdFx0XHRmaWVsZHMucHVzaChcblx0XHRcdFx0XHRuYW1lLnJlcGxhY2UoUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQpLnJlcGxhY2UoUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKS5yZXBsYWNlKE5PVF9IRk5BTUUsIHBjdEVuY0NoYXIpICtcblx0XHRcdFx0XHRcIj1cIiArXG5cdFx0XHRcdFx0aGVhZGVyc1tuYW1lXS5yZXBsYWNlKFBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkKS5yZXBsYWNlKFBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSkucmVwbGFjZShOT1RfSEZWQUxVRSwgcGN0RW5jQ2hhcilcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGZpZWxkcy5sZW5ndGgpIHtcblx0XHRcdGNvbXBvbmVudHMucXVlcnkgPSBmaWVsZHMuam9pbihcIiZcIik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCJpbXBvcnQgeyBVUklTY2hlbWVIYW5kbGVyLCBVUklDb21wb25lbnRzLCBVUklPcHRpb25zIH0gZnJvbSBcIi4uL3VyaVwiO1xuaW1wb3J0IHsgcGN0RW5jQ2hhciwgU0NIRU1FUyB9IGZyb20gXCIuLi91cmlcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVUk5Db21wb25lbnRzIGV4dGVuZHMgVVJJQ29tcG9uZW50cyB7XG5cdG5pZD86c3RyaW5nO1xuXHRuc3M/OnN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVUk5PcHRpb25zIGV4dGVuZHMgVVJJT3B0aW9ucyB7XG5cdG5pZD86c3RyaW5nO1xufVxuXG5jb25zdCBOSUQkID0gXCIoPzpbMC05QS1aYS16XVswLTlBLVphLXpcXFxcLV17MSwzMX0pXCI7XG5jb25zdCBQQ1RfRU5DT0RFRCQgPSBcIig/OlxcXFwlWzAtOUEtRmEtZl17Mn0pXCI7XG5jb25zdCBUUkFOUyQkID0gXCJbMC05QS1aYS16XFxcXChcXFxcKVxcXFwrXFxcXCxcXFxcLVxcXFwuXFxcXDpcXFxcPVxcXFxAXFxcXDtcXFxcJFxcXFxfXFxcXCFcXFxcKlxcXFwnXFxcXC9cXFxcP1xcXFwjXVwiO1xuY29uc3QgTlNTJCA9IFwiKD86KD86XCIgKyBQQ1RfRU5DT0RFRCQgKyBcInxcIiArIFRSQU5TJCQgKyBcIikrKVwiO1xuY29uc3QgVVJOX1NDSEVNRSA9IG5ldyBSZWdFeHAoXCJedXJuXFxcXDooXCIgKyBOSUQkICsgXCIpJFwiKTtcbmNvbnN0IFVSTl9QQVRIID0gbmV3IFJlZ0V4cChcIl4oXCIgKyBOSUQkICsgXCIpXFxcXDooXCIgKyBOU1MkICsgXCIpJFwiKTtcbmNvbnN0IFVSTl9QQVJTRSA9IC9eKFteXFw6XSspXFw6KC4qKS87XG5jb25zdCBVUk5fRVhDTFVERUQgPSAvW1xceDAwLVxceDIwXFxcXFxcXCJcXCZcXDxcXD5cXFtcXF1cXF5cXGBcXHtcXHxcXH1cXH5cXHg3Ri1cXHhGRl0vZztcblxuLy9SRkMgMjE0MVxuY29uc3QgaGFuZGxlcjpVUklTY2hlbWVIYW5kbGVyPFVSTkNvbXBvbmVudHMsVVJOT3B0aW9ucz4gPSB7XG5cdHNjaGVtZSA6IFwidXJuXCIsXG5cblx0cGFyc2UgOiBmdW5jdGlvbiAoY29tcG9uZW50czpVUklDb21wb25lbnRzLCBvcHRpb25zOlVSTk9wdGlvbnMpOlVSTkNvbXBvbmVudHMge1xuXHRcdGNvbnN0IG1hdGNoZXMgPSBjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5wYXRoLm1hdGNoKFVSTl9QQVJTRSk7XG5cdFx0bGV0IHVybkNvbXBvbmVudHMgPSBjb21wb25lbnRzIGFzIFVSTkNvbXBvbmVudHM7XG5cblx0XHRpZiAobWF0Y2hlcykge1xuXHRcdFx0Y29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50cy5zY2hlbWUgfHwgXCJ1cm5cIjtcblx0XHRcdGNvbnN0IG5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvbnN0IG5zcyA9IG1hdGNoZXNbMl07XG5cdFx0XHRjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgbmlkfWA7XG5cdFx0XHRjb25zdCBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1t1cm5TY2hlbWVdO1xuXG5cdFx0XHR1cm5Db21wb25lbnRzLm5pZCA9IG5pZDtcblx0XHRcdHVybkNvbXBvbmVudHMubnNzID0gbnNzO1xuXHRcdFx0dXJuQ29tcG9uZW50cy5wYXRoID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoc2NoZW1lSGFuZGxlcikge1xuXHRcdFx0XHR1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5wYXJzZSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSBhcyBVUk5Db21wb25lbnRzO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1cm5Db21wb25lbnRzLmVycm9yID0gdXJuQ29tcG9uZW50cy5lcnJvciB8fCBcIlVSTiBjYW4gbm90IGJlIHBhcnNlZC5cIjtcblx0XHR9XG5cblx0XHRyZXR1cm4gdXJuQ29tcG9uZW50cztcblx0fSxcblxuXHRzZXJpYWxpemUgOiBmdW5jdGlvbiAodXJuQ29tcG9uZW50czpVUk5Db21wb25lbnRzLCBvcHRpb25zOlVSTk9wdGlvbnMpOlVSSUNvbXBvbmVudHMge1xuXHRcdGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG5cdFx0Y29uc3QgbmlkID0gdXJuQ29tcG9uZW50cy5uaWQ7XG5cdFx0Y29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gO1xuXHRcdGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTW3VyblNjaGVtZV07XG5cblx0XHRpZiAoc2NoZW1lSGFuZGxlcikge1xuXHRcdFx0dXJuQ29tcG9uZW50cyA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIGFzIFVSTkNvbXBvbmVudHM7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdXJpQ29tcG9uZW50cyA9IHVybkNvbXBvbmVudHMgYXMgVVJJQ29tcG9uZW50cztcblx0XHRjb25zdCBuc3MgPSB1cm5Db21wb25lbnRzLm5zcztcblx0XHR1cmlDb21wb25lbnRzLnBhdGggPSBgJHtuaWQgfHwgb3B0aW9ucy5uaWR9OiR7bnNzfWA7XG5cblx0XHRyZXR1cm4gdXJpQ29tcG9uZW50cztcblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGhhbmRsZXI7IiwiaW1wb3J0IHsgVVJJU2NoZW1lSGFuZGxlciwgVVJJQ29tcG9uZW50cywgVVJJT3B0aW9ucyB9IGZyb20gXCIuLi91cmlcIjtcbmltcG9ydCB7IFVSTkNvbXBvbmVudHMgfSBmcm9tIFwiLi91cm5cIjtcbmltcG9ydCB7IFNDSEVNRVMgfSBmcm9tIFwiLi4vdXJpXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVVVJRENvbXBvbmVudHMgZXh0ZW5kcyBVUk5Db21wb25lbnRzIHtcblx0dXVpZD86IHN0cmluZztcbn1cblxuY29uc3QgVVVJRCA9IC9eWzAtOUEtRmEtZl17OH0oPzpcXC1bMC05QS1GYS1mXXs0fSl7M31cXC1bMC05QS1GYS1mXXsxMn0kLztcbmNvbnN0IFVVSURfUEFSU0UgPSAvXlswLTlBLUZhLWZcXC1dezM2fS87XG5cbi8vUkZDIDQxMjJcbmNvbnN0IGhhbmRsZXI6VVJJU2NoZW1lSGFuZGxlcjxVVUlEQ29tcG9uZW50cywgVVJJT3B0aW9ucywgVVJOQ29tcG9uZW50cz4gPSB7XG5cdHNjaGVtZSA6IFwidXJuOnV1aWRcIixcblxuXHRwYXJzZSA6IGZ1bmN0aW9uICh1cm5Db21wb25lbnRzOlVSTkNvbXBvbmVudHMsIG9wdGlvbnM6VVJJT3B0aW9ucyk6VVVJRENvbXBvbmVudHMge1xuXHRcdGNvbnN0IHV1aWRDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cyBhcyBVVUlEQ29tcG9uZW50cztcblx0XHR1dWlkQ29tcG9uZW50cy51dWlkID0gdXVpZENvbXBvbmVudHMubnNzO1xuXHRcdHV1aWRDb21wb25lbnRzLm5zcyA9IHVuZGVmaW5lZDtcblxuXHRcdGlmICghb3B0aW9ucy50b2xlcmFudCAmJiAoIXV1aWRDb21wb25lbnRzLnV1aWQgfHwgIXV1aWRDb21wb25lbnRzLnV1aWQubWF0Y2goVVVJRCkpKSB7XG5cdFx0XHR1dWlkQ29tcG9uZW50cy5lcnJvciA9IHV1aWRDb21wb25lbnRzLmVycm9yIHx8IFwiVVVJRCBpcyBub3QgdmFsaWQuXCI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHV1aWRDb21wb25lbnRzO1xuXHR9LFxuXG5cdHNlcmlhbGl6ZSA6IGZ1bmN0aW9uICh1dWlkQ29tcG9uZW50czpVVUlEQ29tcG9uZW50cywgb3B0aW9uczpVUklPcHRpb25zKTpVUk5Db21wb25lbnRzIHtcblx0XHRjb25zdCB1cm5Db21wb25lbnRzID0gdXVpZENvbXBvbmVudHMgYXMgVVJOQ29tcG9uZW50cztcblx0XHQvL25vcm1hbGl6ZSBVVUlEXG5cdFx0dXJuQ29tcG9uZW50cy5uc3MgPSAodXVpZENvbXBvbmVudHMudXVpZCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiB1cm5Db21wb25lbnRzO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgaGFuZGxlcjsiLCJpbXBvcnQgeyBTQ0hFTUVTIH0gZnJvbSBcIi4vdXJpXCI7XG5cbmltcG9ydCBodHRwIGZyb20gXCIuL3NjaGVtZXMvaHR0cFwiO1xuU0NIRU1FU1todHRwLnNjaGVtZV0gPSBodHRwO1xuXG5pbXBvcnQgaHR0cHMgZnJvbSBcIi4vc2NoZW1lcy9odHRwc1wiO1xuU0NIRU1FU1todHRwcy5zY2hlbWVdID0gaHR0cHM7XG5cbmltcG9ydCBtYWlsdG8gZnJvbSBcIi4vc2NoZW1lcy9tYWlsdG9cIjtcblNDSEVNRVNbbWFpbHRvLnNjaGVtZV0gPSBtYWlsdG87XG5cbmltcG9ydCB1cm4gZnJvbSBcIi4vc2NoZW1lcy91cm5cIjtcblNDSEVNRVNbdXJuLnNjaGVtZV0gPSB1cm47XG5cbmltcG9ydCB1dWlkIGZyb20gXCIuL3NjaGVtZXMvdXJuLXV1aWRcIjtcblNDSEVNRVNbdXVpZC5zY2hlbWVdID0gdXVpZDtcblxuZXhwb3J0ICogZnJvbSBcIi4vdXJpXCI7XG4iLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==